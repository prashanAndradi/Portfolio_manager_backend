
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model account_types
 * 
 */
export type account_types = $Result.DefaultSelection<Prisma.$account_typesPayload>
/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model brokers
 * 
 */
export type brokers = $Result.DefaultSelection<Prisma.$brokersPayload>
/**
 * Model chart_of_accounts
 * 
 */
export type chart_of_accounts = $Result.DefaultSelection<Prisma.$chart_of_accountsPayload>
/**
 * Model counterparty_limits
 * 
 */
export type counterparty_limits = $Result.DefaultSelection<Prisma.$counterparty_limitsPayload>
/**
 * Model counterparty_master_individual
 * 
 */
export type counterparty_master_individual = $Result.DefaultSelection<Prisma.$counterparty_master_individualPayload>
/**
 * Model counterparty_master_joint
 * 
 */
export type counterparty_master_joint = $Result.DefaultSelection<Prisma.$counterparty_master_jointPayload>
/**
 * Model gsec
 * 
 */
export type gsec = $Result.DefaultSelection<Prisma.$gsecPayload>
/**
 * Model isin_coupon_schedule
 * 
 */
export type isin_coupon_schedule = $Result.DefaultSelection<Prisma.$isin_coupon_schedulePayload>
/**
 * Model isin_master
 * 
 */
export type isin_master = $Result.DefaultSelection<Prisma.$isin_masterPayload>
/**
 * Model ledger_entries
 * 
 */
export type ledger_entries = $Result.DefaultSelection<Prisma.$ledger_entriesPayload>
/**
 * Model money_market_deals
 * 
 */
export type money_market_deals = $Result.DefaultSelection<Prisma.$money_market_dealsPayload>
/**
 * Model portfolio_master
 * 
 */
export type portfolio_master = $Result.DefaultSelection<Prisma.$portfolio_masterPayload>
/**
 * Model securities
 * 
 */
export type securities = $Result.DefaultSelection<Prisma.$securitiesPayload>
/**
 * Model settlement_accounts
 * 
 */
export type settlement_accounts = $Result.DefaultSelection<Prisma.$settlement_accountsPayload>
/**
 * Model strategy_master
 * 
 */
export type strategy_master = $Result.DefaultSelection<Prisma.$strategy_masterPayload>
/**
 * Model transaction_types
 * 
 */
export type transaction_types = $Result.DefaultSelection<Prisma.$transaction_typesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const account_types_category: {
  asset: 'asset',
  liability: 'liability',
  equity: 'equity',
  revenue: 'revenue',
  expense: 'expense'
};

export type account_types_category = (typeof account_types_category)[keyof typeof account_types_category]


export const counterparty_limits_counterparty_type: {
  individual: 'individual',
  joint: 'joint'
};

export type counterparty_limits_counterparty_type = (typeof counterparty_limits_counterparty_type)[keyof typeof counterparty_limits_counterparty_type]


export const users_role: {
  user: 'user',
  authorizer: 'authorizer'
};

export type users_role = (typeof users_role)[keyof typeof users_role]


export const money_market_deals_counterparty_type: {
  individual: 'individual',
  joint: 'joint'
};

export type money_market_deals_counterparty_type = (typeof money_market_deals_counterparty_type)[keyof typeof money_market_deals_counterparty_type]


export const portfolio_master_status: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type portfolio_master_status = (typeof portfolio_master_status)[keyof typeof portfolio_master_status]


export const portfolio_master_risk_profile: {
  Conservative: 'Conservative',
  Moderate: 'Moderate',
  Aggressive: 'Aggressive'
};

export type portfolio_master_risk_profile = (typeof portfolio_master_risk_profile)[keyof typeof portfolio_master_risk_profile]


export const portfolio_master_investment_horizon: {
  Short_term: 'Short_term',
  Medium_term: 'Medium_term',
  Long_term: 'Long_term'
};

export type portfolio_master_investment_horizon = (typeof portfolio_master_investment_horizon)[keyof typeof portfolio_master_investment_horizon]


export const transactions_authorization_status: {
  pending: 'pending',
  authorized: 'authorized',
  rejected: 'rejected'
};

export type transactions_authorization_status = (typeof transactions_authorization_status)[keyof typeof transactions_authorization_status]

}

export type account_types_category = $Enums.account_types_category

export const account_types_category: typeof $Enums.account_types_category

export type counterparty_limits_counterparty_type = $Enums.counterparty_limits_counterparty_type

export const counterparty_limits_counterparty_type: typeof $Enums.counterparty_limits_counterparty_type

export type users_role = $Enums.users_role

export const users_role: typeof $Enums.users_role

export type money_market_deals_counterparty_type = $Enums.money_market_deals_counterparty_type

export const money_market_deals_counterparty_type: typeof $Enums.money_market_deals_counterparty_type

export type portfolio_master_status = $Enums.portfolio_master_status

export const portfolio_master_status: typeof $Enums.portfolio_master_status

export type portfolio_master_risk_profile = $Enums.portfolio_master_risk_profile

export const portfolio_master_risk_profile: typeof $Enums.portfolio_master_risk_profile

export type portfolio_master_investment_horizon = $Enums.portfolio_master_investment_horizon

export const portfolio_master_investment_horizon: typeof $Enums.portfolio_master_investment_horizon

export type transactions_authorization_status = $Enums.transactions_authorization_status

export const transactions_authorization_status: typeof $Enums.transactions_authorization_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Account_types
 * const account_types = await prisma.account_types.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Account_types
   * const account_types = await prisma.account_types.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account_types`: Exposes CRUD operations for the **account_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Account_types
    * const account_types = await prisma.account_types.findMany()
    * ```
    */
  get account_types(): Prisma.account_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brokers`: Exposes CRUD operations for the **brokers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brokers
    * const brokers = await prisma.brokers.findMany()
    * ```
    */
  get brokers(): Prisma.brokersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chart_of_accounts`: Exposes CRUD operations for the **chart_of_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chart_of_accounts
    * const chart_of_accounts = await prisma.chart_of_accounts.findMany()
    * ```
    */
  get chart_of_accounts(): Prisma.chart_of_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counterparty_limits`: Exposes CRUD operations for the **counterparty_limits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counterparty_limits
    * const counterparty_limits = await prisma.counterparty_limits.findMany()
    * ```
    */
  get counterparty_limits(): Prisma.counterparty_limitsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counterparty_master_individual`: Exposes CRUD operations for the **counterparty_master_individual** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counterparty_master_individuals
    * const counterparty_master_individuals = await prisma.counterparty_master_individual.findMany()
    * ```
    */
  get counterparty_master_individual(): Prisma.counterparty_master_individualDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counterparty_master_joint`: Exposes CRUD operations for the **counterparty_master_joint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counterparty_master_joints
    * const counterparty_master_joints = await prisma.counterparty_master_joint.findMany()
    * ```
    */
  get counterparty_master_joint(): Prisma.counterparty_master_jointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gsec`: Exposes CRUD operations for the **gsec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gsecs
    * const gsecs = await prisma.gsec.findMany()
    * ```
    */
  get gsec(): Prisma.gsecDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.isin_coupon_schedule`: Exposes CRUD operations for the **isin_coupon_schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Isin_coupon_schedules
    * const isin_coupon_schedules = await prisma.isin_coupon_schedule.findMany()
    * ```
    */
  get isin_coupon_schedule(): Prisma.isin_coupon_scheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.isin_master`: Exposes CRUD operations for the **isin_master** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Isin_masters
    * const isin_masters = await prisma.isin_master.findMany()
    * ```
    */
  get isin_master(): Prisma.isin_masterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ledger_entries`: Exposes CRUD operations for the **ledger_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ledger_entries
    * const ledger_entries = await prisma.ledger_entries.findMany()
    * ```
    */
  get ledger_entries(): Prisma.ledger_entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.money_market_deals`: Exposes CRUD operations for the **money_market_deals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Money_market_deals
    * const money_market_deals = await prisma.money_market_deals.findMany()
    * ```
    */
  get money_market_deals(): Prisma.money_market_dealsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolio_master`: Exposes CRUD operations for the **portfolio_master** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolio_masters
    * const portfolio_masters = await prisma.portfolio_master.findMany()
    * ```
    */
  get portfolio_master(): Prisma.portfolio_masterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securities`: Exposes CRUD operations for the **securities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Securities
    * const securities = await prisma.securities.findMany()
    * ```
    */
  get securities(): Prisma.securitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settlement_accounts`: Exposes CRUD operations for the **settlement_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settlement_accounts
    * const settlement_accounts = await prisma.settlement_accounts.findMany()
    * ```
    */
  get settlement_accounts(): Prisma.settlement_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strategy_master`: Exposes CRUD operations for the **strategy_master** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strategy_masters
    * const strategy_masters = await prisma.strategy_master.findMany()
    * ```
    */
  get strategy_master(): Prisma.strategy_masterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction_types`: Exposes CRUD operations for the **transaction_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaction_types
    * const transaction_types = await prisma.transaction_types.findMany()
    * ```
    */
  get transaction_types(): Prisma.transaction_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.0
   * Query Engine version: aee10d5a411e4360c6d3445ce4810ca65adbf3e8
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    account_types: 'account_types',
    accounts: 'accounts',
    brokers: 'brokers',
    chart_of_accounts: 'chart_of_accounts',
    counterparty_limits: 'counterparty_limits',
    counterparty_master_individual: 'counterparty_master_individual',
    counterparty_master_joint: 'counterparty_master_joint',
    gsec: 'gsec',
    isin_coupon_schedule: 'isin_coupon_schedule',
    isin_master: 'isin_master',
    ledger_entries: 'ledger_entries',
    money_market_deals: 'money_market_deals',
    portfolio_master: 'portfolio_master',
    securities: 'securities',
    settlement_accounts: 'settlement_accounts',
    strategy_master: 'strategy_master',
    transaction_types: 'transaction_types',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account_types" | "accounts" | "brokers" | "chart_of_accounts" | "counterparty_limits" | "counterparty_master_individual" | "counterparty_master_joint" | "gsec" | "isin_coupon_schedule" | "isin_master" | "ledger_entries" | "money_market_deals" | "portfolio_master" | "securities" | "settlement_accounts" | "strategy_master" | "transaction_types" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      account_types: {
        payload: Prisma.$account_typesPayload<ExtArgs>
        fields: Prisma.account_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.account_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.account_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>
          }
          findFirst: {
            args: Prisma.account_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.account_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>
          }
          findMany: {
            args: Prisma.account_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>[]
          }
          create: {
            args: Prisma.account_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>
          }
          createMany: {
            args: Prisma.account_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.account_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>
          }
          update: {
            args: Prisma.account_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>
          }
          deleteMany: {
            args: Prisma.account_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.account_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.account_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$account_typesPayload>
          }
          aggregate: {
            args: Prisma.Account_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount_types>
          }
          groupBy: {
            args: Prisma.account_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Account_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.account_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Account_typesCountAggregateOutputType> | number
          }
        }
      }
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      brokers: {
        payload: Prisma.$brokersPayload<ExtArgs>
        fields: Prisma.brokersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brokersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brokersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>
          }
          findFirst: {
            args: Prisma.brokersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brokersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>
          }
          findMany: {
            args: Prisma.brokersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>[]
          }
          create: {
            args: Prisma.brokersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>
          }
          createMany: {
            args: Prisma.brokersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.brokersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>
          }
          update: {
            args: Prisma.brokersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>
          }
          deleteMany: {
            args: Prisma.brokersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brokersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.brokersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brokersPayload>
          }
          aggregate: {
            args: Prisma.BrokersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrokers>
          }
          groupBy: {
            args: Prisma.brokersGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrokersGroupByOutputType>[]
          }
          count: {
            args: Prisma.brokersCountArgs<ExtArgs>
            result: $Utils.Optional<BrokersCountAggregateOutputType> | number
          }
        }
      }
      chart_of_accounts: {
        payload: Prisma.$chart_of_accountsPayload<ExtArgs>
        fields: Prisma.chart_of_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chart_of_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chart_of_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>
          }
          findFirst: {
            args: Prisma.chart_of_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chart_of_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>
          }
          findMany: {
            args: Prisma.chart_of_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>[]
          }
          create: {
            args: Prisma.chart_of_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>
          }
          createMany: {
            args: Prisma.chart_of_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.chart_of_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>
          }
          update: {
            args: Prisma.chart_of_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>
          }
          deleteMany: {
            args: Prisma.chart_of_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chart_of_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chart_of_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chart_of_accountsPayload>
          }
          aggregate: {
            args: Prisma.Chart_of_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChart_of_accounts>
          }
          groupBy: {
            args: Prisma.chart_of_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chart_of_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chart_of_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Chart_of_accountsCountAggregateOutputType> | number
          }
        }
      }
      counterparty_limits: {
        payload: Prisma.$counterparty_limitsPayload<ExtArgs>
        fields: Prisma.counterparty_limitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counterparty_limitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counterparty_limitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>
          }
          findFirst: {
            args: Prisma.counterparty_limitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counterparty_limitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>
          }
          findMany: {
            args: Prisma.counterparty_limitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>[]
          }
          create: {
            args: Prisma.counterparty_limitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>
          }
          createMany: {
            args: Prisma.counterparty_limitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.counterparty_limitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>
          }
          update: {
            args: Prisma.counterparty_limitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>
          }
          deleteMany: {
            args: Prisma.counterparty_limitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.counterparty_limitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.counterparty_limitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_limitsPayload>
          }
          aggregate: {
            args: Prisma.Counterparty_limitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounterparty_limits>
          }
          groupBy: {
            args: Prisma.counterparty_limitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Counterparty_limitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.counterparty_limitsCountArgs<ExtArgs>
            result: $Utils.Optional<Counterparty_limitsCountAggregateOutputType> | number
          }
        }
      }
      counterparty_master_individual: {
        payload: Prisma.$counterparty_master_individualPayload<ExtArgs>
        fields: Prisma.counterparty_master_individualFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counterparty_master_individualFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counterparty_master_individualFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>
          }
          findFirst: {
            args: Prisma.counterparty_master_individualFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counterparty_master_individualFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>
          }
          findMany: {
            args: Prisma.counterparty_master_individualFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>[]
          }
          create: {
            args: Prisma.counterparty_master_individualCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>
          }
          createMany: {
            args: Prisma.counterparty_master_individualCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.counterparty_master_individualDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>
          }
          update: {
            args: Prisma.counterparty_master_individualUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>
          }
          deleteMany: {
            args: Prisma.counterparty_master_individualDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.counterparty_master_individualUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.counterparty_master_individualUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_individualPayload>
          }
          aggregate: {
            args: Prisma.Counterparty_master_individualAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounterparty_master_individual>
          }
          groupBy: {
            args: Prisma.counterparty_master_individualGroupByArgs<ExtArgs>
            result: $Utils.Optional<Counterparty_master_individualGroupByOutputType>[]
          }
          count: {
            args: Prisma.counterparty_master_individualCountArgs<ExtArgs>
            result: $Utils.Optional<Counterparty_master_individualCountAggregateOutputType> | number
          }
        }
      }
      counterparty_master_joint: {
        payload: Prisma.$counterparty_master_jointPayload<ExtArgs>
        fields: Prisma.counterparty_master_jointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counterparty_master_jointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counterparty_master_jointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>
          }
          findFirst: {
            args: Prisma.counterparty_master_jointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counterparty_master_jointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>
          }
          findMany: {
            args: Prisma.counterparty_master_jointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>[]
          }
          create: {
            args: Prisma.counterparty_master_jointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>
          }
          createMany: {
            args: Prisma.counterparty_master_jointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.counterparty_master_jointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>
          }
          update: {
            args: Prisma.counterparty_master_jointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>
          }
          deleteMany: {
            args: Prisma.counterparty_master_jointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.counterparty_master_jointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.counterparty_master_jointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counterparty_master_jointPayload>
          }
          aggregate: {
            args: Prisma.Counterparty_master_jointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounterparty_master_joint>
          }
          groupBy: {
            args: Prisma.counterparty_master_jointGroupByArgs<ExtArgs>
            result: $Utils.Optional<Counterparty_master_jointGroupByOutputType>[]
          }
          count: {
            args: Prisma.counterparty_master_jointCountArgs<ExtArgs>
            result: $Utils.Optional<Counterparty_master_jointCountAggregateOutputType> | number
          }
        }
      }
      gsec: {
        payload: Prisma.$gsecPayload<ExtArgs>
        fields: Prisma.gsecFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gsecFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gsecFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>
          }
          findFirst: {
            args: Prisma.gsecFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gsecFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>
          }
          findMany: {
            args: Prisma.gsecFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>[]
          }
          create: {
            args: Prisma.gsecCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>
          }
          createMany: {
            args: Prisma.gsecCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gsecDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>
          }
          update: {
            args: Prisma.gsecUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>
          }
          deleteMany: {
            args: Prisma.gsecDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gsecUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gsecUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gsecPayload>
          }
          aggregate: {
            args: Prisma.GsecAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGsec>
          }
          groupBy: {
            args: Prisma.gsecGroupByArgs<ExtArgs>
            result: $Utils.Optional<GsecGroupByOutputType>[]
          }
          count: {
            args: Prisma.gsecCountArgs<ExtArgs>
            result: $Utils.Optional<GsecCountAggregateOutputType> | number
          }
        }
      }
      isin_coupon_schedule: {
        payload: Prisma.$isin_coupon_schedulePayload<ExtArgs>
        fields: Prisma.isin_coupon_scheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.isin_coupon_scheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.isin_coupon_scheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>
          }
          findFirst: {
            args: Prisma.isin_coupon_scheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.isin_coupon_scheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>
          }
          findMany: {
            args: Prisma.isin_coupon_scheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>[]
          }
          create: {
            args: Prisma.isin_coupon_scheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>
          }
          createMany: {
            args: Prisma.isin_coupon_scheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.isin_coupon_scheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>
          }
          update: {
            args: Prisma.isin_coupon_scheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>
          }
          deleteMany: {
            args: Prisma.isin_coupon_scheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.isin_coupon_scheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.isin_coupon_scheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_coupon_schedulePayload>
          }
          aggregate: {
            args: Prisma.Isin_coupon_scheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIsin_coupon_schedule>
          }
          groupBy: {
            args: Prisma.isin_coupon_scheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Isin_coupon_scheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.isin_coupon_scheduleCountArgs<ExtArgs>
            result: $Utils.Optional<Isin_coupon_scheduleCountAggregateOutputType> | number
          }
        }
      }
      isin_master: {
        payload: Prisma.$isin_masterPayload<ExtArgs>
        fields: Prisma.isin_masterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.isin_masterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.isin_masterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>
          }
          findFirst: {
            args: Prisma.isin_masterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.isin_masterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>
          }
          findMany: {
            args: Prisma.isin_masterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>[]
          }
          create: {
            args: Prisma.isin_masterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>
          }
          createMany: {
            args: Prisma.isin_masterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.isin_masterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>
          }
          update: {
            args: Prisma.isin_masterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>
          }
          deleteMany: {
            args: Prisma.isin_masterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.isin_masterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.isin_masterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$isin_masterPayload>
          }
          aggregate: {
            args: Prisma.Isin_masterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIsin_master>
          }
          groupBy: {
            args: Prisma.isin_masterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Isin_masterGroupByOutputType>[]
          }
          count: {
            args: Prisma.isin_masterCountArgs<ExtArgs>
            result: $Utils.Optional<Isin_masterCountAggregateOutputType> | number
          }
        }
      }
      ledger_entries: {
        payload: Prisma.$ledger_entriesPayload<ExtArgs>
        fields: Prisma.ledger_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ledger_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ledger_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>
          }
          findFirst: {
            args: Prisma.ledger_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ledger_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>
          }
          findMany: {
            args: Prisma.ledger_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>[]
          }
          create: {
            args: Prisma.ledger_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>
          }
          createMany: {
            args: Prisma.ledger_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ledger_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>
          }
          update: {
            args: Prisma.ledger_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>
          }
          deleteMany: {
            args: Prisma.ledger_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ledger_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ledger_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ledger_entriesPayload>
          }
          aggregate: {
            args: Prisma.Ledger_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedger_entries>
          }
          groupBy: {
            args: Prisma.ledger_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ledger_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ledger_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Ledger_entriesCountAggregateOutputType> | number
          }
        }
      }
      money_market_deals: {
        payload: Prisma.$money_market_dealsPayload<ExtArgs>
        fields: Prisma.money_market_dealsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.money_market_dealsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.money_market_dealsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>
          }
          findFirst: {
            args: Prisma.money_market_dealsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.money_market_dealsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>
          }
          findMany: {
            args: Prisma.money_market_dealsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>[]
          }
          create: {
            args: Prisma.money_market_dealsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>
          }
          createMany: {
            args: Prisma.money_market_dealsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.money_market_dealsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>
          }
          update: {
            args: Prisma.money_market_dealsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>
          }
          deleteMany: {
            args: Prisma.money_market_dealsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.money_market_dealsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.money_market_dealsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$money_market_dealsPayload>
          }
          aggregate: {
            args: Prisma.Money_market_dealsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoney_market_deals>
          }
          groupBy: {
            args: Prisma.money_market_dealsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Money_market_dealsGroupByOutputType>[]
          }
          count: {
            args: Prisma.money_market_dealsCountArgs<ExtArgs>
            result: $Utils.Optional<Money_market_dealsCountAggregateOutputType> | number
          }
        }
      }
      portfolio_master: {
        payload: Prisma.$portfolio_masterPayload<ExtArgs>
        fields: Prisma.portfolio_masterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.portfolio_masterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.portfolio_masterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>
          }
          findFirst: {
            args: Prisma.portfolio_masterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.portfolio_masterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>
          }
          findMany: {
            args: Prisma.portfolio_masterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>[]
          }
          create: {
            args: Prisma.portfolio_masterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>
          }
          createMany: {
            args: Prisma.portfolio_masterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.portfolio_masterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>
          }
          update: {
            args: Prisma.portfolio_masterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>
          }
          deleteMany: {
            args: Prisma.portfolio_masterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.portfolio_masterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.portfolio_masterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolio_masterPayload>
          }
          aggregate: {
            args: Prisma.Portfolio_masterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio_master>
          }
          groupBy: {
            args: Prisma.portfolio_masterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Portfolio_masterGroupByOutputType>[]
          }
          count: {
            args: Prisma.portfolio_masterCountArgs<ExtArgs>
            result: $Utils.Optional<Portfolio_masterCountAggregateOutputType> | number
          }
        }
      }
      securities: {
        payload: Prisma.$securitiesPayload<ExtArgs>
        fields: Prisma.securitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.securitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.securitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          findFirst: {
            args: Prisma.securitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.securitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          findMany: {
            args: Prisma.securitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>[]
          }
          create: {
            args: Prisma.securitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          createMany: {
            args: Prisma.securitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.securitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          update: {
            args: Prisma.securitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          deleteMany: {
            args: Prisma.securitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.securitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.securitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          aggregate: {
            args: Prisma.SecuritiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurities>
          }
          groupBy: {
            args: Prisma.securitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecuritiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.securitiesCountArgs<ExtArgs>
            result: $Utils.Optional<SecuritiesCountAggregateOutputType> | number
          }
        }
      }
      settlement_accounts: {
        payload: Prisma.$settlement_accountsPayload<ExtArgs>
        fields: Prisma.settlement_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settlement_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settlement_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>
          }
          findFirst: {
            args: Prisma.settlement_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settlement_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>
          }
          findMany: {
            args: Prisma.settlement_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>[]
          }
          create: {
            args: Prisma.settlement_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>
          }
          createMany: {
            args: Prisma.settlement_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settlement_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>
          }
          update: {
            args: Prisma.settlement_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>
          }
          deleteMany: {
            args: Prisma.settlement_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settlement_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settlement_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settlement_accountsPayload>
          }
          aggregate: {
            args: Prisma.Settlement_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlement_accounts>
          }
          groupBy: {
            args: Prisma.settlement_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Settlement_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settlement_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Settlement_accountsCountAggregateOutputType> | number
          }
        }
      }
      strategy_master: {
        payload: Prisma.$strategy_masterPayload<ExtArgs>
        fields: Prisma.strategy_masterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.strategy_masterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.strategy_masterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>
          }
          findFirst: {
            args: Prisma.strategy_masterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.strategy_masterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>
          }
          findMany: {
            args: Prisma.strategy_masterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>[]
          }
          create: {
            args: Prisma.strategy_masterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>
          }
          createMany: {
            args: Prisma.strategy_masterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.strategy_masterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>
          }
          update: {
            args: Prisma.strategy_masterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>
          }
          deleteMany: {
            args: Prisma.strategy_masterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.strategy_masterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.strategy_masterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$strategy_masterPayload>
          }
          aggregate: {
            args: Prisma.Strategy_masterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategy_master>
          }
          groupBy: {
            args: Prisma.strategy_masterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Strategy_masterGroupByOutputType>[]
          }
          count: {
            args: Prisma.strategy_masterCountArgs<ExtArgs>
            result: $Utils.Optional<Strategy_masterCountAggregateOutputType> | number
          }
        }
      }
      transaction_types: {
        payload: Prisma.$transaction_typesPayload<ExtArgs>
        fields: Prisma.transaction_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaction_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaction_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          findFirst: {
            args: Prisma.transaction_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaction_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          findMany: {
            args: Prisma.transaction_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>[]
          }
          create: {
            args: Prisma.transaction_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          createMany: {
            args: Prisma.transaction_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transaction_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          update: {
            args: Prisma.transaction_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          deleteMany: {
            args: Prisma.transaction_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaction_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transaction_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          aggregate: {
            args: Prisma.Transaction_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction_types>
          }
          groupBy: {
            args: Prisma.transaction_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaction_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaction_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Transaction_typesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account_types?: account_typesOmit
    accounts?: accountsOmit
    brokers?: brokersOmit
    chart_of_accounts?: chart_of_accountsOmit
    counterparty_limits?: counterparty_limitsOmit
    counterparty_master_individual?: counterparty_master_individualOmit
    counterparty_master_joint?: counterparty_master_jointOmit
    gsec?: gsecOmit
    isin_coupon_schedule?: isin_coupon_scheduleOmit
    isin_master?: isin_masterOmit
    ledger_entries?: ledger_entriesOmit
    money_market_deals?: money_market_dealsOmit
    portfolio_master?: portfolio_masterOmit
    securities?: securitiesOmit
    settlement_accounts?: settlement_accountsOmit
    strategy_master?: strategy_masterOmit
    transaction_types?: transaction_typesOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Account_typesCountOutputType
   */

  export type Account_typesCountOutputType = {
    chart_of_accounts: number
  }

  export type Account_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chart_of_accounts?: boolean | Account_typesCountOutputTypeCountChart_of_accountsArgs
  }

  // Custom InputTypes
  /**
   * Account_typesCountOutputType without action
   */
  export type Account_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account_typesCountOutputType
     */
    select?: Account_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Account_typesCountOutputType without action
   */
  export type Account_typesCountOutputTypeCountChart_of_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chart_of_accountsWhereInput
  }


  /**
   * Count Type Chart_of_accountsCountOutputType
   */

  export type Chart_of_accountsCountOutputType = {
    other_chart_of_accounts: number
    ledger_entries: number
  }

  export type Chart_of_accountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_chart_of_accounts?: boolean | Chart_of_accountsCountOutputTypeCountOther_chart_of_accountsArgs
    ledger_entries?: boolean | Chart_of_accountsCountOutputTypeCountLedger_entriesArgs
  }

  // Custom InputTypes
  /**
   * Chart_of_accountsCountOutputType without action
   */
  export type Chart_of_accountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart_of_accountsCountOutputType
     */
    select?: Chart_of_accountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Chart_of_accountsCountOutputType without action
   */
  export type Chart_of_accountsCountOutputTypeCountOther_chart_of_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chart_of_accountsWhereInput
  }

  /**
   * Chart_of_accountsCountOutputType without action
   */
  export type Chart_of_accountsCountOutputTypeCountLedger_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ledger_entriesWhereInput
  }


  /**
   * Count Type Isin_masterCountOutputType
   */

  export type Isin_masterCountOutputType = {
    isin_coupon_schedule: number
  }

  export type Isin_masterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    isin_coupon_schedule?: boolean | Isin_masterCountOutputTypeCountIsin_coupon_scheduleArgs
  }

  // Custom InputTypes
  /**
   * Isin_masterCountOutputType without action
   */
  export type Isin_masterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Isin_masterCountOutputType
     */
    select?: Isin_masterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Isin_masterCountOutputType without action
   */
  export type Isin_masterCountOutputTypeCountIsin_coupon_scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: isin_coupon_scheduleWhereInput
  }


  /**
   * Count Type Portfolio_masterCountOutputType
   */

  export type Portfolio_masterCountOutputType = {
    other_portfolio_master: number
  }

  export type Portfolio_masterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_portfolio_master?: boolean | Portfolio_masterCountOutputTypeCountOther_portfolio_masterArgs
  }

  // Custom InputTypes
  /**
   * Portfolio_masterCountOutputType without action
   */
  export type Portfolio_masterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio_masterCountOutputType
     */
    select?: Portfolio_masterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Portfolio_masterCountOutputType without action
   */
  export type Portfolio_masterCountOutputTypeCountOther_portfolio_masterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: portfolio_masterWhereInput
  }


  /**
   * Models
   */

  /**
   * Model account_types
   */

  export type AggregateAccount_types = {
    _count: Account_typesCountAggregateOutputType | null
    _avg: Account_typesAvgAggregateOutputType | null
    _sum: Account_typesSumAggregateOutputType | null
    _min: Account_typesMinAggregateOutputType | null
    _max: Account_typesMaxAggregateOutputType | null
  }

  export type Account_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Account_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Account_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: $Enums.account_types_category | null
    description: string | null
    created_at: Date | null
  }

  export type Account_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: $Enums.account_types_category | null
    description: string | null
    created_at: Date | null
  }

  export type Account_typesCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    created_at: number
    _all: number
  }


  export type Account_typesAvgAggregateInputType = {
    id?: true
  }

  export type Account_typesSumAggregateInputType = {
    id?: true
  }

  export type Account_typesMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    created_at?: true
  }

  export type Account_typesMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    created_at?: true
  }

  export type Account_typesCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type Account_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_types to aggregate.
     */
    where?: account_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_types to fetch.
     */
    orderBy?: account_typesOrderByWithRelationInput | account_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: account_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned account_types
    **/
    _count?: true | Account_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Account_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Account_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Account_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Account_typesMaxAggregateInputType
  }

  export type GetAccount_typesAggregateType<T extends Account_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount_types[P]>
      : GetScalarType<T[P], AggregateAccount_types[P]>
  }




  export type account_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: account_typesWhereInput
    orderBy?: account_typesOrderByWithAggregationInput | account_typesOrderByWithAggregationInput[]
    by: Account_typesScalarFieldEnum[] | Account_typesScalarFieldEnum
    having?: account_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Account_typesCountAggregateInputType | true
    _avg?: Account_typesAvgAggregateInputType
    _sum?: Account_typesSumAggregateInputType
    _min?: Account_typesMinAggregateInputType
    _max?: Account_typesMaxAggregateInputType
  }

  export type Account_typesGroupByOutputType = {
    id: number
    name: string
    category: $Enums.account_types_category
    description: string | null
    created_at: Date | null
    _count: Account_typesCountAggregateOutputType | null
    _avg: Account_typesAvgAggregateOutputType | null
    _sum: Account_typesSumAggregateOutputType | null
    _min: Account_typesMinAggregateOutputType | null
    _max: Account_typesMaxAggregateOutputType | null
  }

  type GetAccount_typesGroupByPayload<T extends account_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Account_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Account_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Account_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Account_typesGroupByOutputType[P]>
        }
      >
    >


  export type account_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    created_at?: boolean
    chart_of_accounts?: boolean | account_types$chart_of_accountsArgs<ExtArgs>
    _count?: boolean | Account_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account_types"]>



  export type account_typesSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type account_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "description" | "created_at", ExtArgs["result"]["account_types"]>
  export type account_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chart_of_accounts?: boolean | account_types$chart_of_accountsArgs<ExtArgs>
    _count?: boolean | Account_typesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $account_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "account_types"
    objects: {
      chart_of_accounts: Prisma.$chart_of_accountsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: $Enums.account_types_category
      description: string | null
      created_at: Date | null
    }, ExtArgs["result"]["account_types"]>
    composites: {}
  }

  type account_typesGetPayload<S extends boolean | null | undefined | account_typesDefaultArgs> = $Result.GetResult<Prisma.$account_typesPayload, S>

  type account_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<account_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Account_typesCountAggregateInputType | true
    }

  export interface account_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account_types'], meta: { name: 'account_types' } }
    /**
     * Find zero or one Account_types that matches the filter.
     * @param {account_typesFindUniqueArgs} args - Arguments to find a Account_types
     * @example
     * // Get one Account_types
     * const account_types = await prisma.account_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends account_typesFindUniqueArgs>(args: SelectSubset<T, account_typesFindUniqueArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {account_typesFindUniqueOrThrowArgs} args - Arguments to find a Account_types
     * @example
     * // Get one Account_types
     * const account_types = await prisma.account_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends account_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, account_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_typesFindFirstArgs} args - Arguments to find a Account_types
     * @example
     * // Get one Account_types
     * const account_types = await prisma.account_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends account_typesFindFirstArgs>(args?: SelectSubset<T, account_typesFindFirstArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_typesFindFirstOrThrowArgs} args - Arguments to find a Account_types
     * @example
     * // Get one Account_types
     * const account_types = await prisma.account_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends account_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, account_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Account_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Account_types
     * const account_types = await prisma.account_types.findMany()
     * 
     * // Get first 10 Account_types
     * const account_types = await prisma.account_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const account_typesWithIdOnly = await prisma.account_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends account_typesFindManyArgs>(args?: SelectSubset<T, account_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account_types.
     * @param {account_typesCreateArgs} args - Arguments to create a Account_types.
     * @example
     * // Create one Account_types
     * const Account_types = await prisma.account_types.create({
     *   data: {
     *     // ... data to create a Account_types
     *   }
     * })
     * 
     */
    create<T extends account_typesCreateArgs>(args: SelectSubset<T, account_typesCreateArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Account_types.
     * @param {account_typesCreateManyArgs} args - Arguments to create many Account_types.
     * @example
     * // Create many Account_types
     * const account_types = await prisma.account_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends account_typesCreateManyArgs>(args?: SelectSubset<T, account_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account_types.
     * @param {account_typesDeleteArgs} args - Arguments to delete one Account_types.
     * @example
     * // Delete one Account_types
     * const Account_types = await prisma.account_types.delete({
     *   where: {
     *     // ... filter to delete one Account_types
     *   }
     * })
     * 
     */
    delete<T extends account_typesDeleteArgs>(args: SelectSubset<T, account_typesDeleteArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account_types.
     * @param {account_typesUpdateArgs} args - Arguments to update one Account_types.
     * @example
     * // Update one Account_types
     * const account_types = await prisma.account_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends account_typesUpdateArgs>(args: SelectSubset<T, account_typesUpdateArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Account_types.
     * @param {account_typesDeleteManyArgs} args - Arguments to filter Account_types to delete.
     * @example
     * // Delete a few Account_types
     * const { count } = await prisma.account_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends account_typesDeleteManyArgs>(args?: SelectSubset<T, account_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Account_types
     * const account_types = await prisma.account_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends account_typesUpdateManyArgs>(args: SelectSubset<T, account_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account_types.
     * @param {account_typesUpsertArgs} args - Arguments to update or create a Account_types.
     * @example
     * // Update or create a Account_types
     * const account_types = await prisma.account_types.upsert({
     *   create: {
     *     // ... data to create a Account_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account_types we want to update
     *   }
     * })
     */
    upsert<T extends account_typesUpsertArgs>(args: SelectSubset<T, account_typesUpsertArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Account_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_typesCountArgs} args - Arguments to filter Account_types to count.
     * @example
     * // Count the number of Account_types
     * const count = await prisma.account_types.count({
     *   where: {
     *     // ... the filter for the Account_types we want to count
     *   }
     * })
    **/
    count<T extends account_typesCountArgs>(
      args?: Subset<T, account_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Account_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Account_typesAggregateArgs>(args: Subset<T, Account_typesAggregateArgs>): Prisma.PrismaPromise<GetAccount_typesAggregateType<T>>

    /**
     * Group by Account_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends account_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: account_typesGroupByArgs['orderBy'] }
        : { orderBy?: account_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, account_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccount_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the account_types model
   */
  readonly fields: account_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for account_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__account_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chart_of_accounts<T extends account_types$chart_of_accountsArgs<ExtArgs> = {}>(args?: Subset<T, account_types$chart_of_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the account_types model
   */
  interface account_typesFieldRefs {
    readonly id: FieldRef<"account_types", 'Int'>
    readonly name: FieldRef<"account_types", 'String'>
    readonly category: FieldRef<"account_types", 'account_types_category'>
    readonly description: FieldRef<"account_types", 'String'>
    readonly created_at: FieldRef<"account_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * account_types findUnique
   */
  export type account_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * Filter, which account_types to fetch.
     */
    where: account_typesWhereUniqueInput
  }

  /**
   * account_types findUniqueOrThrow
   */
  export type account_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * Filter, which account_types to fetch.
     */
    where: account_typesWhereUniqueInput
  }

  /**
   * account_types findFirst
   */
  export type account_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * Filter, which account_types to fetch.
     */
    where?: account_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_types to fetch.
     */
    orderBy?: account_typesOrderByWithRelationInput | account_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_types.
     */
    cursor?: account_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_types.
     */
    distinct?: Account_typesScalarFieldEnum | Account_typesScalarFieldEnum[]
  }

  /**
   * account_types findFirstOrThrow
   */
  export type account_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * Filter, which account_types to fetch.
     */
    where?: account_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_types to fetch.
     */
    orderBy?: account_typesOrderByWithRelationInput | account_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_types.
     */
    cursor?: account_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_types.
     */
    distinct?: Account_typesScalarFieldEnum | Account_typesScalarFieldEnum[]
  }

  /**
   * account_types findMany
   */
  export type account_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * Filter, which account_types to fetch.
     */
    where?: account_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_types to fetch.
     */
    orderBy?: account_typesOrderByWithRelationInput | account_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing account_types.
     */
    cursor?: account_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_types.
     */
    skip?: number
    distinct?: Account_typesScalarFieldEnum | Account_typesScalarFieldEnum[]
  }

  /**
   * account_types create
   */
  export type account_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a account_types.
     */
    data: XOR<account_typesCreateInput, account_typesUncheckedCreateInput>
  }

  /**
   * account_types createMany
   */
  export type account_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many account_types.
     */
    data: account_typesCreateManyInput | account_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * account_types update
   */
  export type account_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a account_types.
     */
    data: XOR<account_typesUpdateInput, account_typesUncheckedUpdateInput>
    /**
     * Choose, which account_types to update.
     */
    where: account_typesWhereUniqueInput
  }

  /**
   * account_types updateMany
   */
  export type account_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update account_types.
     */
    data: XOR<account_typesUpdateManyMutationInput, account_typesUncheckedUpdateManyInput>
    /**
     * Filter which account_types to update
     */
    where?: account_typesWhereInput
    /**
     * Limit how many account_types to update.
     */
    limit?: number
  }

  /**
   * account_types upsert
   */
  export type account_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the account_types to update in case it exists.
     */
    where: account_typesWhereUniqueInput
    /**
     * In case the account_types found by the `where` argument doesn't exist, create a new account_types with this data.
     */
    create: XOR<account_typesCreateInput, account_typesUncheckedCreateInput>
    /**
     * In case the account_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<account_typesUpdateInput, account_typesUncheckedUpdateInput>
  }

  /**
   * account_types delete
   */
  export type account_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
    /**
     * Filter which account_types to delete.
     */
    where: account_typesWhereUniqueInput
  }

  /**
   * account_types deleteMany
   */
  export type account_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_types to delete
     */
    where?: account_typesWhereInput
    /**
     * Limit how many account_types to delete.
     */
    limit?: number
  }

  /**
   * account_types.chart_of_accounts
   */
  export type account_types$chart_of_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    where?: chart_of_accountsWhereInput
    orderBy?: chart_of_accountsOrderByWithRelationInput | chart_of_accountsOrderByWithRelationInput[]
    cursor?: chart_of_accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chart_of_accountsScalarFieldEnum | Chart_of_accountsScalarFieldEnum[]
  }

  /**
   * account_types without action
   */
  export type account_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_types
     */
    select?: account_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the account_types
     */
    omit?: account_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: account_typesInclude<ExtArgs> | null
  }


  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    id: number | null
    balance: Decimal | null
  }

  export type AccountsSumAggregateOutputType = {
    id: number | null
    balance: Decimal | null
  }

  export type AccountsMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    name: number
    type: number
    balance: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    id?: true
    balance?: true
  }

  export type AccountsSumAggregateInputType = {
    id?: true
    balance?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    balance?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    balance?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    balance?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: number
    name: string
    type: string
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["accounts"]>



  export type accountsSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "balance" | "created_at" | "updated_at", ExtArgs["result"]["accounts"]>

  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      balance: Prisma.Decimal | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountsFindUniqueArgs>(args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountsFindFirstArgs>(args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountsFindManyArgs>(args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
     */
    create<T extends accountsCreateArgs>(args: SelectSubset<T, accountsCreateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountsCreateManyArgs>(args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
     */
    delete<T extends accountsDeleteArgs>(args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountsUpdateArgs>(args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountsDeleteManyArgs>(args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountsUpdateManyArgs>(args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
     */
    upsert<T extends accountsUpsertArgs>(args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accounts model
   */
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'Int'>
    readonly name: FieldRef<"accounts", 'String'>
    readonly type: FieldRef<"accounts", 'String'>
    readonly balance: FieldRef<"accounts", 'Decimal'>
    readonly created_at: FieldRef<"accounts", 'DateTime'>
    readonly updated_at: FieldRef<"accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
  }


  /**
   * Model brokers
   */

  export type AggregateBrokers = {
    _count: BrokersCountAggregateOutputType | null
    _avg: BrokersAvgAggregateOutputType | null
    _sum: BrokersSumAggregateOutputType | null
    _min: BrokersMinAggregateOutputType | null
    _max: BrokersMaxAggregateOutputType | null
  }

  export type BrokersAvgAggregateOutputType = {
    id: number | null
    brokerage_cal_method_id: number | null
    brokerage_input_percentage: Decimal | null
    brokerage_settlement_method_id: number | null
  }

  export type BrokersSumAggregateOutputType = {
    id: number | null
    brokerage_cal_method_id: number | null
    brokerage_input_percentage: Decimal | null
    brokerage_settlement_method_id: number | null
  }

  export type BrokersMinAggregateOutputType = {
    id: number | null
    broker_code: string | null
    broker_name: string | null
    building_number: string | null
    street_name: string | null
    street_name2: string | null
    city: string | null
    province: string | null
    zip_code: string | null
    country: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_mobile: string | null
    contact_fax: string | null
    contact_email: string | null
    broker_type: string | null
    brokerage_method: string | null
    brokerage_cal_method_id: number | null
    brokerage_input_percentage: Decimal | null
    brokerage_settlement_method_id: number | null
    settlement_account_number: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BrokersMaxAggregateOutputType = {
    id: number | null
    broker_code: string | null
    broker_name: string | null
    building_number: string | null
    street_name: string | null
    street_name2: string | null
    city: string | null
    province: string | null
    zip_code: string | null
    country: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_mobile: string | null
    contact_fax: string | null
    contact_email: string | null
    broker_type: string | null
    brokerage_method: string | null
    brokerage_cal_method_id: number | null
    brokerage_input_percentage: Decimal | null
    brokerage_settlement_method_id: number | null
    settlement_account_number: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BrokersCountAggregateOutputType = {
    id: number
    broker_code: number
    broker_name: number
    building_number: number
    street_name: number
    street_name2: number
    city: number
    province: number
    zip_code: number
    country: number
    contact_name: number
    contact_phone: number
    contact_mobile: number
    contact_fax: number
    contact_email: number
    broker_type: number
    brokerage_method: number
    brokerage_cal_method_id: number
    brokerage_input_percentage: number
    brokerage_settlement_method_id: number
    settlement_account_number: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BrokersAvgAggregateInputType = {
    id?: true
    brokerage_cal_method_id?: true
    brokerage_input_percentage?: true
    brokerage_settlement_method_id?: true
  }

  export type BrokersSumAggregateInputType = {
    id?: true
    brokerage_cal_method_id?: true
    brokerage_input_percentage?: true
    brokerage_settlement_method_id?: true
  }

  export type BrokersMinAggregateInputType = {
    id?: true
    broker_code?: true
    broker_name?: true
    building_number?: true
    street_name?: true
    street_name2?: true
    city?: true
    province?: true
    zip_code?: true
    country?: true
    contact_name?: true
    contact_phone?: true
    contact_mobile?: true
    contact_fax?: true
    contact_email?: true
    broker_type?: true
    brokerage_method?: true
    brokerage_cal_method_id?: true
    brokerage_input_percentage?: true
    brokerage_settlement_method_id?: true
    settlement_account_number?: true
    created_at?: true
    updated_at?: true
  }

  export type BrokersMaxAggregateInputType = {
    id?: true
    broker_code?: true
    broker_name?: true
    building_number?: true
    street_name?: true
    street_name2?: true
    city?: true
    province?: true
    zip_code?: true
    country?: true
    contact_name?: true
    contact_phone?: true
    contact_mobile?: true
    contact_fax?: true
    contact_email?: true
    broker_type?: true
    brokerage_method?: true
    brokerage_cal_method_id?: true
    brokerage_input_percentage?: true
    brokerage_settlement_method_id?: true
    settlement_account_number?: true
    created_at?: true
    updated_at?: true
  }

  export type BrokersCountAggregateInputType = {
    id?: true
    broker_code?: true
    broker_name?: true
    building_number?: true
    street_name?: true
    street_name2?: true
    city?: true
    province?: true
    zip_code?: true
    country?: true
    contact_name?: true
    contact_phone?: true
    contact_mobile?: true
    contact_fax?: true
    contact_email?: true
    broker_type?: true
    brokerage_method?: true
    brokerage_cal_method_id?: true
    brokerage_input_percentage?: true
    brokerage_settlement_method_id?: true
    settlement_account_number?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BrokersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brokers to aggregate.
     */
    where?: brokersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brokers to fetch.
     */
    orderBy?: brokersOrderByWithRelationInput | brokersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brokersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brokers
    **/
    _count?: true | BrokersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrokersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrokersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrokersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrokersMaxAggregateInputType
  }

  export type GetBrokersAggregateType<T extends BrokersAggregateArgs> = {
        [P in keyof T & keyof AggregateBrokers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrokers[P]>
      : GetScalarType<T[P], AggregateBrokers[P]>
  }




  export type brokersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brokersWhereInput
    orderBy?: brokersOrderByWithAggregationInput | brokersOrderByWithAggregationInput[]
    by: BrokersScalarFieldEnum[] | BrokersScalarFieldEnum
    having?: brokersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrokersCountAggregateInputType | true
    _avg?: BrokersAvgAggregateInputType
    _sum?: BrokersSumAggregateInputType
    _min?: BrokersMinAggregateInputType
    _max?: BrokersMaxAggregateInputType
  }

  export type BrokersGroupByOutputType = {
    id: number
    broker_code: string
    broker_name: string
    building_number: string | null
    street_name: string | null
    street_name2: string | null
    city: string | null
    province: string | null
    zip_code: string | null
    country: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_mobile: string | null
    contact_fax: string | null
    contact_email: string | null
    broker_type: string | null
    brokerage_method: string | null
    brokerage_cal_method_id: number | null
    brokerage_input_percentage: Decimal | null
    brokerage_settlement_method_id: number | null
    settlement_account_number: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: BrokersCountAggregateOutputType | null
    _avg: BrokersAvgAggregateOutputType | null
    _sum: BrokersSumAggregateOutputType | null
    _min: BrokersMinAggregateOutputType | null
    _max: BrokersMaxAggregateOutputType | null
  }

  type GetBrokersGroupByPayload<T extends brokersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrokersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrokersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrokersGroupByOutputType[P]>
            : GetScalarType<T[P], BrokersGroupByOutputType[P]>
        }
      >
    >


  export type brokersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broker_code?: boolean
    broker_name?: boolean
    building_number?: boolean
    street_name?: boolean
    street_name2?: boolean
    city?: boolean
    province?: boolean
    zip_code?: boolean
    country?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    contact_mobile?: boolean
    contact_fax?: boolean
    contact_email?: boolean
    broker_type?: boolean
    brokerage_method?: boolean
    brokerage_cal_method_id?: boolean
    brokerage_input_percentage?: boolean
    brokerage_settlement_method_id?: boolean
    settlement_account_number?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["brokers"]>



  export type brokersSelectScalar = {
    id?: boolean
    broker_code?: boolean
    broker_name?: boolean
    building_number?: boolean
    street_name?: boolean
    street_name2?: boolean
    city?: boolean
    province?: boolean
    zip_code?: boolean
    country?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    contact_mobile?: boolean
    contact_fax?: boolean
    contact_email?: boolean
    broker_type?: boolean
    brokerage_method?: boolean
    brokerage_cal_method_id?: boolean
    brokerage_input_percentage?: boolean
    brokerage_settlement_method_id?: boolean
    settlement_account_number?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type brokersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "broker_code" | "broker_name" | "building_number" | "street_name" | "street_name2" | "city" | "province" | "zip_code" | "country" | "contact_name" | "contact_phone" | "contact_mobile" | "contact_fax" | "contact_email" | "broker_type" | "brokerage_method" | "brokerage_cal_method_id" | "brokerage_input_percentage" | "brokerage_settlement_method_id" | "settlement_account_number" | "created_at" | "updated_at", ExtArgs["result"]["brokers"]>

  export type $brokersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brokers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      broker_code: string
      broker_name: string
      building_number: string | null
      street_name: string | null
      street_name2: string | null
      city: string | null
      province: string | null
      zip_code: string | null
      country: string | null
      contact_name: string | null
      contact_phone: string | null
      contact_mobile: string | null
      contact_fax: string | null
      contact_email: string | null
      broker_type: string | null
      brokerage_method: string | null
      brokerage_cal_method_id: number | null
      brokerage_input_percentage: Prisma.Decimal | null
      brokerage_settlement_method_id: number | null
      settlement_account_number: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["brokers"]>
    composites: {}
  }

  type brokersGetPayload<S extends boolean | null | undefined | brokersDefaultArgs> = $Result.GetResult<Prisma.$brokersPayload, S>

  type brokersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<brokersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrokersCountAggregateInputType | true
    }

  export interface brokersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brokers'], meta: { name: 'brokers' } }
    /**
     * Find zero or one Brokers that matches the filter.
     * @param {brokersFindUniqueArgs} args - Arguments to find a Brokers
     * @example
     * // Get one Brokers
     * const brokers = await prisma.brokers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brokersFindUniqueArgs>(args: SelectSubset<T, brokersFindUniqueArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brokers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {brokersFindUniqueOrThrowArgs} args - Arguments to find a Brokers
     * @example
     * // Get one Brokers
     * const brokers = await prisma.brokers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brokersFindUniqueOrThrowArgs>(args: SelectSubset<T, brokersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brokers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brokersFindFirstArgs} args - Arguments to find a Brokers
     * @example
     * // Get one Brokers
     * const brokers = await prisma.brokers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brokersFindFirstArgs>(args?: SelectSubset<T, brokersFindFirstArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brokers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brokersFindFirstOrThrowArgs} args - Arguments to find a Brokers
     * @example
     * // Get one Brokers
     * const brokers = await prisma.brokers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brokersFindFirstOrThrowArgs>(args?: SelectSubset<T, brokersFindFirstOrThrowArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brokers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brokersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brokers
     * const brokers = await prisma.brokers.findMany()
     * 
     * // Get first 10 Brokers
     * const brokers = await prisma.brokers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brokersWithIdOnly = await prisma.brokers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brokersFindManyArgs>(args?: SelectSubset<T, brokersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brokers.
     * @param {brokersCreateArgs} args - Arguments to create a Brokers.
     * @example
     * // Create one Brokers
     * const Brokers = await prisma.brokers.create({
     *   data: {
     *     // ... data to create a Brokers
     *   }
     * })
     * 
     */
    create<T extends brokersCreateArgs>(args: SelectSubset<T, brokersCreateArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brokers.
     * @param {brokersCreateManyArgs} args - Arguments to create many Brokers.
     * @example
     * // Create many Brokers
     * const brokers = await prisma.brokers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brokersCreateManyArgs>(args?: SelectSubset<T, brokersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brokers.
     * @param {brokersDeleteArgs} args - Arguments to delete one Brokers.
     * @example
     * // Delete one Brokers
     * const Brokers = await prisma.brokers.delete({
     *   where: {
     *     // ... filter to delete one Brokers
     *   }
     * })
     * 
     */
    delete<T extends brokersDeleteArgs>(args: SelectSubset<T, brokersDeleteArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brokers.
     * @param {brokersUpdateArgs} args - Arguments to update one Brokers.
     * @example
     * // Update one Brokers
     * const brokers = await prisma.brokers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brokersUpdateArgs>(args: SelectSubset<T, brokersUpdateArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brokers.
     * @param {brokersDeleteManyArgs} args - Arguments to filter Brokers to delete.
     * @example
     * // Delete a few Brokers
     * const { count } = await prisma.brokers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brokersDeleteManyArgs>(args?: SelectSubset<T, brokersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brokersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brokers
     * const brokers = await prisma.brokers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brokersUpdateManyArgs>(args: SelectSubset<T, brokersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brokers.
     * @param {brokersUpsertArgs} args - Arguments to update or create a Brokers.
     * @example
     * // Update or create a Brokers
     * const brokers = await prisma.brokers.upsert({
     *   create: {
     *     // ... data to create a Brokers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brokers we want to update
     *   }
     * })
     */
    upsert<T extends brokersUpsertArgs>(args: SelectSubset<T, brokersUpsertArgs<ExtArgs>>): Prisma__brokersClient<$Result.GetResult<Prisma.$brokersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brokersCountArgs} args - Arguments to filter Brokers to count.
     * @example
     * // Count the number of Brokers
     * const count = await prisma.brokers.count({
     *   where: {
     *     // ... the filter for the Brokers we want to count
     *   }
     * })
    **/
    count<T extends brokersCountArgs>(
      args?: Subset<T, brokersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrokersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrokersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrokersAggregateArgs>(args: Subset<T, BrokersAggregateArgs>): Prisma.PrismaPromise<GetBrokersAggregateType<T>>

    /**
     * Group by Brokers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brokersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brokersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brokersGroupByArgs['orderBy'] }
        : { orderBy?: brokersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brokersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrokersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brokers model
   */
  readonly fields: brokersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brokers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brokersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brokers model
   */
  interface brokersFieldRefs {
    readonly id: FieldRef<"brokers", 'Int'>
    readonly broker_code: FieldRef<"brokers", 'String'>
    readonly broker_name: FieldRef<"brokers", 'String'>
    readonly building_number: FieldRef<"brokers", 'String'>
    readonly street_name: FieldRef<"brokers", 'String'>
    readonly street_name2: FieldRef<"brokers", 'String'>
    readonly city: FieldRef<"brokers", 'String'>
    readonly province: FieldRef<"brokers", 'String'>
    readonly zip_code: FieldRef<"brokers", 'String'>
    readonly country: FieldRef<"brokers", 'String'>
    readonly contact_name: FieldRef<"brokers", 'String'>
    readonly contact_phone: FieldRef<"brokers", 'String'>
    readonly contact_mobile: FieldRef<"brokers", 'String'>
    readonly contact_fax: FieldRef<"brokers", 'String'>
    readonly contact_email: FieldRef<"brokers", 'String'>
    readonly broker_type: FieldRef<"brokers", 'String'>
    readonly brokerage_method: FieldRef<"brokers", 'String'>
    readonly brokerage_cal_method_id: FieldRef<"brokers", 'Int'>
    readonly brokerage_input_percentage: FieldRef<"brokers", 'Decimal'>
    readonly brokerage_settlement_method_id: FieldRef<"brokers", 'Int'>
    readonly settlement_account_number: FieldRef<"brokers", 'String'>
    readonly created_at: FieldRef<"brokers", 'DateTime'>
    readonly updated_at: FieldRef<"brokers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brokers findUnique
   */
  export type brokersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * Filter, which brokers to fetch.
     */
    where: brokersWhereUniqueInput
  }

  /**
   * brokers findUniqueOrThrow
   */
  export type brokersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * Filter, which brokers to fetch.
     */
    where: brokersWhereUniqueInput
  }

  /**
   * brokers findFirst
   */
  export type brokersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * Filter, which brokers to fetch.
     */
    where?: brokersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brokers to fetch.
     */
    orderBy?: brokersOrderByWithRelationInput | brokersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brokers.
     */
    cursor?: brokersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brokers.
     */
    distinct?: BrokersScalarFieldEnum | BrokersScalarFieldEnum[]
  }

  /**
   * brokers findFirstOrThrow
   */
  export type brokersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * Filter, which brokers to fetch.
     */
    where?: brokersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brokers to fetch.
     */
    orderBy?: brokersOrderByWithRelationInput | brokersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brokers.
     */
    cursor?: brokersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brokers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brokers.
     */
    distinct?: BrokersScalarFieldEnum | BrokersScalarFieldEnum[]
  }

  /**
   * brokers findMany
   */
  export type brokersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * Filter, which brokers to fetch.
     */
    where?: brokersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brokers to fetch.
     */
    orderBy?: brokersOrderByWithRelationInput | brokersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brokers.
     */
    cursor?: brokersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brokers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brokers.
     */
    skip?: number
    distinct?: BrokersScalarFieldEnum | BrokersScalarFieldEnum[]
  }

  /**
   * brokers create
   */
  export type brokersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * The data needed to create a brokers.
     */
    data: XOR<brokersCreateInput, brokersUncheckedCreateInput>
  }

  /**
   * brokers createMany
   */
  export type brokersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brokers.
     */
    data: brokersCreateManyInput | brokersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brokers update
   */
  export type brokersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * The data needed to update a brokers.
     */
    data: XOR<brokersUpdateInput, brokersUncheckedUpdateInput>
    /**
     * Choose, which brokers to update.
     */
    where: brokersWhereUniqueInput
  }

  /**
   * brokers updateMany
   */
  export type brokersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brokers.
     */
    data: XOR<brokersUpdateManyMutationInput, brokersUncheckedUpdateManyInput>
    /**
     * Filter which brokers to update
     */
    where?: brokersWhereInput
    /**
     * Limit how many brokers to update.
     */
    limit?: number
  }

  /**
   * brokers upsert
   */
  export type brokersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * The filter to search for the brokers to update in case it exists.
     */
    where: brokersWhereUniqueInput
    /**
     * In case the brokers found by the `where` argument doesn't exist, create a new brokers with this data.
     */
    create: XOR<brokersCreateInput, brokersUncheckedCreateInput>
    /**
     * In case the brokers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brokersUpdateInput, brokersUncheckedUpdateInput>
  }

  /**
   * brokers delete
   */
  export type brokersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
    /**
     * Filter which brokers to delete.
     */
    where: brokersWhereUniqueInput
  }

  /**
   * brokers deleteMany
   */
  export type brokersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brokers to delete
     */
    where?: brokersWhereInput
    /**
     * Limit how many brokers to delete.
     */
    limit?: number
  }

  /**
   * brokers without action
   */
  export type brokersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brokers
     */
    select?: brokersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brokers
     */
    omit?: brokersOmit<ExtArgs> | null
  }


  /**
   * Model chart_of_accounts
   */

  export type AggregateChart_of_accounts = {
    _count: Chart_of_accountsCountAggregateOutputType | null
    _avg: Chart_of_accountsAvgAggregateOutputType | null
    _sum: Chart_of_accountsSumAggregateOutputType | null
    _min: Chart_of_accountsMinAggregateOutputType | null
    _max: Chart_of_accountsMaxAggregateOutputType | null
  }

  export type Chart_of_accountsAvgAggregateOutputType = {
    id: number | null
    account_type_id: number | null
    parent_account_id: number | null
  }

  export type Chart_of_accountsSumAggregateOutputType = {
    id: number | null
    account_type_id: number | null
    parent_account_id: number | null
  }

  export type Chart_of_accountsMinAggregateOutputType = {
    id: number | null
    account_code: string | null
    name: string | null
    account_type_id: number | null
    parent_account_id: number | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Chart_of_accountsMaxAggregateOutputType = {
    id: number | null
    account_code: string | null
    name: string | null
    account_type_id: number | null
    parent_account_id: number | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Chart_of_accountsCountAggregateOutputType = {
    id: number
    account_code: number
    name: number
    account_type_id: number
    parent_account_id: number
    description: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Chart_of_accountsAvgAggregateInputType = {
    id?: true
    account_type_id?: true
    parent_account_id?: true
  }

  export type Chart_of_accountsSumAggregateInputType = {
    id?: true
    account_type_id?: true
    parent_account_id?: true
  }

  export type Chart_of_accountsMinAggregateInputType = {
    id?: true
    account_code?: true
    name?: true
    account_type_id?: true
    parent_account_id?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Chart_of_accountsMaxAggregateInputType = {
    id?: true
    account_code?: true
    name?: true
    account_type_id?: true
    parent_account_id?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Chart_of_accountsCountAggregateInputType = {
    id?: true
    account_code?: true
    name?: true
    account_type_id?: true
    parent_account_id?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Chart_of_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chart_of_accounts to aggregate.
     */
    where?: chart_of_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chart_of_accounts to fetch.
     */
    orderBy?: chart_of_accountsOrderByWithRelationInput | chart_of_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chart_of_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chart_of_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chart_of_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chart_of_accounts
    **/
    _count?: true | Chart_of_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chart_of_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chart_of_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chart_of_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chart_of_accountsMaxAggregateInputType
  }

  export type GetChart_of_accountsAggregateType<T extends Chart_of_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateChart_of_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChart_of_accounts[P]>
      : GetScalarType<T[P], AggregateChart_of_accounts[P]>
  }




  export type chart_of_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chart_of_accountsWhereInput
    orderBy?: chart_of_accountsOrderByWithAggregationInput | chart_of_accountsOrderByWithAggregationInput[]
    by: Chart_of_accountsScalarFieldEnum[] | Chart_of_accountsScalarFieldEnum
    having?: chart_of_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chart_of_accountsCountAggregateInputType | true
    _avg?: Chart_of_accountsAvgAggregateInputType
    _sum?: Chart_of_accountsSumAggregateInputType
    _min?: Chart_of_accountsMinAggregateInputType
    _max?: Chart_of_accountsMaxAggregateInputType
  }

  export type Chart_of_accountsGroupByOutputType = {
    id: number
    account_code: string
    name: string
    account_type_id: number
    parent_account_id: number | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: Chart_of_accountsCountAggregateOutputType | null
    _avg: Chart_of_accountsAvgAggregateOutputType | null
    _sum: Chart_of_accountsSumAggregateOutputType | null
    _min: Chart_of_accountsMinAggregateOutputType | null
    _max: Chart_of_accountsMaxAggregateOutputType | null
  }

  type GetChart_of_accountsGroupByPayload<T extends chart_of_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chart_of_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chart_of_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chart_of_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Chart_of_accountsGroupByOutputType[P]>
        }
      >
    >


  export type chart_of_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_code?: boolean
    name?: boolean
    account_type_id?: boolean
    parent_account_id?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_types?: boolean | account_typesDefaultArgs<ExtArgs>
    chart_of_accounts?: boolean | chart_of_accounts$chart_of_accountsArgs<ExtArgs>
    other_chart_of_accounts?: boolean | chart_of_accounts$other_chart_of_accountsArgs<ExtArgs>
    ledger_entries?: boolean | chart_of_accounts$ledger_entriesArgs<ExtArgs>
    _count?: boolean | Chart_of_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chart_of_accounts"]>



  export type chart_of_accountsSelectScalar = {
    id?: boolean
    account_code?: boolean
    name?: boolean
    account_type_id?: boolean
    parent_account_id?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chart_of_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_code" | "name" | "account_type_id" | "parent_account_id" | "description" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["chart_of_accounts"]>
  export type chart_of_accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_types?: boolean | account_typesDefaultArgs<ExtArgs>
    chart_of_accounts?: boolean | chart_of_accounts$chart_of_accountsArgs<ExtArgs>
    other_chart_of_accounts?: boolean | chart_of_accounts$other_chart_of_accountsArgs<ExtArgs>
    ledger_entries?: boolean | chart_of_accounts$ledger_entriesArgs<ExtArgs>
    _count?: boolean | Chart_of_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $chart_of_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chart_of_accounts"
    objects: {
      account_types: Prisma.$account_typesPayload<ExtArgs>
      chart_of_accounts: Prisma.$chart_of_accountsPayload<ExtArgs> | null
      other_chart_of_accounts: Prisma.$chart_of_accountsPayload<ExtArgs>[]
      ledger_entries: Prisma.$ledger_entriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      account_code: string
      name: string
      account_type_id: number
      parent_account_id: number | null
      description: string | null
      is_active: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["chart_of_accounts"]>
    composites: {}
  }

  type chart_of_accountsGetPayload<S extends boolean | null | undefined | chart_of_accountsDefaultArgs> = $Result.GetResult<Prisma.$chart_of_accountsPayload, S>

  type chart_of_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chart_of_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chart_of_accountsCountAggregateInputType | true
    }

  export interface chart_of_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chart_of_accounts'], meta: { name: 'chart_of_accounts' } }
    /**
     * Find zero or one Chart_of_accounts that matches the filter.
     * @param {chart_of_accountsFindUniqueArgs} args - Arguments to find a Chart_of_accounts
     * @example
     * // Get one Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chart_of_accountsFindUniqueArgs>(args: SelectSubset<T, chart_of_accountsFindUniqueArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chart_of_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chart_of_accountsFindUniqueOrThrowArgs} args - Arguments to find a Chart_of_accounts
     * @example
     * // Get one Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chart_of_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, chart_of_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chart_of_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chart_of_accountsFindFirstArgs} args - Arguments to find a Chart_of_accounts
     * @example
     * // Get one Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chart_of_accountsFindFirstArgs>(args?: SelectSubset<T, chart_of_accountsFindFirstArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chart_of_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chart_of_accountsFindFirstOrThrowArgs} args - Arguments to find a Chart_of_accounts
     * @example
     * // Get one Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chart_of_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, chart_of_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chart_of_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chart_of_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.findMany()
     * 
     * // Get first 10 Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chart_of_accountsWithIdOnly = await prisma.chart_of_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chart_of_accountsFindManyArgs>(args?: SelectSubset<T, chart_of_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chart_of_accounts.
     * @param {chart_of_accountsCreateArgs} args - Arguments to create a Chart_of_accounts.
     * @example
     * // Create one Chart_of_accounts
     * const Chart_of_accounts = await prisma.chart_of_accounts.create({
     *   data: {
     *     // ... data to create a Chart_of_accounts
     *   }
     * })
     * 
     */
    create<T extends chart_of_accountsCreateArgs>(args: SelectSubset<T, chart_of_accountsCreateArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chart_of_accounts.
     * @param {chart_of_accountsCreateManyArgs} args - Arguments to create many Chart_of_accounts.
     * @example
     * // Create many Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chart_of_accountsCreateManyArgs>(args?: SelectSubset<T, chart_of_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chart_of_accounts.
     * @param {chart_of_accountsDeleteArgs} args - Arguments to delete one Chart_of_accounts.
     * @example
     * // Delete one Chart_of_accounts
     * const Chart_of_accounts = await prisma.chart_of_accounts.delete({
     *   where: {
     *     // ... filter to delete one Chart_of_accounts
     *   }
     * })
     * 
     */
    delete<T extends chart_of_accountsDeleteArgs>(args: SelectSubset<T, chart_of_accountsDeleteArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chart_of_accounts.
     * @param {chart_of_accountsUpdateArgs} args - Arguments to update one Chart_of_accounts.
     * @example
     * // Update one Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chart_of_accountsUpdateArgs>(args: SelectSubset<T, chart_of_accountsUpdateArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chart_of_accounts.
     * @param {chart_of_accountsDeleteManyArgs} args - Arguments to filter Chart_of_accounts to delete.
     * @example
     * // Delete a few Chart_of_accounts
     * const { count } = await prisma.chart_of_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chart_of_accountsDeleteManyArgs>(args?: SelectSubset<T, chart_of_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chart_of_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chart_of_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chart_of_accountsUpdateManyArgs>(args: SelectSubset<T, chart_of_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chart_of_accounts.
     * @param {chart_of_accountsUpsertArgs} args - Arguments to update or create a Chart_of_accounts.
     * @example
     * // Update or create a Chart_of_accounts
     * const chart_of_accounts = await prisma.chart_of_accounts.upsert({
     *   create: {
     *     // ... data to create a Chart_of_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chart_of_accounts we want to update
     *   }
     * })
     */
    upsert<T extends chart_of_accountsUpsertArgs>(args: SelectSubset<T, chart_of_accountsUpsertArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chart_of_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chart_of_accountsCountArgs} args - Arguments to filter Chart_of_accounts to count.
     * @example
     * // Count the number of Chart_of_accounts
     * const count = await prisma.chart_of_accounts.count({
     *   where: {
     *     // ... the filter for the Chart_of_accounts we want to count
     *   }
     * })
    **/
    count<T extends chart_of_accountsCountArgs>(
      args?: Subset<T, chart_of_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chart_of_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chart_of_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chart_of_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chart_of_accountsAggregateArgs>(args: Subset<T, Chart_of_accountsAggregateArgs>): Prisma.PrismaPromise<GetChart_of_accountsAggregateType<T>>

    /**
     * Group by Chart_of_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chart_of_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chart_of_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chart_of_accountsGroupByArgs['orderBy'] }
        : { orderBy?: chart_of_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chart_of_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChart_of_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chart_of_accounts model
   */
  readonly fields: chart_of_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chart_of_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chart_of_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account_types<T extends account_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, account_typesDefaultArgs<ExtArgs>>): Prisma__account_typesClient<$Result.GetResult<Prisma.$account_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chart_of_accounts<T extends chart_of_accounts$chart_of_accountsArgs<ExtArgs> = {}>(args?: Subset<T, chart_of_accounts$chart_of_accountsArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_chart_of_accounts<T extends chart_of_accounts$other_chart_of_accountsArgs<ExtArgs> = {}>(args?: Subset<T, chart_of_accounts$other_chart_of_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledger_entries<T extends chart_of_accounts$ledger_entriesArgs<ExtArgs> = {}>(args?: Subset<T, chart_of_accounts$ledger_entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chart_of_accounts model
   */
  interface chart_of_accountsFieldRefs {
    readonly id: FieldRef<"chart_of_accounts", 'Int'>
    readonly account_code: FieldRef<"chart_of_accounts", 'String'>
    readonly name: FieldRef<"chart_of_accounts", 'String'>
    readonly account_type_id: FieldRef<"chart_of_accounts", 'Int'>
    readonly parent_account_id: FieldRef<"chart_of_accounts", 'Int'>
    readonly description: FieldRef<"chart_of_accounts", 'String'>
    readonly is_active: FieldRef<"chart_of_accounts", 'Boolean'>
    readonly created_at: FieldRef<"chart_of_accounts", 'DateTime'>
    readonly updated_at: FieldRef<"chart_of_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chart_of_accounts findUnique
   */
  export type chart_of_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * Filter, which chart_of_accounts to fetch.
     */
    where: chart_of_accountsWhereUniqueInput
  }

  /**
   * chart_of_accounts findUniqueOrThrow
   */
  export type chart_of_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * Filter, which chart_of_accounts to fetch.
     */
    where: chart_of_accountsWhereUniqueInput
  }

  /**
   * chart_of_accounts findFirst
   */
  export type chart_of_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * Filter, which chart_of_accounts to fetch.
     */
    where?: chart_of_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chart_of_accounts to fetch.
     */
    orderBy?: chart_of_accountsOrderByWithRelationInput | chart_of_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chart_of_accounts.
     */
    cursor?: chart_of_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chart_of_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chart_of_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chart_of_accounts.
     */
    distinct?: Chart_of_accountsScalarFieldEnum | Chart_of_accountsScalarFieldEnum[]
  }

  /**
   * chart_of_accounts findFirstOrThrow
   */
  export type chart_of_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * Filter, which chart_of_accounts to fetch.
     */
    where?: chart_of_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chart_of_accounts to fetch.
     */
    orderBy?: chart_of_accountsOrderByWithRelationInput | chart_of_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chart_of_accounts.
     */
    cursor?: chart_of_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chart_of_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chart_of_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chart_of_accounts.
     */
    distinct?: Chart_of_accountsScalarFieldEnum | Chart_of_accountsScalarFieldEnum[]
  }

  /**
   * chart_of_accounts findMany
   */
  export type chart_of_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * Filter, which chart_of_accounts to fetch.
     */
    where?: chart_of_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chart_of_accounts to fetch.
     */
    orderBy?: chart_of_accountsOrderByWithRelationInput | chart_of_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chart_of_accounts.
     */
    cursor?: chart_of_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chart_of_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chart_of_accounts.
     */
    skip?: number
    distinct?: Chart_of_accountsScalarFieldEnum | Chart_of_accountsScalarFieldEnum[]
  }

  /**
   * chart_of_accounts create
   */
  export type chart_of_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a chart_of_accounts.
     */
    data: XOR<chart_of_accountsCreateInput, chart_of_accountsUncheckedCreateInput>
  }

  /**
   * chart_of_accounts createMany
   */
  export type chart_of_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chart_of_accounts.
     */
    data: chart_of_accountsCreateManyInput | chart_of_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chart_of_accounts update
   */
  export type chart_of_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a chart_of_accounts.
     */
    data: XOR<chart_of_accountsUpdateInput, chart_of_accountsUncheckedUpdateInput>
    /**
     * Choose, which chart_of_accounts to update.
     */
    where: chart_of_accountsWhereUniqueInput
  }

  /**
   * chart_of_accounts updateMany
   */
  export type chart_of_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chart_of_accounts.
     */
    data: XOR<chart_of_accountsUpdateManyMutationInput, chart_of_accountsUncheckedUpdateManyInput>
    /**
     * Filter which chart_of_accounts to update
     */
    where?: chart_of_accountsWhereInput
    /**
     * Limit how many chart_of_accounts to update.
     */
    limit?: number
  }

  /**
   * chart_of_accounts upsert
   */
  export type chart_of_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the chart_of_accounts to update in case it exists.
     */
    where: chart_of_accountsWhereUniqueInput
    /**
     * In case the chart_of_accounts found by the `where` argument doesn't exist, create a new chart_of_accounts with this data.
     */
    create: XOR<chart_of_accountsCreateInput, chart_of_accountsUncheckedCreateInput>
    /**
     * In case the chart_of_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chart_of_accountsUpdateInput, chart_of_accountsUncheckedUpdateInput>
  }

  /**
   * chart_of_accounts delete
   */
  export type chart_of_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    /**
     * Filter which chart_of_accounts to delete.
     */
    where: chart_of_accountsWhereUniqueInput
  }

  /**
   * chart_of_accounts deleteMany
   */
  export type chart_of_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chart_of_accounts to delete
     */
    where?: chart_of_accountsWhereInput
    /**
     * Limit how many chart_of_accounts to delete.
     */
    limit?: number
  }

  /**
   * chart_of_accounts.chart_of_accounts
   */
  export type chart_of_accounts$chart_of_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    where?: chart_of_accountsWhereInput
  }

  /**
   * chart_of_accounts.other_chart_of_accounts
   */
  export type chart_of_accounts$other_chart_of_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
    where?: chart_of_accountsWhereInput
    orderBy?: chart_of_accountsOrderByWithRelationInput | chart_of_accountsOrderByWithRelationInput[]
    cursor?: chart_of_accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chart_of_accountsScalarFieldEnum | Chart_of_accountsScalarFieldEnum[]
  }

  /**
   * chart_of_accounts.ledger_entries
   */
  export type chart_of_accounts$ledger_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    where?: ledger_entriesWhereInput
    orderBy?: ledger_entriesOrderByWithRelationInput | ledger_entriesOrderByWithRelationInput[]
    cursor?: ledger_entriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ledger_entriesScalarFieldEnum | Ledger_entriesScalarFieldEnum[]
  }

  /**
   * chart_of_accounts without action
   */
  export type chart_of_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chart_of_accounts
     */
    select?: chart_of_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chart_of_accounts
     */
    omit?: chart_of_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chart_of_accountsInclude<ExtArgs> | null
  }


  /**
   * Model counterparty_limits
   */

  export type AggregateCounterparty_limits = {
    _count: Counterparty_limitsCountAggregateOutputType | null
    _avg: Counterparty_limitsAvgAggregateOutputType | null
    _sum: Counterparty_limitsSumAggregateOutputType | null
    _min: Counterparty_limitsMinAggregateOutputType | null
    _max: Counterparty_limitsMaxAggregateOutputType | null
  }

  export type Counterparty_limitsAvgAggregateOutputType = {
    id: number | null
    counterparty_id: number | null
    overall_exposure_limit: Decimal | null
    product_money_market_limit: Decimal | null
    product_fx_limit: Decimal | null
    product_derivative_limit: Decimal | null
    product_repo_limit: Decimal | null
    product_reverse_repo_limit: Decimal | null
    product_gsec_limit: Decimal | null
    product_sell_and_buy_back_limit: Decimal | null
    product_buy_and_sell_back_limit: Decimal | null
    tenor_limit: Decimal | null
    settlement_risk_limit: Decimal | null
    country_limit: Decimal | null
    group_limit: Decimal | null
    intraday_limit: Decimal | null
    product_transaction_limit: Decimal | null
  }

  export type Counterparty_limitsSumAggregateOutputType = {
    id: number | null
    counterparty_id: number | null
    overall_exposure_limit: Decimal | null
    product_money_market_limit: Decimal | null
    product_fx_limit: Decimal | null
    product_derivative_limit: Decimal | null
    product_repo_limit: Decimal | null
    product_reverse_repo_limit: Decimal | null
    product_gsec_limit: Decimal | null
    product_sell_and_buy_back_limit: Decimal | null
    product_buy_and_sell_back_limit: Decimal | null
    tenor_limit: Decimal | null
    settlement_risk_limit: Decimal | null
    country_limit: Decimal | null
    group_limit: Decimal | null
    intraday_limit: Decimal | null
    product_transaction_limit: Decimal | null
  }

  export type Counterparty_limitsMinAggregateOutputType = {
    id: number | null
    counterparty_id: number | null
    counterparty_type: $Enums.counterparty_limits_counterparty_type | null
    overall_exposure_limit: Decimal | null
    currency_limit: string | null
    product_money_market_limit: Decimal | null
    product_fx_limit: Decimal | null
    product_derivative_limit: Decimal | null
    product_repo_limit: Decimal | null
    product_reverse_repo_limit: Decimal | null
    product_gsec_limit: Decimal | null
    product_sell_and_buy_back_limit: Decimal | null
    product_buy_and_sell_back_limit: Decimal | null
    tenor_limit: Decimal | null
    settlement_risk_limit: Decimal | null
    country_limit: Decimal | null
    group_limit: Decimal | null
    intraday_limit: Decimal | null
    created_at: Date | null
    product_transaction_limit: Decimal | null
    currency: string | null
  }

  export type Counterparty_limitsMaxAggregateOutputType = {
    id: number | null
    counterparty_id: number | null
    counterparty_type: $Enums.counterparty_limits_counterparty_type | null
    overall_exposure_limit: Decimal | null
    currency_limit: string | null
    product_money_market_limit: Decimal | null
    product_fx_limit: Decimal | null
    product_derivative_limit: Decimal | null
    product_repo_limit: Decimal | null
    product_reverse_repo_limit: Decimal | null
    product_gsec_limit: Decimal | null
    product_sell_and_buy_back_limit: Decimal | null
    product_buy_and_sell_back_limit: Decimal | null
    tenor_limit: Decimal | null
    settlement_risk_limit: Decimal | null
    country_limit: Decimal | null
    group_limit: Decimal | null
    intraday_limit: Decimal | null
    created_at: Date | null
    product_transaction_limit: Decimal | null
    currency: string | null
  }

  export type Counterparty_limitsCountAggregateOutputType = {
    id: number
    counterparty_id: number
    counterparty_type: number
    overall_exposure_limit: number
    currency_limit: number
    product_money_market_limit: number
    product_fx_limit: number
    product_derivative_limit: number
    product_repo_limit: number
    product_reverse_repo_limit: number
    product_gsec_limit: number
    product_sell_and_buy_back_limit: number
    product_buy_and_sell_back_limit: number
    tenor_limit: number
    settlement_risk_limit: number
    country_limit: number
    group_limit: number
    intraday_limit: number
    created_at: number
    product_transaction_limit: number
    currency: number
    _all: number
  }


  export type Counterparty_limitsAvgAggregateInputType = {
    id?: true
    counterparty_id?: true
    overall_exposure_limit?: true
    product_money_market_limit?: true
    product_fx_limit?: true
    product_derivative_limit?: true
    product_repo_limit?: true
    product_reverse_repo_limit?: true
    product_gsec_limit?: true
    product_sell_and_buy_back_limit?: true
    product_buy_and_sell_back_limit?: true
    tenor_limit?: true
    settlement_risk_limit?: true
    country_limit?: true
    group_limit?: true
    intraday_limit?: true
    product_transaction_limit?: true
  }

  export type Counterparty_limitsSumAggregateInputType = {
    id?: true
    counterparty_id?: true
    overall_exposure_limit?: true
    product_money_market_limit?: true
    product_fx_limit?: true
    product_derivative_limit?: true
    product_repo_limit?: true
    product_reverse_repo_limit?: true
    product_gsec_limit?: true
    product_sell_and_buy_back_limit?: true
    product_buy_and_sell_back_limit?: true
    tenor_limit?: true
    settlement_risk_limit?: true
    country_limit?: true
    group_limit?: true
    intraday_limit?: true
    product_transaction_limit?: true
  }

  export type Counterparty_limitsMinAggregateInputType = {
    id?: true
    counterparty_id?: true
    counterparty_type?: true
    overall_exposure_limit?: true
    currency_limit?: true
    product_money_market_limit?: true
    product_fx_limit?: true
    product_derivative_limit?: true
    product_repo_limit?: true
    product_reverse_repo_limit?: true
    product_gsec_limit?: true
    product_sell_and_buy_back_limit?: true
    product_buy_and_sell_back_limit?: true
    tenor_limit?: true
    settlement_risk_limit?: true
    country_limit?: true
    group_limit?: true
    intraday_limit?: true
    created_at?: true
    product_transaction_limit?: true
    currency?: true
  }

  export type Counterparty_limitsMaxAggregateInputType = {
    id?: true
    counterparty_id?: true
    counterparty_type?: true
    overall_exposure_limit?: true
    currency_limit?: true
    product_money_market_limit?: true
    product_fx_limit?: true
    product_derivative_limit?: true
    product_repo_limit?: true
    product_reverse_repo_limit?: true
    product_gsec_limit?: true
    product_sell_and_buy_back_limit?: true
    product_buy_and_sell_back_limit?: true
    tenor_limit?: true
    settlement_risk_limit?: true
    country_limit?: true
    group_limit?: true
    intraday_limit?: true
    created_at?: true
    product_transaction_limit?: true
    currency?: true
  }

  export type Counterparty_limitsCountAggregateInputType = {
    id?: true
    counterparty_id?: true
    counterparty_type?: true
    overall_exposure_limit?: true
    currency_limit?: true
    product_money_market_limit?: true
    product_fx_limit?: true
    product_derivative_limit?: true
    product_repo_limit?: true
    product_reverse_repo_limit?: true
    product_gsec_limit?: true
    product_sell_and_buy_back_limit?: true
    product_buy_and_sell_back_limit?: true
    tenor_limit?: true
    settlement_risk_limit?: true
    country_limit?: true
    group_limit?: true
    intraday_limit?: true
    created_at?: true
    product_transaction_limit?: true
    currency?: true
    _all?: true
  }

  export type Counterparty_limitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counterparty_limits to aggregate.
     */
    where?: counterparty_limitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_limits to fetch.
     */
    orderBy?: counterparty_limitsOrderByWithRelationInput | counterparty_limitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counterparty_limitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_limits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_limits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counterparty_limits
    **/
    _count?: true | Counterparty_limitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Counterparty_limitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Counterparty_limitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Counterparty_limitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Counterparty_limitsMaxAggregateInputType
  }

  export type GetCounterparty_limitsAggregateType<T extends Counterparty_limitsAggregateArgs> = {
        [P in keyof T & keyof AggregateCounterparty_limits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounterparty_limits[P]>
      : GetScalarType<T[P], AggregateCounterparty_limits[P]>
  }




  export type counterparty_limitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counterparty_limitsWhereInput
    orderBy?: counterparty_limitsOrderByWithAggregationInput | counterparty_limitsOrderByWithAggregationInput[]
    by: Counterparty_limitsScalarFieldEnum[] | Counterparty_limitsScalarFieldEnum
    having?: counterparty_limitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Counterparty_limitsCountAggregateInputType | true
    _avg?: Counterparty_limitsAvgAggregateInputType
    _sum?: Counterparty_limitsSumAggregateInputType
    _min?: Counterparty_limitsMinAggregateInputType
    _max?: Counterparty_limitsMaxAggregateInputType
  }

  export type Counterparty_limitsGroupByOutputType = {
    id: number
    counterparty_id: number
    counterparty_type: $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit: Decimal | null
    currency_limit: string | null
    product_money_market_limit: Decimal | null
    product_fx_limit: Decimal | null
    product_derivative_limit: Decimal | null
    product_repo_limit: Decimal | null
    product_reverse_repo_limit: Decimal | null
    product_gsec_limit: Decimal | null
    product_sell_and_buy_back_limit: Decimal | null
    product_buy_and_sell_back_limit: Decimal | null
    tenor_limit: Decimal | null
    settlement_risk_limit: Decimal | null
    country_limit: Decimal | null
    group_limit: Decimal | null
    intraday_limit: Decimal | null
    created_at: Date | null
    product_transaction_limit: Decimal | null
    currency: string | null
    _count: Counterparty_limitsCountAggregateOutputType | null
    _avg: Counterparty_limitsAvgAggregateOutputType | null
    _sum: Counterparty_limitsSumAggregateOutputType | null
    _min: Counterparty_limitsMinAggregateOutputType | null
    _max: Counterparty_limitsMaxAggregateOutputType | null
  }

  type GetCounterparty_limitsGroupByPayload<T extends counterparty_limitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Counterparty_limitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Counterparty_limitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Counterparty_limitsGroupByOutputType[P]>
            : GetScalarType<T[P], Counterparty_limitsGroupByOutputType[P]>
        }
      >
    >


  export type counterparty_limitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counterparty_id?: boolean
    counterparty_type?: boolean
    overall_exposure_limit?: boolean
    currency_limit?: boolean
    product_money_market_limit?: boolean
    product_fx_limit?: boolean
    product_derivative_limit?: boolean
    product_repo_limit?: boolean
    product_reverse_repo_limit?: boolean
    product_gsec_limit?: boolean
    product_sell_and_buy_back_limit?: boolean
    product_buy_and_sell_back_limit?: boolean
    tenor_limit?: boolean
    settlement_risk_limit?: boolean
    country_limit?: boolean
    group_limit?: boolean
    intraday_limit?: boolean
    created_at?: boolean
    product_transaction_limit?: boolean
    currency?: boolean
  }, ExtArgs["result"]["counterparty_limits"]>



  export type counterparty_limitsSelectScalar = {
    id?: boolean
    counterparty_id?: boolean
    counterparty_type?: boolean
    overall_exposure_limit?: boolean
    currency_limit?: boolean
    product_money_market_limit?: boolean
    product_fx_limit?: boolean
    product_derivative_limit?: boolean
    product_repo_limit?: boolean
    product_reverse_repo_limit?: boolean
    product_gsec_limit?: boolean
    product_sell_and_buy_back_limit?: boolean
    product_buy_and_sell_back_limit?: boolean
    tenor_limit?: boolean
    settlement_risk_limit?: boolean
    country_limit?: boolean
    group_limit?: boolean
    intraday_limit?: boolean
    created_at?: boolean
    product_transaction_limit?: boolean
    currency?: boolean
  }

  export type counterparty_limitsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "counterparty_id" | "counterparty_type" | "overall_exposure_limit" | "currency_limit" | "product_money_market_limit" | "product_fx_limit" | "product_derivative_limit" | "product_repo_limit" | "product_reverse_repo_limit" | "product_gsec_limit" | "product_sell_and_buy_back_limit" | "product_buy_and_sell_back_limit" | "tenor_limit" | "settlement_risk_limit" | "country_limit" | "group_limit" | "intraday_limit" | "created_at" | "product_transaction_limit" | "currency", ExtArgs["result"]["counterparty_limits"]>

  export type $counterparty_limitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counterparty_limits"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      counterparty_id: number
      counterparty_type: $Enums.counterparty_limits_counterparty_type
      overall_exposure_limit: Prisma.Decimal | null
      currency_limit: string | null
      product_money_market_limit: Prisma.Decimal | null
      product_fx_limit: Prisma.Decimal | null
      product_derivative_limit: Prisma.Decimal | null
      product_repo_limit: Prisma.Decimal | null
      product_reverse_repo_limit: Prisma.Decimal | null
      product_gsec_limit: Prisma.Decimal | null
      product_sell_and_buy_back_limit: Prisma.Decimal | null
      product_buy_and_sell_back_limit: Prisma.Decimal | null
      tenor_limit: Prisma.Decimal | null
      settlement_risk_limit: Prisma.Decimal | null
      country_limit: Prisma.Decimal | null
      group_limit: Prisma.Decimal | null
      intraday_limit: Prisma.Decimal | null
      created_at: Date | null
      product_transaction_limit: Prisma.Decimal | null
      currency: string | null
    }, ExtArgs["result"]["counterparty_limits"]>
    composites: {}
  }

  type counterparty_limitsGetPayload<S extends boolean | null | undefined | counterparty_limitsDefaultArgs> = $Result.GetResult<Prisma.$counterparty_limitsPayload, S>

  type counterparty_limitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<counterparty_limitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Counterparty_limitsCountAggregateInputType | true
    }

  export interface counterparty_limitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counterparty_limits'], meta: { name: 'counterparty_limits' } }
    /**
     * Find zero or one Counterparty_limits that matches the filter.
     * @param {counterparty_limitsFindUniqueArgs} args - Arguments to find a Counterparty_limits
     * @example
     * // Get one Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends counterparty_limitsFindUniqueArgs>(args: SelectSubset<T, counterparty_limitsFindUniqueArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Counterparty_limits that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {counterparty_limitsFindUniqueOrThrowArgs} args - Arguments to find a Counterparty_limits
     * @example
     * // Get one Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends counterparty_limitsFindUniqueOrThrowArgs>(args: SelectSubset<T, counterparty_limitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counterparty_limits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_limitsFindFirstArgs} args - Arguments to find a Counterparty_limits
     * @example
     * // Get one Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends counterparty_limitsFindFirstArgs>(args?: SelectSubset<T, counterparty_limitsFindFirstArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counterparty_limits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_limitsFindFirstOrThrowArgs} args - Arguments to find a Counterparty_limits
     * @example
     * // Get one Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends counterparty_limitsFindFirstOrThrowArgs>(args?: SelectSubset<T, counterparty_limitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counterparty_limits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_limitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.findMany()
     * 
     * // Get first 10 Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counterparty_limitsWithIdOnly = await prisma.counterparty_limits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends counterparty_limitsFindManyArgs>(args?: SelectSubset<T, counterparty_limitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Counterparty_limits.
     * @param {counterparty_limitsCreateArgs} args - Arguments to create a Counterparty_limits.
     * @example
     * // Create one Counterparty_limits
     * const Counterparty_limits = await prisma.counterparty_limits.create({
     *   data: {
     *     // ... data to create a Counterparty_limits
     *   }
     * })
     * 
     */
    create<T extends counterparty_limitsCreateArgs>(args: SelectSubset<T, counterparty_limitsCreateArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counterparty_limits.
     * @param {counterparty_limitsCreateManyArgs} args - Arguments to create many Counterparty_limits.
     * @example
     * // Create many Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends counterparty_limitsCreateManyArgs>(args?: SelectSubset<T, counterparty_limitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Counterparty_limits.
     * @param {counterparty_limitsDeleteArgs} args - Arguments to delete one Counterparty_limits.
     * @example
     * // Delete one Counterparty_limits
     * const Counterparty_limits = await prisma.counterparty_limits.delete({
     *   where: {
     *     // ... filter to delete one Counterparty_limits
     *   }
     * })
     * 
     */
    delete<T extends counterparty_limitsDeleteArgs>(args: SelectSubset<T, counterparty_limitsDeleteArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Counterparty_limits.
     * @param {counterparty_limitsUpdateArgs} args - Arguments to update one Counterparty_limits.
     * @example
     * // Update one Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends counterparty_limitsUpdateArgs>(args: SelectSubset<T, counterparty_limitsUpdateArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counterparty_limits.
     * @param {counterparty_limitsDeleteManyArgs} args - Arguments to filter Counterparty_limits to delete.
     * @example
     * // Delete a few Counterparty_limits
     * const { count } = await prisma.counterparty_limits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends counterparty_limitsDeleteManyArgs>(args?: SelectSubset<T, counterparty_limitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counterparty_limits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_limitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends counterparty_limitsUpdateManyArgs>(args: SelectSubset<T, counterparty_limitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counterparty_limits.
     * @param {counterparty_limitsUpsertArgs} args - Arguments to update or create a Counterparty_limits.
     * @example
     * // Update or create a Counterparty_limits
     * const counterparty_limits = await prisma.counterparty_limits.upsert({
     *   create: {
     *     // ... data to create a Counterparty_limits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counterparty_limits we want to update
     *   }
     * })
     */
    upsert<T extends counterparty_limitsUpsertArgs>(args: SelectSubset<T, counterparty_limitsUpsertArgs<ExtArgs>>): Prisma__counterparty_limitsClient<$Result.GetResult<Prisma.$counterparty_limitsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counterparty_limits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_limitsCountArgs} args - Arguments to filter Counterparty_limits to count.
     * @example
     * // Count the number of Counterparty_limits
     * const count = await prisma.counterparty_limits.count({
     *   where: {
     *     // ... the filter for the Counterparty_limits we want to count
     *   }
     * })
    **/
    count<T extends counterparty_limitsCountArgs>(
      args?: Subset<T, counterparty_limitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Counterparty_limitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counterparty_limits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Counterparty_limitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Counterparty_limitsAggregateArgs>(args: Subset<T, Counterparty_limitsAggregateArgs>): Prisma.PrismaPromise<GetCounterparty_limitsAggregateType<T>>

    /**
     * Group by Counterparty_limits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_limitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counterparty_limitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counterparty_limitsGroupByArgs['orderBy'] }
        : { orderBy?: counterparty_limitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counterparty_limitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterparty_limitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counterparty_limits model
   */
  readonly fields: counterparty_limitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counterparty_limits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counterparty_limitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the counterparty_limits model
   */
  interface counterparty_limitsFieldRefs {
    readonly id: FieldRef<"counterparty_limits", 'Int'>
    readonly counterparty_id: FieldRef<"counterparty_limits", 'Int'>
    readonly counterparty_type: FieldRef<"counterparty_limits", 'counterparty_limits_counterparty_type'>
    readonly overall_exposure_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly currency_limit: FieldRef<"counterparty_limits", 'String'>
    readonly product_money_market_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_fx_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_derivative_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_repo_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_reverse_repo_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_gsec_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_sell_and_buy_back_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly product_buy_and_sell_back_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly tenor_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly settlement_risk_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly country_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly group_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly intraday_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly created_at: FieldRef<"counterparty_limits", 'DateTime'>
    readonly product_transaction_limit: FieldRef<"counterparty_limits", 'Decimal'>
    readonly currency: FieldRef<"counterparty_limits", 'String'>
  }
    

  // Custom InputTypes
  /**
   * counterparty_limits findUnique
   */
  export type counterparty_limitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_limits to fetch.
     */
    where: counterparty_limitsWhereUniqueInput
  }

  /**
   * counterparty_limits findUniqueOrThrow
   */
  export type counterparty_limitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_limits to fetch.
     */
    where: counterparty_limitsWhereUniqueInput
  }

  /**
   * counterparty_limits findFirst
   */
  export type counterparty_limitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_limits to fetch.
     */
    where?: counterparty_limitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_limits to fetch.
     */
    orderBy?: counterparty_limitsOrderByWithRelationInput | counterparty_limitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counterparty_limits.
     */
    cursor?: counterparty_limitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_limits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_limits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counterparty_limits.
     */
    distinct?: Counterparty_limitsScalarFieldEnum | Counterparty_limitsScalarFieldEnum[]
  }

  /**
   * counterparty_limits findFirstOrThrow
   */
  export type counterparty_limitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_limits to fetch.
     */
    where?: counterparty_limitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_limits to fetch.
     */
    orderBy?: counterparty_limitsOrderByWithRelationInput | counterparty_limitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counterparty_limits.
     */
    cursor?: counterparty_limitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_limits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_limits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counterparty_limits.
     */
    distinct?: Counterparty_limitsScalarFieldEnum | Counterparty_limitsScalarFieldEnum[]
  }

  /**
   * counterparty_limits findMany
   */
  export type counterparty_limitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_limits to fetch.
     */
    where?: counterparty_limitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_limits to fetch.
     */
    orderBy?: counterparty_limitsOrderByWithRelationInput | counterparty_limitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counterparty_limits.
     */
    cursor?: counterparty_limitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_limits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_limits.
     */
    skip?: number
    distinct?: Counterparty_limitsScalarFieldEnum | Counterparty_limitsScalarFieldEnum[]
  }

  /**
   * counterparty_limits create
   */
  export type counterparty_limitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * The data needed to create a counterparty_limits.
     */
    data: XOR<counterparty_limitsCreateInput, counterparty_limitsUncheckedCreateInput>
  }

  /**
   * counterparty_limits createMany
   */
  export type counterparty_limitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counterparty_limits.
     */
    data: counterparty_limitsCreateManyInput | counterparty_limitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * counterparty_limits update
   */
  export type counterparty_limitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * The data needed to update a counterparty_limits.
     */
    data: XOR<counterparty_limitsUpdateInput, counterparty_limitsUncheckedUpdateInput>
    /**
     * Choose, which counterparty_limits to update.
     */
    where: counterparty_limitsWhereUniqueInput
  }

  /**
   * counterparty_limits updateMany
   */
  export type counterparty_limitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counterparty_limits.
     */
    data: XOR<counterparty_limitsUpdateManyMutationInput, counterparty_limitsUncheckedUpdateManyInput>
    /**
     * Filter which counterparty_limits to update
     */
    where?: counterparty_limitsWhereInput
    /**
     * Limit how many counterparty_limits to update.
     */
    limit?: number
  }

  /**
   * counterparty_limits upsert
   */
  export type counterparty_limitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * The filter to search for the counterparty_limits to update in case it exists.
     */
    where: counterparty_limitsWhereUniqueInput
    /**
     * In case the counterparty_limits found by the `where` argument doesn't exist, create a new counterparty_limits with this data.
     */
    create: XOR<counterparty_limitsCreateInput, counterparty_limitsUncheckedCreateInput>
    /**
     * In case the counterparty_limits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counterparty_limitsUpdateInput, counterparty_limitsUncheckedUpdateInput>
  }

  /**
   * counterparty_limits delete
   */
  export type counterparty_limitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
    /**
     * Filter which counterparty_limits to delete.
     */
    where: counterparty_limitsWhereUniqueInput
  }

  /**
   * counterparty_limits deleteMany
   */
  export type counterparty_limitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counterparty_limits to delete
     */
    where?: counterparty_limitsWhereInput
    /**
     * Limit how many counterparty_limits to delete.
     */
    limit?: number
  }

  /**
   * counterparty_limits without action
   */
  export type counterparty_limitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_limits
     */
    select?: counterparty_limitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_limits
     */
    omit?: counterparty_limitsOmit<ExtArgs> | null
  }


  /**
   * Model counterparty_master_individual
   */

  export type AggregateCounterparty_master_individual = {
    _count: Counterparty_master_individualCountAggregateOutputType | null
    _avg: Counterparty_master_individualAvgAggregateOutputType | null
    _sum: Counterparty_master_individualSumAggregateOutputType | null
    _min: Counterparty_master_individualMinAggregateOutputType | null
    _max: Counterparty_master_individualMaxAggregateOutputType | null
  }

  export type Counterparty_master_individualAvgAggregateOutputType = {
    id: number | null
  }

  export type Counterparty_master_individualSumAggregateOutputType = {
    id: number | null
  }

  export type Counterparty_master_individualMinAggregateOutputType = {
    id: number | null
    title: string | null
    short_name: string | null
    long_name: string | null
    id_type: string | null
    house_number: string | null
    street_name: string | null
    province: string | null
    postal_code: string | null
    city: string | null
    country: string | null
    telephone: string | null
    email: string | null
    mobile: string | null
    created_at: Date | null
  }

  export type Counterparty_master_individualMaxAggregateOutputType = {
    id: number | null
    title: string | null
    short_name: string | null
    long_name: string | null
    id_type: string | null
    house_number: string | null
    street_name: string | null
    province: string | null
    postal_code: string | null
    city: string | null
    country: string | null
    telephone: string | null
    email: string | null
    mobile: string | null
    created_at: Date | null
  }

  export type Counterparty_master_individualCountAggregateOutputType = {
    id: number
    title: number
    short_name: number
    long_name: number
    id_type: number
    house_number: number
    street_name: number
    province: number
    postal_code: number
    city: number
    country: number
    telephone: number
    email: number
    mobile: number
    created_at: number
    _all: number
  }


  export type Counterparty_master_individualAvgAggregateInputType = {
    id?: true
  }

  export type Counterparty_master_individualSumAggregateInputType = {
    id?: true
  }

  export type Counterparty_master_individualMinAggregateInputType = {
    id?: true
    title?: true
    short_name?: true
    long_name?: true
    id_type?: true
    house_number?: true
    street_name?: true
    province?: true
    postal_code?: true
    city?: true
    country?: true
    telephone?: true
    email?: true
    mobile?: true
    created_at?: true
  }

  export type Counterparty_master_individualMaxAggregateInputType = {
    id?: true
    title?: true
    short_name?: true
    long_name?: true
    id_type?: true
    house_number?: true
    street_name?: true
    province?: true
    postal_code?: true
    city?: true
    country?: true
    telephone?: true
    email?: true
    mobile?: true
    created_at?: true
  }

  export type Counterparty_master_individualCountAggregateInputType = {
    id?: true
    title?: true
    short_name?: true
    long_name?: true
    id_type?: true
    house_number?: true
    street_name?: true
    province?: true
    postal_code?: true
    city?: true
    country?: true
    telephone?: true
    email?: true
    mobile?: true
    created_at?: true
    _all?: true
  }

  export type Counterparty_master_individualAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counterparty_master_individual to aggregate.
     */
    where?: counterparty_master_individualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_individuals to fetch.
     */
    orderBy?: counterparty_master_individualOrderByWithRelationInput | counterparty_master_individualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counterparty_master_individualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counterparty_master_individuals
    **/
    _count?: true | Counterparty_master_individualCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Counterparty_master_individualAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Counterparty_master_individualSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Counterparty_master_individualMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Counterparty_master_individualMaxAggregateInputType
  }

  export type GetCounterparty_master_individualAggregateType<T extends Counterparty_master_individualAggregateArgs> = {
        [P in keyof T & keyof AggregateCounterparty_master_individual]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounterparty_master_individual[P]>
      : GetScalarType<T[P], AggregateCounterparty_master_individual[P]>
  }




  export type counterparty_master_individualGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counterparty_master_individualWhereInput
    orderBy?: counterparty_master_individualOrderByWithAggregationInput | counterparty_master_individualOrderByWithAggregationInput[]
    by: Counterparty_master_individualScalarFieldEnum[] | Counterparty_master_individualScalarFieldEnum
    having?: counterparty_master_individualScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Counterparty_master_individualCountAggregateInputType | true
    _avg?: Counterparty_master_individualAvgAggregateInputType
    _sum?: Counterparty_master_individualSumAggregateInputType
    _min?: Counterparty_master_individualMinAggregateInputType
    _max?: Counterparty_master_individualMaxAggregateInputType
  }

  export type Counterparty_master_individualGroupByOutputType = {
    id: number
    title: string | null
    short_name: string | null
    long_name: string | null
    id_type: string | null
    house_number: string | null
    street_name: string | null
    province: string | null
    postal_code: string | null
    city: string | null
    country: string | null
    telephone: string | null
    email: string | null
    mobile: string | null
    created_at: Date | null
    _count: Counterparty_master_individualCountAggregateOutputType | null
    _avg: Counterparty_master_individualAvgAggregateOutputType | null
    _sum: Counterparty_master_individualSumAggregateOutputType | null
    _min: Counterparty_master_individualMinAggregateOutputType | null
    _max: Counterparty_master_individualMaxAggregateOutputType | null
  }

  type GetCounterparty_master_individualGroupByPayload<T extends counterparty_master_individualGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Counterparty_master_individualGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Counterparty_master_individualGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Counterparty_master_individualGroupByOutputType[P]>
            : GetScalarType<T[P], Counterparty_master_individualGroupByOutputType[P]>
        }
      >
    >


  export type counterparty_master_individualSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    short_name?: boolean
    long_name?: boolean
    id_type?: boolean
    house_number?: boolean
    street_name?: boolean
    province?: boolean
    postal_code?: boolean
    city?: boolean
    country?: boolean
    telephone?: boolean
    email?: boolean
    mobile?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["counterparty_master_individual"]>



  export type counterparty_master_individualSelectScalar = {
    id?: boolean
    title?: boolean
    short_name?: boolean
    long_name?: boolean
    id_type?: boolean
    house_number?: boolean
    street_name?: boolean
    province?: boolean
    postal_code?: boolean
    city?: boolean
    country?: boolean
    telephone?: boolean
    email?: boolean
    mobile?: boolean
    created_at?: boolean
  }

  export type counterparty_master_individualOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "short_name" | "long_name" | "id_type" | "house_number" | "street_name" | "province" | "postal_code" | "city" | "country" | "telephone" | "email" | "mobile" | "created_at", ExtArgs["result"]["counterparty_master_individual"]>

  export type $counterparty_master_individualPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counterparty_master_individual"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      short_name: string | null
      long_name: string | null
      id_type: string | null
      house_number: string | null
      street_name: string | null
      province: string | null
      postal_code: string | null
      city: string | null
      country: string | null
      telephone: string | null
      email: string | null
      mobile: string | null
      created_at: Date | null
    }, ExtArgs["result"]["counterparty_master_individual"]>
    composites: {}
  }

  type counterparty_master_individualGetPayload<S extends boolean | null | undefined | counterparty_master_individualDefaultArgs> = $Result.GetResult<Prisma.$counterparty_master_individualPayload, S>

  type counterparty_master_individualCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<counterparty_master_individualFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Counterparty_master_individualCountAggregateInputType | true
    }

  export interface counterparty_master_individualDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counterparty_master_individual'], meta: { name: 'counterparty_master_individual' } }
    /**
     * Find zero or one Counterparty_master_individual that matches the filter.
     * @param {counterparty_master_individualFindUniqueArgs} args - Arguments to find a Counterparty_master_individual
     * @example
     * // Get one Counterparty_master_individual
     * const counterparty_master_individual = await prisma.counterparty_master_individual.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends counterparty_master_individualFindUniqueArgs>(args: SelectSubset<T, counterparty_master_individualFindUniqueArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Counterparty_master_individual that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {counterparty_master_individualFindUniqueOrThrowArgs} args - Arguments to find a Counterparty_master_individual
     * @example
     * // Get one Counterparty_master_individual
     * const counterparty_master_individual = await prisma.counterparty_master_individual.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends counterparty_master_individualFindUniqueOrThrowArgs>(args: SelectSubset<T, counterparty_master_individualFindUniqueOrThrowArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counterparty_master_individual that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_individualFindFirstArgs} args - Arguments to find a Counterparty_master_individual
     * @example
     * // Get one Counterparty_master_individual
     * const counterparty_master_individual = await prisma.counterparty_master_individual.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends counterparty_master_individualFindFirstArgs>(args?: SelectSubset<T, counterparty_master_individualFindFirstArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counterparty_master_individual that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_individualFindFirstOrThrowArgs} args - Arguments to find a Counterparty_master_individual
     * @example
     * // Get one Counterparty_master_individual
     * const counterparty_master_individual = await prisma.counterparty_master_individual.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends counterparty_master_individualFindFirstOrThrowArgs>(args?: SelectSubset<T, counterparty_master_individualFindFirstOrThrowArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counterparty_master_individuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_individualFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counterparty_master_individuals
     * const counterparty_master_individuals = await prisma.counterparty_master_individual.findMany()
     * 
     * // Get first 10 Counterparty_master_individuals
     * const counterparty_master_individuals = await prisma.counterparty_master_individual.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counterparty_master_individualWithIdOnly = await prisma.counterparty_master_individual.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends counterparty_master_individualFindManyArgs>(args?: SelectSubset<T, counterparty_master_individualFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Counterparty_master_individual.
     * @param {counterparty_master_individualCreateArgs} args - Arguments to create a Counterparty_master_individual.
     * @example
     * // Create one Counterparty_master_individual
     * const Counterparty_master_individual = await prisma.counterparty_master_individual.create({
     *   data: {
     *     // ... data to create a Counterparty_master_individual
     *   }
     * })
     * 
     */
    create<T extends counterparty_master_individualCreateArgs>(args: SelectSubset<T, counterparty_master_individualCreateArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counterparty_master_individuals.
     * @param {counterparty_master_individualCreateManyArgs} args - Arguments to create many Counterparty_master_individuals.
     * @example
     * // Create many Counterparty_master_individuals
     * const counterparty_master_individual = await prisma.counterparty_master_individual.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends counterparty_master_individualCreateManyArgs>(args?: SelectSubset<T, counterparty_master_individualCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Counterparty_master_individual.
     * @param {counterparty_master_individualDeleteArgs} args - Arguments to delete one Counterparty_master_individual.
     * @example
     * // Delete one Counterparty_master_individual
     * const Counterparty_master_individual = await prisma.counterparty_master_individual.delete({
     *   where: {
     *     // ... filter to delete one Counterparty_master_individual
     *   }
     * })
     * 
     */
    delete<T extends counterparty_master_individualDeleteArgs>(args: SelectSubset<T, counterparty_master_individualDeleteArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Counterparty_master_individual.
     * @param {counterparty_master_individualUpdateArgs} args - Arguments to update one Counterparty_master_individual.
     * @example
     * // Update one Counterparty_master_individual
     * const counterparty_master_individual = await prisma.counterparty_master_individual.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends counterparty_master_individualUpdateArgs>(args: SelectSubset<T, counterparty_master_individualUpdateArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counterparty_master_individuals.
     * @param {counterparty_master_individualDeleteManyArgs} args - Arguments to filter Counterparty_master_individuals to delete.
     * @example
     * // Delete a few Counterparty_master_individuals
     * const { count } = await prisma.counterparty_master_individual.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends counterparty_master_individualDeleteManyArgs>(args?: SelectSubset<T, counterparty_master_individualDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counterparty_master_individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_individualUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counterparty_master_individuals
     * const counterparty_master_individual = await prisma.counterparty_master_individual.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends counterparty_master_individualUpdateManyArgs>(args: SelectSubset<T, counterparty_master_individualUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counterparty_master_individual.
     * @param {counterparty_master_individualUpsertArgs} args - Arguments to update or create a Counterparty_master_individual.
     * @example
     * // Update or create a Counterparty_master_individual
     * const counterparty_master_individual = await prisma.counterparty_master_individual.upsert({
     *   create: {
     *     // ... data to create a Counterparty_master_individual
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counterparty_master_individual we want to update
     *   }
     * })
     */
    upsert<T extends counterparty_master_individualUpsertArgs>(args: SelectSubset<T, counterparty_master_individualUpsertArgs<ExtArgs>>): Prisma__counterparty_master_individualClient<$Result.GetResult<Prisma.$counterparty_master_individualPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counterparty_master_individuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_individualCountArgs} args - Arguments to filter Counterparty_master_individuals to count.
     * @example
     * // Count the number of Counterparty_master_individuals
     * const count = await prisma.counterparty_master_individual.count({
     *   where: {
     *     // ... the filter for the Counterparty_master_individuals we want to count
     *   }
     * })
    **/
    count<T extends counterparty_master_individualCountArgs>(
      args?: Subset<T, counterparty_master_individualCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Counterparty_master_individualCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counterparty_master_individual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Counterparty_master_individualAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Counterparty_master_individualAggregateArgs>(args: Subset<T, Counterparty_master_individualAggregateArgs>): Prisma.PrismaPromise<GetCounterparty_master_individualAggregateType<T>>

    /**
     * Group by Counterparty_master_individual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_individualGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counterparty_master_individualGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counterparty_master_individualGroupByArgs['orderBy'] }
        : { orderBy?: counterparty_master_individualGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counterparty_master_individualGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterparty_master_individualGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counterparty_master_individual model
   */
  readonly fields: counterparty_master_individualFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counterparty_master_individual.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counterparty_master_individualClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the counterparty_master_individual model
   */
  interface counterparty_master_individualFieldRefs {
    readonly id: FieldRef<"counterparty_master_individual", 'Int'>
    readonly title: FieldRef<"counterparty_master_individual", 'String'>
    readonly short_name: FieldRef<"counterparty_master_individual", 'String'>
    readonly long_name: FieldRef<"counterparty_master_individual", 'String'>
    readonly id_type: FieldRef<"counterparty_master_individual", 'String'>
    readonly house_number: FieldRef<"counterparty_master_individual", 'String'>
    readonly street_name: FieldRef<"counterparty_master_individual", 'String'>
    readonly province: FieldRef<"counterparty_master_individual", 'String'>
    readonly postal_code: FieldRef<"counterparty_master_individual", 'String'>
    readonly city: FieldRef<"counterparty_master_individual", 'String'>
    readonly country: FieldRef<"counterparty_master_individual", 'String'>
    readonly telephone: FieldRef<"counterparty_master_individual", 'String'>
    readonly email: FieldRef<"counterparty_master_individual", 'String'>
    readonly mobile: FieldRef<"counterparty_master_individual", 'String'>
    readonly created_at: FieldRef<"counterparty_master_individual", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * counterparty_master_individual findUnique
   */
  export type counterparty_master_individualFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_individual to fetch.
     */
    where: counterparty_master_individualWhereUniqueInput
  }

  /**
   * counterparty_master_individual findUniqueOrThrow
   */
  export type counterparty_master_individualFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_individual to fetch.
     */
    where: counterparty_master_individualWhereUniqueInput
  }

  /**
   * counterparty_master_individual findFirst
   */
  export type counterparty_master_individualFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_individual to fetch.
     */
    where?: counterparty_master_individualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_individuals to fetch.
     */
    orderBy?: counterparty_master_individualOrderByWithRelationInput | counterparty_master_individualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counterparty_master_individuals.
     */
    cursor?: counterparty_master_individualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counterparty_master_individuals.
     */
    distinct?: Counterparty_master_individualScalarFieldEnum | Counterparty_master_individualScalarFieldEnum[]
  }

  /**
   * counterparty_master_individual findFirstOrThrow
   */
  export type counterparty_master_individualFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_individual to fetch.
     */
    where?: counterparty_master_individualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_individuals to fetch.
     */
    orderBy?: counterparty_master_individualOrderByWithRelationInput | counterparty_master_individualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counterparty_master_individuals.
     */
    cursor?: counterparty_master_individualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_individuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counterparty_master_individuals.
     */
    distinct?: Counterparty_master_individualScalarFieldEnum | Counterparty_master_individualScalarFieldEnum[]
  }

  /**
   * counterparty_master_individual findMany
   */
  export type counterparty_master_individualFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_individuals to fetch.
     */
    where?: counterparty_master_individualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_individuals to fetch.
     */
    orderBy?: counterparty_master_individualOrderByWithRelationInput | counterparty_master_individualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counterparty_master_individuals.
     */
    cursor?: counterparty_master_individualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_individuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_individuals.
     */
    skip?: number
    distinct?: Counterparty_master_individualScalarFieldEnum | Counterparty_master_individualScalarFieldEnum[]
  }

  /**
   * counterparty_master_individual create
   */
  export type counterparty_master_individualCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * The data needed to create a counterparty_master_individual.
     */
    data?: XOR<counterparty_master_individualCreateInput, counterparty_master_individualUncheckedCreateInput>
  }

  /**
   * counterparty_master_individual createMany
   */
  export type counterparty_master_individualCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counterparty_master_individuals.
     */
    data: counterparty_master_individualCreateManyInput | counterparty_master_individualCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * counterparty_master_individual update
   */
  export type counterparty_master_individualUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * The data needed to update a counterparty_master_individual.
     */
    data: XOR<counterparty_master_individualUpdateInput, counterparty_master_individualUncheckedUpdateInput>
    /**
     * Choose, which counterparty_master_individual to update.
     */
    where: counterparty_master_individualWhereUniqueInput
  }

  /**
   * counterparty_master_individual updateMany
   */
  export type counterparty_master_individualUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counterparty_master_individuals.
     */
    data: XOR<counterparty_master_individualUpdateManyMutationInput, counterparty_master_individualUncheckedUpdateManyInput>
    /**
     * Filter which counterparty_master_individuals to update
     */
    where?: counterparty_master_individualWhereInput
    /**
     * Limit how many counterparty_master_individuals to update.
     */
    limit?: number
  }

  /**
   * counterparty_master_individual upsert
   */
  export type counterparty_master_individualUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * The filter to search for the counterparty_master_individual to update in case it exists.
     */
    where: counterparty_master_individualWhereUniqueInput
    /**
     * In case the counterparty_master_individual found by the `where` argument doesn't exist, create a new counterparty_master_individual with this data.
     */
    create: XOR<counterparty_master_individualCreateInput, counterparty_master_individualUncheckedCreateInput>
    /**
     * In case the counterparty_master_individual was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counterparty_master_individualUpdateInput, counterparty_master_individualUncheckedUpdateInput>
  }

  /**
   * counterparty_master_individual delete
   */
  export type counterparty_master_individualDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
    /**
     * Filter which counterparty_master_individual to delete.
     */
    where: counterparty_master_individualWhereUniqueInput
  }

  /**
   * counterparty_master_individual deleteMany
   */
  export type counterparty_master_individualDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counterparty_master_individuals to delete
     */
    where?: counterparty_master_individualWhereInput
    /**
     * Limit how many counterparty_master_individuals to delete.
     */
    limit?: number
  }

  /**
   * counterparty_master_individual without action
   */
  export type counterparty_master_individualDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_individual
     */
    select?: counterparty_master_individualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_individual
     */
    omit?: counterparty_master_individualOmit<ExtArgs> | null
  }


  /**
   * Model counterparty_master_joint
   */

  export type AggregateCounterparty_master_joint = {
    _count: Counterparty_master_jointCountAggregateOutputType | null
    _avg: Counterparty_master_jointAvgAggregateOutputType | null
    _sum: Counterparty_master_jointSumAggregateOutputType | null
    _min: Counterparty_master_jointMinAggregateOutputType | null
    _max: Counterparty_master_jointMaxAggregateOutputType | null
  }

  export type Counterparty_master_jointAvgAggregateOutputType = {
    id: number | null
  }

  export type Counterparty_master_jointSumAggregateOutputType = {
    id: number | null
  }

  export type Counterparty_master_jointMinAggregateOutputType = {
    id: number | null
    title: string | null
    short_name: string | null
    long_name: string | null
    id_type: string | null
    house_number: string | null
    street_name: string | null
    province: string | null
    postal_code: string | null
    city: string | null
    country: string | null
    telephone: string | null
    email: string | null
    mobile: string | null
    created_at: Date | null
  }

  export type Counterparty_master_jointMaxAggregateOutputType = {
    id: number | null
    title: string | null
    short_name: string | null
    long_name: string | null
    id_type: string | null
    house_number: string | null
    street_name: string | null
    province: string | null
    postal_code: string | null
    city: string | null
    country: string | null
    telephone: string | null
    email: string | null
    mobile: string | null
    created_at: Date | null
  }

  export type Counterparty_master_jointCountAggregateOutputType = {
    id: number
    title: number
    short_name: number
    long_name: number
    id_type: number
    house_number: number
    street_name: number
    province: number
    postal_code: number
    city: number
    country: number
    telephone: number
    email: number
    mobile: number
    created_at: number
    _all: number
  }


  export type Counterparty_master_jointAvgAggregateInputType = {
    id?: true
  }

  export type Counterparty_master_jointSumAggregateInputType = {
    id?: true
  }

  export type Counterparty_master_jointMinAggregateInputType = {
    id?: true
    title?: true
    short_name?: true
    long_name?: true
    id_type?: true
    house_number?: true
    street_name?: true
    province?: true
    postal_code?: true
    city?: true
    country?: true
    telephone?: true
    email?: true
    mobile?: true
    created_at?: true
  }

  export type Counterparty_master_jointMaxAggregateInputType = {
    id?: true
    title?: true
    short_name?: true
    long_name?: true
    id_type?: true
    house_number?: true
    street_name?: true
    province?: true
    postal_code?: true
    city?: true
    country?: true
    telephone?: true
    email?: true
    mobile?: true
    created_at?: true
  }

  export type Counterparty_master_jointCountAggregateInputType = {
    id?: true
    title?: true
    short_name?: true
    long_name?: true
    id_type?: true
    house_number?: true
    street_name?: true
    province?: true
    postal_code?: true
    city?: true
    country?: true
    telephone?: true
    email?: true
    mobile?: true
    created_at?: true
    _all?: true
  }

  export type Counterparty_master_jointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counterparty_master_joint to aggregate.
     */
    where?: counterparty_master_jointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_joints to fetch.
     */
    orderBy?: counterparty_master_jointOrderByWithRelationInput | counterparty_master_jointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counterparty_master_jointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_joints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_joints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counterparty_master_joints
    **/
    _count?: true | Counterparty_master_jointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Counterparty_master_jointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Counterparty_master_jointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Counterparty_master_jointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Counterparty_master_jointMaxAggregateInputType
  }

  export type GetCounterparty_master_jointAggregateType<T extends Counterparty_master_jointAggregateArgs> = {
        [P in keyof T & keyof AggregateCounterparty_master_joint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounterparty_master_joint[P]>
      : GetScalarType<T[P], AggregateCounterparty_master_joint[P]>
  }




  export type counterparty_master_jointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counterparty_master_jointWhereInput
    orderBy?: counterparty_master_jointOrderByWithAggregationInput | counterparty_master_jointOrderByWithAggregationInput[]
    by: Counterparty_master_jointScalarFieldEnum[] | Counterparty_master_jointScalarFieldEnum
    having?: counterparty_master_jointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Counterparty_master_jointCountAggregateInputType | true
    _avg?: Counterparty_master_jointAvgAggregateInputType
    _sum?: Counterparty_master_jointSumAggregateInputType
    _min?: Counterparty_master_jointMinAggregateInputType
    _max?: Counterparty_master_jointMaxAggregateInputType
  }

  export type Counterparty_master_jointGroupByOutputType = {
    id: number
    title: string
    short_name: string | null
    long_name: string | null
    id_type: string
    house_number: string | null
    street_name: string | null
    province: string | null
    postal_code: string | null
    city: string | null
    country: string | null
    telephone: string | null
    email: string | null
    mobile: string | null
    created_at: Date | null
    _count: Counterparty_master_jointCountAggregateOutputType | null
    _avg: Counterparty_master_jointAvgAggregateOutputType | null
    _sum: Counterparty_master_jointSumAggregateOutputType | null
    _min: Counterparty_master_jointMinAggregateOutputType | null
    _max: Counterparty_master_jointMaxAggregateOutputType | null
  }

  type GetCounterparty_master_jointGroupByPayload<T extends counterparty_master_jointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Counterparty_master_jointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Counterparty_master_jointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Counterparty_master_jointGroupByOutputType[P]>
            : GetScalarType<T[P], Counterparty_master_jointGroupByOutputType[P]>
        }
      >
    >


  export type counterparty_master_jointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    short_name?: boolean
    long_name?: boolean
    id_type?: boolean
    house_number?: boolean
    street_name?: boolean
    province?: boolean
    postal_code?: boolean
    city?: boolean
    country?: boolean
    telephone?: boolean
    email?: boolean
    mobile?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["counterparty_master_joint"]>



  export type counterparty_master_jointSelectScalar = {
    id?: boolean
    title?: boolean
    short_name?: boolean
    long_name?: boolean
    id_type?: boolean
    house_number?: boolean
    street_name?: boolean
    province?: boolean
    postal_code?: boolean
    city?: boolean
    country?: boolean
    telephone?: boolean
    email?: boolean
    mobile?: boolean
    created_at?: boolean
  }

  export type counterparty_master_jointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "short_name" | "long_name" | "id_type" | "house_number" | "street_name" | "province" | "postal_code" | "city" | "country" | "telephone" | "email" | "mobile" | "created_at", ExtArgs["result"]["counterparty_master_joint"]>

  export type $counterparty_master_jointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counterparty_master_joint"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      short_name: string | null
      long_name: string | null
      id_type: string
      house_number: string | null
      street_name: string | null
      province: string | null
      postal_code: string | null
      city: string | null
      country: string | null
      telephone: string | null
      email: string | null
      mobile: string | null
      created_at: Date | null
    }, ExtArgs["result"]["counterparty_master_joint"]>
    composites: {}
  }

  type counterparty_master_jointGetPayload<S extends boolean | null | undefined | counterparty_master_jointDefaultArgs> = $Result.GetResult<Prisma.$counterparty_master_jointPayload, S>

  type counterparty_master_jointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<counterparty_master_jointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Counterparty_master_jointCountAggregateInputType | true
    }

  export interface counterparty_master_jointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counterparty_master_joint'], meta: { name: 'counterparty_master_joint' } }
    /**
     * Find zero or one Counterparty_master_joint that matches the filter.
     * @param {counterparty_master_jointFindUniqueArgs} args - Arguments to find a Counterparty_master_joint
     * @example
     * // Get one Counterparty_master_joint
     * const counterparty_master_joint = await prisma.counterparty_master_joint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends counterparty_master_jointFindUniqueArgs>(args: SelectSubset<T, counterparty_master_jointFindUniqueArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Counterparty_master_joint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {counterparty_master_jointFindUniqueOrThrowArgs} args - Arguments to find a Counterparty_master_joint
     * @example
     * // Get one Counterparty_master_joint
     * const counterparty_master_joint = await prisma.counterparty_master_joint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends counterparty_master_jointFindUniqueOrThrowArgs>(args: SelectSubset<T, counterparty_master_jointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counterparty_master_joint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_jointFindFirstArgs} args - Arguments to find a Counterparty_master_joint
     * @example
     * // Get one Counterparty_master_joint
     * const counterparty_master_joint = await prisma.counterparty_master_joint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends counterparty_master_jointFindFirstArgs>(args?: SelectSubset<T, counterparty_master_jointFindFirstArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counterparty_master_joint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_jointFindFirstOrThrowArgs} args - Arguments to find a Counterparty_master_joint
     * @example
     * // Get one Counterparty_master_joint
     * const counterparty_master_joint = await prisma.counterparty_master_joint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends counterparty_master_jointFindFirstOrThrowArgs>(args?: SelectSubset<T, counterparty_master_jointFindFirstOrThrowArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counterparty_master_joints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_jointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counterparty_master_joints
     * const counterparty_master_joints = await prisma.counterparty_master_joint.findMany()
     * 
     * // Get first 10 Counterparty_master_joints
     * const counterparty_master_joints = await prisma.counterparty_master_joint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counterparty_master_jointWithIdOnly = await prisma.counterparty_master_joint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends counterparty_master_jointFindManyArgs>(args?: SelectSubset<T, counterparty_master_jointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Counterparty_master_joint.
     * @param {counterparty_master_jointCreateArgs} args - Arguments to create a Counterparty_master_joint.
     * @example
     * // Create one Counterparty_master_joint
     * const Counterparty_master_joint = await prisma.counterparty_master_joint.create({
     *   data: {
     *     // ... data to create a Counterparty_master_joint
     *   }
     * })
     * 
     */
    create<T extends counterparty_master_jointCreateArgs>(args: SelectSubset<T, counterparty_master_jointCreateArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counterparty_master_joints.
     * @param {counterparty_master_jointCreateManyArgs} args - Arguments to create many Counterparty_master_joints.
     * @example
     * // Create many Counterparty_master_joints
     * const counterparty_master_joint = await prisma.counterparty_master_joint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends counterparty_master_jointCreateManyArgs>(args?: SelectSubset<T, counterparty_master_jointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Counterparty_master_joint.
     * @param {counterparty_master_jointDeleteArgs} args - Arguments to delete one Counterparty_master_joint.
     * @example
     * // Delete one Counterparty_master_joint
     * const Counterparty_master_joint = await prisma.counterparty_master_joint.delete({
     *   where: {
     *     // ... filter to delete one Counterparty_master_joint
     *   }
     * })
     * 
     */
    delete<T extends counterparty_master_jointDeleteArgs>(args: SelectSubset<T, counterparty_master_jointDeleteArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Counterparty_master_joint.
     * @param {counterparty_master_jointUpdateArgs} args - Arguments to update one Counterparty_master_joint.
     * @example
     * // Update one Counterparty_master_joint
     * const counterparty_master_joint = await prisma.counterparty_master_joint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends counterparty_master_jointUpdateArgs>(args: SelectSubset<T, counterparty_master_jointUpdateArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counterparty_master_joints.
     * @param {counterparty_master_jointDeleteManyArgs} args - Arguments to filter Counterparty_master_joints to delete.
     * @example
     * // Delete a few Counterparty_master_joints
     * const { count } = await prisma.counterparty_master_joint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends counterparty_master_jointDeleteManyArgs>(args?: SelectSubset<T, counterparty_master_jointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counterparty_master_joints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_jointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counterparty_master_joints
     * const counterparty_master_joint = await prisma.counterparty_master_joint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends counterparty_master_jointUpdateManyArgs>(args: SelectSubset<T, counterparty_master_jointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counterparty_master_joint.
     * @param {counterparty_master_jointUpsertArgs} args - Arguments to update or create a Counterparty_master_joint.
     * @example
     * // Update or create a Counterparty_master_joint
     * const counterparty_master_joint = await prisma.counterparty_master_joint.upsert({
     *   create: {
     *     // ... data to create a Counterparty_master_joint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counterparty_master_joint we want to update
     *   }
     * })
     */
    upsert<T extends counterparty_master_jointUpsertArgs>(args: SelectSubset<T, counterparty_master_jointUpsertArgs<ExtArgs>>): Prisma__counterparty_master_jointClient<$Result.GetResult<Prisma.$counterparty_master_jointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counterparty_master_joints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_jointCountArgs} args - Arguments to filter Counterparty_master_joints to count.
     * @example
     * // Count the number of Counterparty_master_joints
     * const count = await prisma.counterparty_master_joint.count({
     *   where: {
     *     // ... the filter for the Counterparty_master_joints we want to count
     *   }
     * })
    **/
    count<T extends counterparty_master_jointCountArgs>(
      args?: Subset<T, counterparty_master_jointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Counterparty_master_jointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counterparty_master_joint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Counterparty_master_jointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Counterparty_master_jointAggregateArgs>(args: Subset<T, Counterparty_master_jointAggregateArgs>): Prisma.PrismaPromise<GetCounterparty_master_jointAggregateType<T>>

    /**
     * Group by Counterparty_master_joint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterparty_master_jointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counterparty_master_jointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counterparty_master_jointGroupByArgs['orderBy'] }
        : { orderBy?: counterparty_master_jointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counterparty_master_jointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterparty_master_jointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counterparty_master_joint model
   */
  readonly fields: counterparty_master_jointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counterparty_master_joint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counterparty_master_jointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the counterparty_master_joint model
   */
  interface counterparty_master_jointFieldRefs {
    readonly id: FieldRef<"counterparty_master_joint", 'Int'>
    readonly title: FieldRef<"counterparty_master_joint", 'String'>
    readonly short_name: FieldRef<"counterparty_master_joint", 'String'>
    readonly long_name: FieldRef<"counterparty_master_joint", 'String'>
    readonly id_type: FieldRef<"counterparty_master_joint", 'String'>
    readonly house_number: FieldRef<"counterparty_master_joint", 'String'>
    readonly street_name: FieldRef<"counterparty_master_joint", 'String'>
    readonly province: FieldRef<"counterparty_master_joint", 'String'>
    readonly postal_code: FieldRef<"counterparty_master_joint", 'String'>
    readonly city: FieldRef<"counterparty_master_joint", 'String'>
    readonly country: FieldRef<"counterparty_master_joint", 'String'>
    readonly telephone: FieldRef<"counterparty_master_joint", 'String'>
    readonly email: FieldRef<"counterparty_master_joint", 'String'>
    readonly mobile: FieldRef<"counterparty_master_joint", 'String'>
    readonly created_at: FieldRef<"counterparty_master_joint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * counterparty_master_joint findUnique
   */
  export type counterparty_master_jointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_joint to fetch.
     */
    where: counterparty_master_jointWhereUniqueInput
  }

  /**
   * counterparty_master_joint findUniqueOrThrow
   */
  export type counterparty_master_jointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_joint to fetch.
     */
    where: counterparty_master_jointWhereUniqueInput
  }

  /**
   * counterparty_master_joint findFirst
   */
  export type counterparty_master_jointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_joint to fetch.
     */
    where?: counterparty_master_jointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_joints to fetch.
     */
    orderBy?: counterparty_master_jointOrderByWithRelationInput | counterparty_master_jointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counterparty_master_joints.
     */
    cursor?: counterparty_master_jointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_joints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_joints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counterparty_master_joints.
     */
    distinct?: Counterparty_master_jointScalarFieldEnum | Counterparty_master_jointScalarFieldEnum[]
  }

  /**
   * counterparty_master_joint findFirstOrThrow
   */
  export type counterparty_master_jointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_joint to fetch.
     */
    where?: counterparty_master_jointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_joints to fetch.
     */
    orderBy?: counterparty_master_jointOrderByWithRelationInput | counterparty_master_jointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counterparty_master_joints.
     */
    cursor?: counterparty_master_jointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_joints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_joints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counterparty_master_joints.
     */
    distinct?: Counterparty_master_jointScalarFieldEnum | Counterparty_master_jointScalarFieldEnum[]
  }

  /**
   * counterparty_master_joint findMany
   */
  export type counterparty_master_jointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * Filter, which counterparty_master_joints to fetch.
     */
    where?: counterparty_master_jointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counterparty_master_joints to fetch.
     */
    orderBy?: counterparty_master_jointOrderByWithRelationInput | counterparty_master_jointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counterparty_master_joints.
     */
    cursor?: counterparty_master_jointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counterparty_master_joints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counterparty_master_joints.
     */
    skip?: number
    distinct?: Counterparty_master_jointScalarFieldEnum | Counterparty_master_jointScalarFieldEnum[]
  }

  /**
   * counterparty_master_joint create
   */
  export type counterparty_master_jointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * The data needed to create a counterparty_master_joint.
     */
    data: XOR<counterparty_master_jointCreateInput, counterparty_master_jointUncheckedCreateInput>
  }

  /**
   * counterparty_master_joint createMany
   */
  export type counterparty_master_jointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counterparty_master_joints.
     */
    data: counterparty_master_jointCreateManyInput | counterparty_master_jointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * counterparty_master_joint update
   */
  export type counterparty_master_jointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * The data needed to update a counterparty_master_joint.
     */
    data: XOR<counterparty_master_jointUpdateInput, counterparty_master_jointUncheckedUpdateInput>
    /**
     * Choose, which counterparty_master_joint to update.
     */
    where: counterparty_master_jointWhereUniqueInput
  }

  /**
   * counterparty_master_joint updateMany
   */
  export type counterparty_master_jointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counterparty_master_joints.
     */
    data: XOR<counterparty_master_jointUpdateManyMutationInput, counterparty_master_jointUncheckedUpdateManyInput>
    /**
     * Filter which counterparty_master_joints to update
     */
    where?: counterparty_master_jointWhereInput
    /**
     * Limit how many counterparty_master_joints to update.
     */
    limit?: number
  }

  /**
   * counterparty_master_joint upsert
   */
  export type counterparty_master_jointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * The filter to search for the counterparty_master_joint to update in case it exists.
     */
    where: counterparty_master_jointWhereUniqueInput
    /**
     * In case the counterparty_master_joint found by the `where` argument doesn't exist, create a new counterparty_master_joint with this data.
     */
    create: XOR<counterparty_master_jointCreateInput, counterparty_master_jointUncheckedCreateInput>
    /**
     * In case the counterparty_master_joint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counterparty_master_jointUpdateInput, counterparty_master_jointUncheckedUpdateInput>
  }

  /**
   * counterparty_master_joint delete
   */
  export type counterparty_master_jointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
    /**
     * Filter which counterparty_master_joint to delete.
     */
    where: counterparty_master_jointWhereUniqueInput
  }

  /**
   * counterparty_master_joint deleteMany
   */
  export type counterparty_master_jointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counterparty_master_joints to delete
     */
    where?: counterparty_master_jointWhereInput
    /**
     * Limit how many counterparty_master_joints to delete.
     */
    limit?: number
  }

  /**
   * counterparty_master_joint without action
   */
  export type counterparty_master_jointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counterparty_master_joint
     */
    select?: counterparty_master_jointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counterparty_master_joint
     */
    omit?: counterparty_master_jointOmit<ExtArgs> | null
  }


  /**
   * Model gsec
   */

  export type AggregateGsec = {
    _count: GsecCountAggregateOutputType | null
    _avg: GsecAvgAggregateOutputType | null
    _sum: GsecSumAggregateOutputType | null
    _min: GsecMinAggregateOutputType | null
    _max: GsecMaxAggregateOutputType | null
  }

  export type GsecAvgAggregateOutputType = {
    id: number | null
    face_value: Decimal | null
    number_of_days_interest_accrued: number | null
    number_of_days_for_coupon_period: number | null
    accrued_interest: Decimal | null
    coupon_interest: Decimal | null
    clean_price: Decimal | null
    dirty_price: Decimal | null
    accrued_interest_calculation: Decimal | null
    accrued_interest_six_decimals: Decimal | null
    accrued_interest_for_100: Decimal | null
    settlement_amount: Decimal | null
    yield: Decimal | null
    created_by: number | null
    updated_by: number | null
    authorized_by: number | null
    brokerage: Decimal | null
  }

  export type GsecSumAggregateOutputType = {
    id: number | null
    face_value: Decimal | null
    number_of_days_interest_accrued: number | null
    number_of_days_for_coupon_period: number | null
    accrued_interest: Decimal | null
    coupon_interest: Decimal | null
    clean_price: Decimal | null
    dirty_price: Decimal | null
    accrued_interest_calculation: Decimal | null
    accrued_interest_six_decimals: Decimal | null
    accrued_interest_for_100: Decimal | null
    settlement_amount: Decimal | null
    yield: Decimal | null
    created_by: number | null
    updated_by: number | null
    authorized_by: number | null
    brokerage: Decimal | null
  }

  export type GsecMinAggregateOutputType = {
    id: number | null
    trade_type: string | null
    transaction_type: string | null
    counterparty: string | null
    deal_number: string | null
    isin: string | null
    face_value: Decimal | null
    value_date: Date | null
    next_coupon_date: Date | null
    last_coupon_date: Date | null
    number_of_days_interest_accrued: number | null
    number_of_days_for_coupon_period: number | null
    accrued_interest: Decimal | null
    coupon_interest: Decimal | null
    clean_price: Decimal | null
    dirty_price: Decimal | null
    accrued_interest_calculation: Decimal | null
    accrued_interest_six_decimals: Decimal | null
    accrued_interest_for_100: Decimal | null
    settlement_amount: Decimal | null
    settlement_mode: string | null
    issue_date: Date | null
    maturity_date: Date | null
    coupon_dates: string | null
    yield: Decimal | null
    portfolio: string | null
    clean_price_adjustment: string | null
    accrued_interest_adjustment: string | null
    broker: string | null
    strategy: string | null
    status: string | null
    comment: string | null
    created_by: number | null
    stratergy: string | null
    created_at: Date | null
    updated_by: number | null
    updated_at: Date | null
    authorized_by: number | null
    authorized_at: Date | null
    brokerage: Decimal | null
    currency: string | null
  }

  export type GsecMaxAggregateOutputType = {
    id: number | null
    trade_type: string | null
    transaction_type: string | null
    counterparty: string | null
    deal_number: string | null
    isin: string | null
    face_value: Decimal | null
    value_date: Date | null
    next_coupon_date: Date | null
    last_coupon_date: Date | null
    number_of_days_interest_accrued: number | null
    number_of_days_for_coupon_period: number | null
    accrued_interest: Decimal | null
    coupon_interest: Decimal | null
    clean_price: Decimal | null
    dirty_price: Decimal | null
    accrued_interest_calculation: Decimal | null
    accrued_interest_six_decimals: Decimal | null
    accrued_interest_for_100: Decimal | null
    settlement_amount: Decimal | null
    settlement_mode: string | null
    issue_date: Date | null
    maturity_date: Date | null
    coupon_dates: string | null
    yield: Decimal | null
    portfolio: string | null
    clean_price_adjustment: string | null
    accrued_interest_adjustment: string | null
    broker: string | null
    strategy: string | null
    status: string | null
    comment: string | null
    created_by: number | null
    stratergy: string | null
    created_at: Date | null
    updated_by: number | null
    updated_at: Date | null
    authorized_by: number | null
    authorized_at: Date | null
    brokerage: Decimal | null
    currency: string | null
  }

  export type GsecCountAggregateOutputType = {
    id: number
    trade_type: number
    transaction_type: number
    counterparty: number
    deal_number: number
    isin: number
    face_value: number
    value_date: number
    next_coupon_date: number
    last_coupon_date: number
    number_of_days_interest_accrued: number
    number_of_days_for_coupon_period: number
    accrued_interest: number
    coupon_interest: number
    clean_price: number
    dirty_price: number
    accrued_interest_calculation: number
    accrued_interest_six_decimals: number
    accrued_interest_for_100: number
    settlement_amount: number
    settlement_mode: number
    issue_date: number
    maturity_date: number
    coupon_dates: number
    yield: number
    portfolio: number
    clean_price_adjustment: number
    accrued_interest_adjustment: number
    broker: number
    strategy: number
    status: number
    comment: number
    created_by: number
    stratergy: number
    created_at: number
    updated_by: number
    updated_at: number
    authorized_by: number
    authorized_at: number
    brokerage: number
    currency: number
    _all: number
  }


  export type GsecAvgAggregateInputType = {
    id?: true
    face_value?: true
    number_of_days_interest_accrued?: true
    number_of_days_for_coupon_period?: true
    accrued_interest?: true
    coupon_interest?: true
    clean_price?: true
    dirty_price?: true
    accrued_interest_calculation?: true
    accrued_interest_six_decimals?: true
    accrued_interest_for_100?: true
    settlement_amount?: true
    yield?: true
    created_by?: true
    updated_by?: true
    authorized_by?: true
    brokerage?: true
  }

  export type GsecSumAggregateInputType = {
    id?: true
    face_value?: true
    number_of_days_interest_accrued?: true
    number_of_days_for_coupon_period?: true
    accrued_interest?: true
    coupon_interest?: true
    clean_price?: true
    dirty_price?: true
    accrued_interest_calculation?: true
    accrued_interest_six_decimals?: true
    accrued_interest_for_100?: true
    settlement_amount?: true
    yield?: true
    created_by?: true
    updated_by?: true
    authorized_by?: true
    brokerage?: true
  }

  export type GsecMinAggregateInputType = {
    id?: true
    trade_type?: true
    transaction_type?: true
    counterparty?: true
    deal_number?: true
    isin?: true
    face_value?: true
    value_date?: true
    next_coupon_date?: true
    last_coupon_date?: true
    number_of_days_interest_accrued?: true
    number_of_days_for_coupon_period?: true
    accrued_interest?: true
    coupon_interest?: true
    clean_price?: true
    dirty_price?: true
    accrued_interest_calculation?: true
    accrued_interest_six_decimals?: true
    accrued_interest_for_100?: true
    settlement_amount?: true
    settlement_mode?: true
    issue_date?: true
    maturity_date?: true
    coupon_dates?: true
    yield?: true
    portfolio?: true
    clean_price_adjustment?: true
    accrued_interest_adjustment?: true
    broker?: true
    strategy?: true
    status?: true
    comment?: true
    created_by?: true
    stratergy?: true
    created_at?: true
    updated_by?: true
    updated_at?: true
    authorized_by?: true
    authorized_at?: true
    brokerage?: true
    currency?: true
  }

  export type GsecMaxAggregateInputType = {
    id?: true
    trade_type?: true
    transaction_type?: true
    counterparty?: true
    deal_number?: true
    isin?: true
    face_value?: true
    value_date?: true
    next_coupon_date?: true
    last_coupon_date?: true
    number_of_days_interest_accrued?: true
    number_of_days_for_coupon_period?: true
    accrued_interest?: true
    coupon_interest?: true
    clean_price?: true
    dirty_price?: true
    accrued_interest_calculation?: true
    accrued_interest_six_decimals?: true
    accrued_interest_for_100?: true
    settlement_amount?: true
    settlement_mode?: true
    issue_date?: true
    maturity_date?: true
    coupon_dates?: true
    yield?: true
    portfolio?: true
    clean_price_adjustment?: true
    accrued_interest_adjustment?: true
    broker?: true
    strategy?: true
    status?: true
    comment?: true
    created_by?: true
    stratergy?: true
    created_at?: true
    updated_by?: true
    updated_at?: true
    authorized_by?: true
    authorized_at?: true
    brokerage?: true
    currency?: true
  }

  export type GsecCountAggregateInputType = {
    id?: true
    trade_type?: true
    transaction_type?: true
    counterparty?: true
    deal_number?: true
    isin?: true
    face_value?: true
    value_date?: true
    next_coupon_date?: true
    last_coupon_date?: true
    number_of_days_interest_accrued?: true
    number_of_days_for_coupon_period?: true
    accrued_interest?: true
    coupon_interest?: true
    clean_price?: true
    dirty_price?: true
    accrued_interest_calculation?: true
    accrued_interest_six_decimals?: true
    accrued_interest_for_100?: true
    settlement_amount?: true
    settlement_mode?: true
    issue_date?: true
    maturity_date?: true
    coupon_dates?: true
    yield?: true
    portfolio?: true
    clean_price_adjustment?: true
    accrued_interest_adjustment?: true
    broker?: true
    strategy?: true
    status?: true
    comment?: true
    created_by?: true
    stratergy?: true
    created_at?: true
    updated_by?: true
    updated_at?: true
    authorized_by?: true
    authorized_at?: true
    brokerage?: true
    currency?: true
    _all?: true
  }

  export type GsecAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gsec to aggregate.
     */
    where?: gsecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gsecs to fetch.
     */
    orderBy?: gsecOrderByWithRelationInput | gsecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gsecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gsecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gsecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gsecs
    **/
    _count?: true | GsecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GsecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GsecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GsecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GsecMaxAggregateInputType
  }

  export type GetGsecAggregateType<T extends GsecAggregateArgs> = {
        [P in keyof T & keyof AggregateGsec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGsec[P]>
      : GetScalarType<T[P], AggregateGsec[P]>
  }




  export type gsecGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gsecWhereInput
    orderBy?: gsecOrderByWithAggregationInput | gsecOrderByWithAggregationInput[]
    by: GsecScalarFieldEnum[] | GsecScalarFieldEnum
    having?: gsecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GsecCountAggregateInputType | true
    _avg?: GsecAvgAggregateInputType
    _sum?: GsecSumAggregateInputType
    _min?: GsecMinAggregateInputType
    _max?: GsecMaxAggregateInputType
  }

  export type GsecGroupByOutputType = {
    id: number
    trade_type: string | null
    transaction_type: string | null
    counterparty: string | null
    deal_number: string | null
    isin: string | null
    face_value: Decimal | null
    value_date: Date | null
    next_coupon_date: Date | null
    last_coupon_date: Date | null
    number_of_days_interest_accrued: number | null
    number_of_days_for_coupon_period: number | null
    accrued_interest: Decimal | null
    coupon_interest: Decimal | null
    clean_price: Decimal | null
    dirty_price: Decimal | null
    accrued_interest_calculation: Decimal | null
    accrued_interest_six_decimals: Decimal | null
    accrued_interest_for_100: Decimal | null
    settlement_amount: Decimal | null
    settlement_mode: string | null
    issue_date: Date | null
    maturity_date: Date | null
    coupon_dates: string | null
    yield: Decimal | null
    portfolio: string | null
    clean_price_adjustment: string | null
    accrued_interest_adjustment: string | null
    broker: string | null
    strategy: string | null
    status: string | null
    comment: string | null
    created_by: number | null
    stratergy: string | null
    created_at: Date | null
    updated_by: number | null
    updated_at: Date | null
    authorized_by: number | null
    authorized_at: Date | null
    brokerage: Decimal | null
    currency: string
    _count: GsecCountAggregateOutputType | null
    _avg: GsecAvgAggregateOutputType | null
    _sum: GsecSumAggregateOutputType | null
    _min: GsecMinAggregateOutputType | null
    _max: GsecMaxAggregateOutputType | null
  }

  type GetGsecGroupByPayload<T extends gsecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GsecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GsecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GsecGroupByOutputType[P]>
            : GetScalarType<T[P], GsecGroupByOutputType[P]>
        }
      >
    >


  export type gsecSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trade_type?: boolean
    transaction_type?: boolean
    counterparty?: boolean
    deal_number?: boolean
    isin?: boolean
    face_value?: boolean
    value_date?: boolean
    next_coupon_date?: boolean
    last_coupon_date?: boolean
    number_of_days_interest_accrued?: boolean
    number_of_days_for_coupon_period?: boolean
    accrued_interest?: boolean
    coupon_interest?: boolean
    clean_price?: boolean
    dirty_price?: boolean
    accrued_interest_calculation?: boolean
    accrued_interest_six_decimals?: boolean
    accrued_interest_for_100?: boolean
    settlement_amount?: boolean
    settlement_mode?: boolean
    issue_date?: boolean
    maturity_date?: boolean
    coupon_dates?: boolean
    yield?: boolean
    portfolio?: boolean
    clean_price_adjustment?: boolean
    accrued_interest_adjustment?: boolean
    broker?: boolean
    strategy?: boolean
    status?: boolean
    comment?: boolean
    created_by?: boolean
    stratergy?: boolean
    created_at?: boolean
    updated_by?: boolean
    updated_at?: boolean
    authorized_by?: boolean
    authorized_at?: boolean
    brokerage?: boolean
    currency?: boolean
  }, ExtArgs["result"]["gsec"]>



  export type gsecSelectScalar = {
    id?: boolean
    trade_type?: boolean
    transaction_type?: boolean
    counterparty?: boolean
    deal_number?: boolean
    isin?: boolean
    face_value?: boolean
    value_date?: boolean
    next_coupon_date?: boolean
    last_coupon_date?: boolean
    number_of_days_interest_accrued?: boolean
    number_of_days_for_coupon_period?: boolean
    accrued_interest?: boolean
    coupon_interest?: boolean
    clean_price?: boolean
    dirty_price?: boolean
    accrued_interest_calculation?: boolean
    accrued_interest_six_decimals?: boolean
    accrued_interest_for_100?: boolean
    settlement_amount?: boolean
    settlement_mode?: boolean
    issue_date?: boolean
    maturity_date?: boolean
    coupon_dates?: boolean
    yield?: boolean
    portfolio?: boolean
    clean_price_adjustment?: boolean
    accrued_interest_adjustment?: boolean
    broker?: boolean
    strategy?: boolean
    status?: boolean
    comment?: boolean
    created_by?: boolean
    stratergy?: boolean
    created_at?: boolean
    updated_by?: boolean
    updated_at?: boolean
    authorized_by?: boolean
    authorized_at?: boolean
    brokerage?: boolean
    currency?: boolean
  }

  export type gsecOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trade_type" | "transaction_type" | "counterparty" | "deal_number" | "isin" | "face_value" | "value_date" | "next_coupon_date" | "last_coupon_date" | "number_of_days_interest_accrued" | "number_of_days_for_coupon_period" | "accrued_interest" | "coupon_interest" | "clean_price" | "dirty_price" | "accrued_interest_calculation" | "accrued_interest_six_decimals" | "accrued_interest_for_100" | "settlement_amount" | "settlement_mode" | "issue_date" | "maturity_date" | "coupon_dates" | "yield" | "portfolio" | "clean_price_adjustment" | "accrued_interest_adjustment" | "broker" | "strategy" | "status" | "comment" | "created_by" | "stratergy" | "created_at" | "updated_by" | "updated_at" | "authorized_by" | "authorized_at" | "brokerage" | "currency", ExtArgs["result"]["gsec"]>

  export type $gsecPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gsec"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      trade_type: string | null
      transaction_type: string | null
      counterparty: string | null
      deal_number: string | null
      isin: string | null
      face_value: Prisma.Decimal | null
      value_date: Date | null
      next_coupon_date: Date | null
      last_coupon_date: Date | null
      number_of_days_interest_accrued: number | null
      number_of_days_for_coupon_period: number | null
      accrued_interest: Prisma.Decimal | null
      coupon_interest: Prisma.Decimal | null
      clean_price: Prisma.Decimal | null
      dirty_price: Prisma.Decimal | null
      accrued_interest_calculation: Prisma.Decimal | null
      accrued_interest_six_decimals: Prisma.Decimal | null
      accrued_interest_for_100: Prisma.Decimal | null
      settlement_amount: Prisma.Decimal | null
      settlement_mode: string | null
      issue_date: Date | null
      maturity_date: Date | null
      coupon_dates: string | null
      yield: Prisma.Decimal | null
      portfolio: string | null
      clean_price_adjustment: string | null
      accrued_interest_adjustment: string | null
      broker: string | null
      strategy: string | null
      status: string | null
      comment: string | null
      created_by: number | null
      stratergy: string | null
      created_at: Date | null
      updated_by: number | null
      updated_at: Date | null
      authorized_by: number | null
      authorized_at: Date | null
      brokerage: Prisma.Decimal | null
      currency: string
    }, ExtArgs["result"]["gsec"]>
    composites: {}
  }

  type gsecGetPayload<S extends boolean | null | undefined | gsecDefaultArgs> = $Result.GetResult<Prisma.$gsecPayload, S>

  type gsecCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gsecFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GsecCountAggregateInputType | true
    }

  export interface gsecDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gsec'], meta: { name: 'gsec' } }
    /**
     * Find zero or one Gsec that matches the filter.
     * @param {gsecFindUniqueArgs} args - Arguments to find a Gsec
     * @example
     * // Get one Gsec
     * const gsec = await prisma.gsec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gsecFindUniqueArgs>(args: SelectSubset<T, gsecFindUniqueArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gsec that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gsecFindUniqueOrThrowArgs} args - Arguments to find a Gsec
     * @example
     * // Get one Gsec
     * const gsec = await prisma.gsec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gsecFindUniqueOrThrowArgs>(args: SelectSubset<T, gsecFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gsec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gsecFindFirstArgs} args - Arguments to find a Gsec
     * @example
     * // Get one Gsec
     * const gsec = await prisma.gsec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gsecFindFirstArgs>(args?: SelectSubset<T, gsecFindFirstArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gsec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gsecFindFirstOrThrowArgs} args - Arguments to find a Gsec
     * @example
     * // Get one Gsec
     * const gsec = await prisma.gsec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gsecFindFirstOrThrowArgs>(args?: SelectSubset<T, gsecFindFirstOrThrowArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gsecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gsecFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gsecs
     * const gsecs = await prisma.gsec.findMany()
     * 
     * // Get first 10 Gsecs
     * const gsecs = await prisma.gsec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gsecWithIdOnly = await prisma.gsec.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gsecFindManyArgs>(args?: SelectSubset<T, gsecFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gsec.
     * @param {gsecCreateArgs} args - Arguments to create a Gsec.
     * @example
     * // Create one Gsec
     * const Gsec = await prisma.gsec.create({
     *   data: {
     *     // ... data to create a Gsec
     *   }
     * })
     * 
     */
    create<T extends gsecCreateArgs>(args: SelectSubset<T, gsecCreateArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gsecs.
     * @param {gsecCreateManyArgs} args - Arguments to create many Gsecs.
     * @example
     * // Create many Gsecs
     * const gsec = await prisma.gsec.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gsecCreateManyArgs>(args?: SelectSubset<T, gsecCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gsec.
     * @param {gsecDeleteArgs} args - Arguments to delete one Gsec.
     * @example
     * // Delete one Gsec
     * const Gsec = await prisma.gsec.delete({
     *   where: {
     *     // ... filter to delete one Gsec
     *   }
     * })
     * 
     */
    delete<T extends gsecDeleteArgs>(args: SelectSubset<T, gsecDeleteArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gsec.
     * @param {gsecUpdateArgs} args - Arguments to update one Gsec.
     * @example
     * // Update one Gsec
     * const gsec = await prisma.gsec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gsecUpdateArgs>(args: SelectSubset<T, gsecUpdateArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gsecs.
     * @param {gsecDeleteManyArgs} args - Arguments to filter Gsecs to delete.
     * @example
     * // Delete a few Gsecs
     * const { count } = await prisma.gsec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gsecDeleteManyArgs>(args?: SelectSubset<T, gsecDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gsecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gsecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gsecs
     * const gsec = await prisma.gsec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gsecUpdateManyArgs>(args: SelectSubset<T, gsecUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gsec.
     * @param {gsecUpsertArgs} args - Arguments to update or create a Gsec.
     * @example
     * // Update or create a Gsec
     * const gsec = await prisma.gsec.upsert({
     *   create: {
     *     // ... data to create a Gsec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gsec we want to update
     *   }
     * })
     */
    upsert<T extends gsecUpsertArgs>(args: SelectSubset<T, gsecUpsertArgs<ExtArgs>>): Prisma__gsecClient<$Result.GetResult<Prisma.$gsecPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gsecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gsecCountArgs} args - Arguments to filter Gsecs to count.
     * @example
     * // Count the number of Gsecs
     * const count = await prisma.gsec.count({
     *   where: {
     *     // ... the filter for the Gsecs we want to count
     *   }
     * })
    **/
    count<T extends gsecCountArgs>(
      args?: Subset<T, gsecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GsecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gsec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GsecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GsecAggregateArgs>(args: Subset<T, GsecAggregateArgs>): Prisma.PrismaPromise<GetGsecAggregateType<T>>

    /**
     * Group by Gsec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gsecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gsecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gsecGroupByArgs['orderBy'] }
        : { orderBy?: gsecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gsecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGsecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gsec model
   */
  readonly fields: gsecFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gsec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gsecClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gsec model
   */
  interface gsecFieldRefs {
    readonly id: FieldRef<"gsec", 'Int'>
    readonly trade_type: FieldRef<"gsec", 'String'>
    readonly transaction_type: FieldRef<"gsec", 'String'>
    readonly counterparty: FieldRef<"gsec", 'String'>
    readonly deal_number: FieldRef<"gsec", 'String'>
    readonly isin: FieldRef<"gsec", 'String'>
    readonly face_value: FieldRef<"gsec", 'Decimal'>
    readonly value_date: FieldRef<"gsec", 'DateTime'>
    readonly next_coupon_date: FieldRef<"gsec", 'DateTime'>
    readonly last_coupon_date: FieldRef<"gsec", 'DateTime'>
    readonly number_of_days_interest_accrued: FieldRef<"gsec", 'Int'>
    readonly number_of_days_for_coupon_period: FieldRef<"gsec", 'Int'>
    readonly accrued_interest: FieldRef<"gsec", 'Decimal'>
    readonly coupon_interest: FieldRef<"gsec", 'Decimal'>
    readonly clean_price: FieldRef<"gsec", 'Decimal'>
    readonly dirty_price: FieldRef<"gsec", 'Decimal'>
    readonly accrued_interest_calculation: FieldRef<"gsec", 'Decimal'>
    readonly accrued_interest_six_decimals: FieldRef<"gsec", 'Decimal'>
    readonly accrued_interest_for_100: FieldRef<"gsec", 'Decimal'>
    readonly settlement_amount: FieldRef<"gsec", 'Decimal'>
    readonly settlement_mode: FieldRef<"gsec", 'String'>
    readonly issue_date: FieldRef<"gsec", 'DateTime'>
    readonly maturity_date: FieldRef<"gsec", 'DateTime'>
    readonly coupon_dates: FieldRef<"gsec", 'String'>
    readonly yield: FieldRef<"gsec", 'Decimal'>
    readonly portfolio: FieldRef<"gsec", 'String'>
    readonly clean_price_adjustment: FieldRef<"gsec", 'String'>
    readonly accrued_interest_adjustment: FieldRef<"gsec", 'String'>
    readonly broker: FieldRef<"gsec", 'String'>
    readonly strategy: FieldRef<"gsec", 'String'>
    readonly status: FieldRef<"gsec", 'String'>
    readonly comment: FieldRef<"gsec", 'String'>
    readonly created_by: FieldRef<"gsec", 'Int'>
    readonly stratergy: FieldRef<"gsec", 'String'>
    readonly created_at: FieldRef<"gsec", 'DateTime'>
    readonly updated_by: FieldRef<"gsec", 'Int'>
    readonly updated_at: FieldRef<"gsec", 'DateTime'>
    readonly authorized_by: FieldRef<"gsec", 'Int'>
    readonly authorized_at: FieldRef<"gsec", 'DateTime'>
    readonly brokerage: FieldRef<"gsec", 'Decimal'>
    readonly currency: FieldRef<"gsec", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gsec findUnique
   */
  export type gsecFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * Filter, which gsec to fetch.
     */
    where: gsecWhereUniqueInput
  }

  /**
   * gsec findUniqueOrThrow
   */
  export type gsecFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * Filter, which gsec to fetch.
     */
    where: gsecWhereUniqueInput
  }

  /**
   * gsec findFirst
   */
  export type gsecFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * Filter, which gsec to fetch.
     */
    where?: gsecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gsecs to fetch.
     */
    orderBy?: gsecOrderByWithRelationInput | gsecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gsecs.
     */
    cursor?: gsecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gsecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gsecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gsecs.
     */
    distinct?: GsecScalarFieldEnum | GsecScalarFieldEnum[]
  }

  /**
   * gsec findFirstOrThrow
   */
  export type gsecFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * Filter, which gsec to fetch.
     */
    where?: gsecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gsecs to fetch.
     */
    orderBy?: gsecOrderByWithRelationInput | gsecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gsecs.
     */
    cursor?: gsecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gsecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gsecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gsecs.
     */
    distinct?: GsecScalarFieldEnum | GsecScalarFieldEnum[]
  }

  /**
   * gsec findMany
   */
  export type gsecFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * Filter, which gsecs to fetch.
     */
    where?: gsecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gsecs to fetch.
     */
    orderBy?: gsecOrderByWithRelationInput | gsecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gsecs.
     */
    cursor?: gsecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gsecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gsecs.
     */
    skip?: number
    distinct?: GsecScalarFieldEnum | GsecScalarFieldEnum[]
  }

  /**
   * gsec create
   */
  export type gsecCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * The data needed to create a gsec.
     */
    data?: XOR<gsecCreateInput, gsecUncheckedCreateInput>
  }

  /**
   * gsec createMany
   */
  export type gsecCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gsecs.
     */
    data: gsecCreateManyInput | gsecCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gsec update
   */
  export type gsecUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * The data needed to update a gsec.
     */
    data: XOR<gsecUpdateInput, gsecUncheckedUpdateInput>
    /**
     * Choose, which gsec to update.
     */
    where: gsecWhereUniqueInput
  }

  /**
   * gsec updateMany
   */
  export type gsecUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gsecs.
     */
    data: XOR<gsecUpdateManyMutationInput, gsecUncheckedUpdateManyInput>
    /**
     * Filter which gsecs to update
     */
    where?: gsecWhereInput
    /**
     * Limit how many gsecs to update.
     */
    limit?: number
  }

  /**
   * gsec upsert
   */
  export type gsecUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * The filter to search for the gsec to update in case it exists.
     */
    where: gsecWhereUniqueInput
    /**
     * In case the gsec found by the `where` argument doesn't exist, create a new gsec with this data.
     */
    create: XOR<gsecCreateInput, gsecUncheckedCreateInput>
    /**
     * In case the gsec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gsecUpdateInput, gsecUncheckedUpdateInput>
  }

  /**
   * gsec delete
   */
  export type gsecDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
    /**
     * Filter which gsec to delete.
     */
    where: gsecWhereUniqueInput
  }

  /**
   * gsec deleteMany
   */
  export type gsecDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gsecs to delete
     */
    where?: gsecWhereInput
    /**
     * Limit how many gsecs to delete.
     */
    limit?: number
  }

  /**
   * gsec without action
   */
  export type gsecDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gsec
     */
    select?: gsecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gsec
     */
    omit?: gsecOmit<ExtArgs> | null
  }


  /**
   * Model isin_coupon_schedule
   */

  export type AggregateIsin_coupon_schedule = {
    _count: Isin_coupon_scheduleCountAggregateOutputType | null
    _avg: Isin_coupon_scheduleAvgAggregateOutputType | null
    _sum: Isin_coupon_scheduleSumAggregateOutputType | null
    _min: Isin_coupon_scheduleMinAggregateOutputType | null
    _max: Isin_coupon_scheduleMaxAggregateOutputType | null
  }

  export type Isin_coupon_scheduleAvgAggregateOutputType = {
    id: number | null
    coupon_number: number | null
    coupon_amount: Decimal | null
    principal: Decimal | null
  }

  export type Isin_coupon_scheduleSumAggregateOutputType = {
    id: number | null
    coupon_number: number | null
    coupon_amount: Decimal | null
    principal: Decimal | null
  }

  export type Isin_coupon_scheduleMinAggregateOutputType = {
    id: number | null
    isin: string | null
    coupon_number: number | null
    coupon_date: Date | null
    coupon_amount: Decimal | null
    principal: Decimal | null
  }

  export type Isin_coupon_scheduleMaxAggregateOutputType = {
    id: number | null
    isin: string | null
    coupon_number: number | null
    coupon_date: Date | null
    coupon_amount: Decimal | null
    principal: Decimal | null
  }

  export type Isin_coupon_scheduleCountAggregateOutputType = {
    id: number
    isin: number
    coupon_number: number
    coupon_date: number
    coupon_amount: number
    principal: number
    _all: number
  }


  export type Isin_coupon_scheduleAvgAggregateInputType = {
    id?: true
    coupon_number?: true
    coupon_amount?: true
    principal?: true
  }

  export type Isin_coupon_scheduleSumAggregateInputType = {
    id?: true
    coupon_number?: true
    coupon_amount?: true
    principal?: true
  }

  export type Isin_coupon_scheduleMinAggregateInputType = {
    id?: true
    isin?: true
    coupon_number?: true
    coupon_date?: true
    coupon_amount?: true
    principal?: true
  }

  export type Isin_coupon_scheduleMaxAggregateInputType = {
    id?: true
    isin?: true
    coupon_number?: true
    coupon_date?: true
    coupon_amount?: true
    principal?: true
  }

  export type Isin_coupon_scheduleCountAggregateInputType = {
    id?: true
    isin?: true
    coupon_number?: true
    coupon_date?: true
    coupon_amount?: true
    principal?: true
    _all?: true
  }

  export type Isin_coupon_scheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which isin_coupon_schedule to aggregate.
     */
    where?: isin_coupon_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_coupon_schedules to fetch.
     */
    orderBy?: isin_coupon_scheduleOrderByWithRelationInput | isin_coupon_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: isin_coupon_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_coupon_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_coupon_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned isin_coupon_schedules
    **/
    _count?: true | Isin_coupon_scheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Isin_coupon_scheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Isin_coupon_scheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Isin_coupon_scheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Isin_coupon_scheduleMaxAggregateInputType
  }

  export type GetIsin_coupon_scheduleAggregateType<T extends Isin_coupon_scheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateIsin_coupon_schedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIsin_coupon_schedule[P]>
      : GetScalarType<T[P], AggregateIsin_coupon_schedule[P]>
  }




  export type isin_coupon_scheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: isin_coupon_scheduleWhereInput
    orderBy?: isin_coupon_scheduleOrderByWithAggregationInput | isin_coupon_scheduleOrderByWithAggregationInput[]
    by: Isin_coupon_scheduleScalarFieldEnum[] | Isin_coupon_scheduleScalarFieldEnum
    having?: isin_coupon_scheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Isin_coupon_scheduleCountAggregateInputType | true
    _avg?: Isin_coupon_scheduleAvgAggregateInputType
    _sum?: Isin_coupon_scheduleSumAggregateInputType
    _min?: Isin_coupon_scheduleMinAggregateInputType
    _max?: Isin_coupon_scheduleMaxAggregateInputType
  }

  export type Isin_coupon_scheduleGroupByOutputType = {
    id: number
    isin: string
    coupon_number: number
    coupon_date: Date
    coupon_amount: Decimal
    principal: Decimal | null
    _count: Isin_coupon_scheduleCountAggregateOutputType | null
    _avg: Isin_coupon_scheduleAvgAggregateOutputType | null
    _sum: Isin_coupon_scheduleSumAggregateOutputType | null
    _min: Isin_coupon_scheduleMinAggregateOutputType | null
    _max: Isin_coupon_scheduleMaxAggregateOutputType | null
  }

  type GetIsin_coupon_scheduleGroupByPayload<T extends isin_coupon_scheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Isin_coupon_scheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Isin_coupon_scheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Isin_coupon_scheduleGroupByOutputType[P]>
            : GetScalarType<T[P], Isin_coupon_scheduleGroupByOutputType[P]>
        }
      >
    >


  export type isin_coupon_scheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isin?: boolean
    coupon_number?: boolean
    coupon_date?: boolean
    coupon_amount?: boolean
    principal?: boolean
    isin_master?: boolean | isin_masterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["isin_coupon_schedule"]>



  export type isin_coupon_scheduleSelectScalar = {
    id?: boolean
    isin?: boolean
    coupon_number?: boolean
    coupon_date?: boolean
    coupon_amount?: boolean
    principal?: boolean
  }

  export type isin_coupon_scheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isin" | "coupon_number" | "coupon_date" | "coupon_amount" | "principal", ExtArgs["result"]["isin_coupon_schedule"]>
  export type isin_coupon_scheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    isin_master?: boolean | isin_masterDefaultArgs<ExtArgs>
  }

  export type $isin_coupon_schedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "isin_coupon_schedule"
    objects: {
      isin_master: Prisma.$isin_masterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isin: string
      coupon_number: number
      coupon_date: Date
      coupon_amount: Prisma.Decimal
      principal: Prisma.Decimal | null
    }, ExtArgs["result"]["isin_coupon_schedule"]>
    composites: {}
  }

  type isin_coupon_scheduleGetPayload<S extends boolean | null | undefined | isin_coupon_scheduleDefaultArgs> = $Result.GetResult<Prisma.$isin_coupon_schedulePayload, S>

  type isin_coupon_scheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<isin_coupon_scheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Isin_coupon_scheduleCountAggregateInputType | true
    }

  export interface isin_coupon_scheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['isin_coupon_schedule'], meta: { name: 'isin_coupon_schedule' } }
    /**
     * Find zero or one Isin_coupon_schedule that matches the filter.
     * @param {isin_coupon_scheduleFindUniqueArgs} args - Arguments to find a Isin_coupon_schedule
     * @example
     * // Get one Isin_coupon_schedule
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends isin_coupon_scheduleFindUniqueArgs>(args: SelectSubset<T, isin_coupon_scheduleFindUniqueArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Isin_coupon_schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {isin_coupon_scheduleFindUniqueOrThrowArgs} args - Arguments to find a Isin_coupon_schedule
     * @example
     * // Get one Isin_coupon_schedule
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends isin_coupon_scheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, isin_coupon_scheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Isin_coupon_schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_coupon_scheduleFindFirstArgs} args - Arguments to find a Isin_coupon_schedule
     * @example
     * // Get one Isin_coupon_schedule
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends isin_coupon_scheduleFindFirstArgs>(args?: SelectSubset<T, isin_coupon_scheduleFindFirstArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Isin_coupon_schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_coupon_scheduleFindFirstOrThrowArgs} args - Arguments to find a Isin_coupon_schedule
     * @example
     * // Get one Isin_coupon_schedule
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends isin_coupon_scheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, isin_coupon_scheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Isin_coupon_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_coupon_scheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Isin_coupon_schedules
     * const isin_coupon_schedules = await prisma.isin_coupon_schedule.findMany()
     * 
     * // Get first 10 Isin_coupon_schedules
     * const isin_coupon_schedules = await prisma.isin_coupon_schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const isin_coupon_scheduleWithIdOnly = await prisma.isin_coupon_schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends isin_coupon_scheduleFindManyArgs>(args?: SelectSubset<T, isin_coupon_scheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Isin_coupon_schedule.
     * @param {isin_coupon_scheduleCreateArgs} args - Arguments to create a Isin_coupon_schedule.
     * @example
     * // Create one Isin_coupon_schedule
     * const Isin_coupon_schedule = await prisma.isin_coupon_schedule.create({
     *   data: {
     *     // ... data to create a Isin_coupon_schedule
     *   }
     * })
     * 
     */
    create<T extends isin_coupon_scheduleCreateArgs>(args: SelectSubset<T, isin_coupon_scheduleCreateArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Isin_coupon_schedules.
     * @param {isin_coupon_scheduleCreateManyArgs} args - Arguments to create many Isin_coupon_schedules.
     * @example
     * // Create many Isin_coupon_schedules
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends isin_coupon_scheduleCreateManyArgs>(args?: SelectSubset<T, isin_coupon_scheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Isin_coupon_schedule.
     * @param {isin_coupon_scheduleDeleteArgs} args - Arguments to delete one Isin_coupon_schedule.
     * @example
     * // Delete one Isin_coupon_schedule
     * const Isin_coupon_schedule = await prisma.isin_coupon_schedule.delete({
     *   where: {
     *     // ... filter to delete one Isin_coupon_schedule
     *   }
     * })
     * 
     */
    delete<T extends isin_coupon_scheduleDeleteArgs>(args: SelectSubset<T, isin_coupon_scheduleDeleteArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Isin_coupon_schedule.
     * @param {isin_coupon_scheduleUpdateArgs} args - Arguments to update one Isin_coupon_schedule.
     * @example
     * // Update one Isin_coupon_schedule
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends isin_coupon_scheduleUpdateArgs>(args: SelectSubset<T, isin_coupon_scheduleUpdateArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Isin_coupon_schedules.
     * @param {isin_coupon_scheduleDeleteManyArgs} args - Arguments to filter Isin_coupon_schedules to delete.
     * @example
     * // Delete a few Isin_coupon_schedules
     * const { count } = await prisma.isin_coupon_schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends isin_coupon_scheduleDeleteManyArgs>(args?: SelectSubset<T, isin_coupon_scheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Isin_coupon_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_coupon_scheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Isin_coupon_schedules
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends isin_coupon_scheduleUpdateManyArgs>(args: SelectSubset<T, isin_coupon_scheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Isin_coupon_schedule.
     * @param {isin_coupon_scheduleUpsertArgs} args - Arguments to update or create a Isin_coupon_schedule.
     * @example
     * // Update or create a Isin_coupon_schedule
     * const isin_coupon_schedule = await prisma.isin_coupon_schedule.upsert({
     *   create: {
     *     // ... data to create a Isin_coupon_schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Isin_coupon_schedule we want to update
     *   }
     * })
     */
    upsert<T extends isin_coupon_scheduleUpsertArgs>(args: SelectSubset<T, isin_coupon_scheduleUpsertArgs<ExtArgs>>): Prisma__isin_coupon_scheduleClient<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Isin_coupon_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_coupon_scheduleCountArgs} args - Arguments to filter Isin_coupon_schedules to count.
     * @example
     * // Count the number of Isin_coupon_schedules
     * const count = await prisma.isin_coupon_schedule.count({
     *   where: {
     *     // ... the filter for the Isin_coupon_schedules we want to count
     *   }
     * })
    **/
    count<T extends isin_coupon_scheduleCountArgs>(
      args?: Subset<T, isin_coupon_scheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Isin_coupon_scheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Isin_coupon_schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Isin_coupon_scheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Isin_coupon_scheduleAggregateArgs>(args: Subset<T, Isin_coupon_scheduleAggregateArgs>): Prisma.PrismaPromise<GetIsin_coupon_scheduleAggregateType<T>>

    /**
     * Group by Isin_coupon_schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_coupon_scheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends isin_coupon_scheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: isin_coupon_scheduleGroupByArgs['orderBy'] }
        : { orderBy?: isin_coupon_scheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, isin_coupon_scheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIsin_coupon_scheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the isin_coupon_schedule model
   */
  readonly fields: isin_coupon_scheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for isin_coupon_schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__isin_coupon_scheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    isin_master<T extends isin_masterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, isin_masterDefaultArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the isin_coupon_schedule model
   */
  interface isin_coupon_scheduleFieldRefs {
    readonly id: FieldRef<"isin_coupon_schedule", 'Int'>
    readonly isin: FieldRef<"isin_coupon_schedule", 'String'>
    readonly coupon_number: FieldRef<"isin_coupon_schedule", 'Int'>
    readonly coupon_date: FieldRef<"isin_coupon_schedule", 'DateTime'>
    readonly coupon_amount: FieldRef<"isin_coupon_schedule", 'Decimal'>
    readonly principal: FieldRef<"isin_coupon_schedule", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * isin_coupon_schedule findUnique
   */
  export type isin_coupon_scheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which isin_coupon_schedule to fetch.
     */
    where: isin_coupon_scheduleWhereUniqueInput
  }

  /**
   * isin_coupon_schedule findUniqueOrThrow
   */
  export type isin_coupon_scheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which isin_coupon_schedule to fetch.
     */
    where: isin_coupon_scheduleWhereUniqueInput
  }

  /**
   * isin_coupon_schedule findFirst
   */
  export type isin_coupon_scheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which isin_coupon_schedule to fetch.
     */
    where?: isin_coupon_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_coupon_schedules to fetch.
     */
    orderBy?: isin_coupon_scheduleOrderByWithRelationInput | isin_coupon_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for isin_coupon_schedules.
     */
    cursor?: isin_coupon_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_coupon_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_coupon_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of isin_coupon_schedules.
     */
    distinct?: Isin_coupon_scheduleScalarFieldEnum | Isin_coupon_scheduleScalarFieldEnum[]
  }

  /**
   * isin_coupon_schedule findFirstOrThrow
   */
  export type isin_coupon_scheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which isin_coupon_schedule to fetch.
     */
    where?: isin_coupon_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_coupon_schedules to fetch.
     */
    orderBy?: isin_coupon_scheduleOrderByWithRelationInput | isin_coupon_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for isin_coupon_schedules.
     */
    cursor?: isin_coupon_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_coupon_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_coupon_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of isin_coupon_schedules.
     */
    distinct?: Isin_coupon_scheduleScalarFieldEnum | Isin_coupon_scheduleScalarFieldEnum[]
  }

  /**
   * isin_coupon_schedule findMany
   */
  export type isin_coupon_scheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which isin_coupon_schedules to fetch.
     */
    where?: isin_coupon_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_coupon_schedules to fetch.
     */
    orderBy?: isin_coupon_scheduleOrderByWithRelationInput | isin_coupon_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing isin_coupon_schedules.
     */
    cursor?: isin_coupon_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_coupon_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_coupon_schedules.
     */
    skip?: number
    distinct?: Isin_coupon_scheduleScalarFieldEnum | Isin_coupon_scheduleScalarFieldEnum[]
  }

  /**
   * isin_coupon_schedule create
   */
  export type isin_coupon_scheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a isin_coupon_schedule.
     */
    data: XOR<isin_coupon_scheduleCreateInput, isin_coupon_scheduleUncheckedCreateInput>
  }

  /**
   * isin_coupon_schedule createMany
   */
  export type isin_coupon_scheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many isin_coupon_schedules.
     */
    data: isin_coupon_scheduleCreateManyInput | isin_coupon_scheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * isin_coupon_schedule update
   */
  export type isin_coupon_scheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a isin_coupon_schedule.
     */
    data: XOR<isin_coupon_scheduleUpdateInput, isin_coupon_scheduleUncheckedUpdateInput>
    /**
     * Choose, which isin_coupon_schedule to update.
     */
    where: isin_coupon_scheduleWhereUniqueInput
  }

  /**
   * isin_coupon_schedule updateMany
   */
  export type isin_coupon_scheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update isin_coupon_schedules.
     */
    data: XOR<isin_coupon_scheduleUpdateManyMutationInput, isin_coupon_scheduleUncheckedUpdateManyInput>
    /**
     * Filter which isin_coupon_schedules to update
     */
    where?: isin_coupon_scheduleWhereInput
    /**
     * Limit how many isin_coupon_schedules to update.
     */
    limit?: number
  }

  /**
   * isin_coupon_schedule upsert
   */
  export type isin_coupon_scheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the isin_coupon_schedule to update in case it exists.
     */
    where: isin_coupon_scheduleWhereUniqueInput
    /**
     * In case the isin_coupon_schedule found by the `where` argument doesn't exist, create a new isin_coupon_schedule with this data.
     */
    create: XOR<isin_coupon_scheduleCreateInput, isin_coupon_scheduleUncheckedCreateInput>
    /**
     * In case the isin_coupon_schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<isin_coupon_scheduleUpdateInput, isin_coupon_scheduleUncheckedUpdateInput>
  }

  /**
   * isin_coupon_schedule delete
   */
  export type isin_coupon_scheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    /**
     * Filter which isin_coupon_schedule to delete.
     */
    where: isin_coupon_scheduleWhereUniqueInput
  }

  /**
   * isin_coupon_schedule deleteMany
   */
  export type isin_coupon_scheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which isin_coupon_schedules to delete
     */
    where?: isin_coupon_scheduleWhereInput
    /**
     * Limit how many isin_coupon_schedules to delete.
     */
    limit?: number
  }

  /**
   * isin_coupon_schedule without action
   */
  export type isin_coupon_scheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
  }


  /**
   * Model isin_master
   */

  export type AggregateIsin_master = {
    _count: Isin_masterCountAggregateOutputType | null
    _avg: Isin_masterAvgAggregateOutputType | null
    _sum: Isin_masterSumAggregateOutputType | null
    _min: Isin_masterMinAggregateOutputType | null
    _max: Isin_masterMaxAggregateOutputType | null
  }

  export type Isin_masterAvgAggregateOutputType = {
    id: number | null
    coupon_rate: Decimal | null
    day_basis: number | null
  }

  export type Isin_masterSumAggregateOutputType = {
    id: number | null
    coupon_rate: Decimal | null
    day_basis: number | null
  }

  export type Isin_masterMinAggregateOutputType = {
    id: number | null
    isin_issuer: string | null
    isin_number: string | null
    issue_date: Date | null
    maturity_date: Date | null
    coupon_rate: Decimal | null
    series: string | null
    coupon_date_1: Date | null
    coupon_date_2: Date | null
    day_basis: number | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Isin_masterMaxAggregateOutputType = {
    id: number | null
    isin_issuer: string | null
    isin_number: string | null
    issue_date: Date | null
    maturity_date: Date | null
    coupon_rate: Decimal | null
    series: string | null
    coupon_date_1: Date | null
    coupon_date_2: Date | null
    day_basis: number | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Isin_masterCountAggregateOutputType = {
    id: number
    isin_issuer: number
    isin_number: number
    issue_date: number
    maturity_date: number
    coupon_rate: number
    series: number
    coupon_date_1: number
    coupon_date_2: number
    day_basis: number
    currency: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Isin_masterAvgAggregateInputType = {
    id?: true
    coupon_rate?: true
    day_basis?: true
  }

  export type Isin_masterSumAggregateInputType = {
    id?: true
    coupon_rate?: true
    day_basis?: true
  }

  export type Isin_masterMinAggregateInputType = {
    id?: true
    isin_issuer?: true
    isin_number?: true
    issue_date?: true
    maturity_date?: true
    coupon_rate?: true
    series?: true
    coupon_date_1?: true
    coupon_date_2?: true
    day_basis?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type Isin_masterMaxAggregateInputType = {
    id?: true
    isin_issuer?: true
    isin_number?: true
    issue_date?: true
    maturity_date?: true
    coupon_rate?: true
    series?: true
    coupon_date_1?: true
    coupon_date_2?: true
    day_basis?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type Isin_masterCountAggregateInputType = {
    id?: true
    isin_issuer?: true
    isin_number?: true
    issue_date?: true
    maturity_date?: true
    coupon_rate?: true
    series?: true
    coupon_date_1?: true
    coupon_date_2?: true
    day_basis?: true
    currency?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Isin_masterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which isin_master to aggregate.
     */
    where?: isin_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_masters to fetch.
     */
    orderBy?: isin_masterOrderByWithRelationInput | isin_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: isin_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned isin_masters
    **/
    _count?: true | Isin_masterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Isin_masterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Isin_masterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Isin_masterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Isin_masterMaxAggregateInputType
  }

  export type GetIsin_masterAggregateType<T extends Isin_masterAggregateArgs> = {
        [P in keyof T & keyof AggregateIsin_master]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIsin_master[P]>
      : GetScalarType<T[P], AggregateIsin_master[P]>
  }




  export type isin_masterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: isin_masterWhereInput
    orderBy?: isin_masterOrderByWithAggregationInput | isin_masterOrderByWithAggregationInput[]
    by: Isin_masterScalarFieldEnum[] | Isin_masterScalarFieldEnum
    having?: isin_masterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Isin_masterCountAggregateInputType | true
    _avg?: Isin_masterAvgAggregateInputType
    _sum?: Isin_masterSumAggregateInputType
    _min?: Isin_masterMinAggregateInputType
    _max?: Isin_masterMaxAggregateInputType
  }

  export type Isin_masterGroupByOutputType = {
    id: number
    isin_issuer: string
    isin_number: string
    issue_date: Date
    maturity_date: Date
    coupon_rate: Decimal
    series: string | null
    coupon_date_1: Date
    coupon_date_2: Date
    day_basis: number
    currency: string
    created_at: Date
    updated_at: Date
    _count: Isin_masterCountAggregateOutputType | null
    _avg: Isin_masterAvgAggregateOutputType | null
    _sum: Isin_masterSumAggregateOutputType | null
    _min: Isin_masterMinAggregateOutputType | null
    _max: Isin_masterMaxAggregateOutputType | null
  }

  type GetIsin_masterGroupByPayload<T extends isin_masterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Isin_masterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Isin_masterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Isin_masterGroupByOutputType[P]>
            : GetScalarType<T[P], Isin_masterGroupByOutputType[P]>
        }
      >
    >


  export type isin_masterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isin_issuer?: boolean
    isin_number?: boolean
    issue_date?: boolean
    maturity_date?: boolean
    coupon_rate?: boolean
    series?: boolean
    coupon_date_1?: boolean
    coupon_date_2?: boolean
    day_basis?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    isin_coupon_schedule?: boolean | isin_master$isin_coupon_scheduleArgs<ExtArgs>
    _count?: boolean | Isin_masterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["isin_master"]>



  export type isin_masterSelectScalar = {
    id?: boolean
    isin_issuer?: boolean
    isin_number?: boolean
    issue_date?: boolean
    maturity_date?: boolean
    coupon_rate?: boolean
    series?: boolean
    coupon_date_1?: boolean
    coupon_date_2?: boolean
    day_basis?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type isin_masterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isin_issuer" | "isin_number" | "issue_date" | "maturity_date" | "coupon_rate" | "series" | "coupon_date_1" | "coupon_date_2" | "day_basis" | "currency" | "created_at" | "updated_at", ExtArgs["result"]["isin_master"]>
  export type isin_masterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    isin_coupon_schedule?: boolean | isin_master$isin_coupon_scheduleArgs<ExtArgs>
    _count?: boolean | Isin_masterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $isin_masterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "isin_master"
    objects: {
      isin_coupon_schedule: Prisma.$isin_coupon_schedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isin_issuer: string
      isin_number: string
      issue_date: Date
      maturity_date: Date
      coupon_rate: Prisma.Decimal
      series: string | null
      coupon_date_1: Date
      coupon_date_2: Date
      day_basis: number
      currency: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["isin_master"]>
    composites: {}
  }

  type isin_masterGetPayload<S extends boolean | null | undefined | isin_masterDefaultArgs> = $Result.GetResult<Prisma.$isin_masterPayload, S>

  type isin_masterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<isin_masterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Isin_masterCountAggregateInputType | true
    }

  export interface isin_masterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['isin_master'], meta: { name: 'isin_master' } }
    /**
     * Find zero or one Isin_master that matches the filter.
     * @param {isin_masterFindUniqueArgs} args - Arguments to find a Isin_master
     * @example
     * // Get one Isin_master
     * const isin_master = await prisma.isin_master.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends isin_masterFindUniqueArgs>(args: SelectSubset<T, isin_masterFindUniqueArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Isin_master that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {isin_masterFindUniqueOrThrowArgs} args - Arguments to find a Isin_master
     * @example
     * // Get one Isin_master
     * const isin_master = await prisma.isin_master.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends isin_masterFindUniqueOrThrowArgs>(args: SelectSubset<T, isin_masterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Isin_master that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_masterFindFirstArgs} args - Arguments to find a Isin_master
     * @example
     * // Get one Isin_master
     * const isin_master = await prisma.isin_master.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends isin_masterFindFirstArgs>(args?: SelectSubset<T, isin_masterFindFirstArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Isin_master that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_masterFindFirstOrThrowArgs} args - Arguments to find a Isin_master
     * @example
     * // Get one Isin_master
     * const isin_master = await prisma.isin_master.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends isin_masterFindFirstOrThrowArgs>(args?: SelectSubset<T, isin_masterFindFirstOrThrowArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Isin_masters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_masterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Isin_masters
     * const isin_masters = await prisma.isin_master.findMany()
     * 
     * // Get first 10 Isin_masters
     * const isin_masters = await prisma.isin_master.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const isin_masterWithIdOnly = await prisma.isin_master.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends isin_masterFindManyArgs>(args?: SelectSubset<T, isin_masterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Isin_master.
     * @param {isin_masterCreateArgs} args - Arguments to create a Isin_master.
     * @example
     * // Create one Isin_master
     * const Isin_master = await prisma.isin_master.create({
     *   data: {
     *     // ... data to create a Isin_master
     *   }
     * })
     * 
     */
    create<T extends isin_masterCreateArgs>(args: SelectSubset<T, isin_masterCreateArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Isin_masters.
     * @param {isin_masterCreateManyArgs} args - Arguments to create many Isin_masters.
     * @example
     * // Create many Isin_masters
     * const isin_master = await prisma.isin_master.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends isin_masterCreateManyArgs>(args?: SelectSubset<T, isin_masterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Isin_master.
     * @param {isin_masterDeleteArgs} args - Arguments to delete one Isin_master.
     * @example
     * // Delete one Isin_master
     * const Isin_master = await prisma.isin_master.delete({
     *   where: {
     *     // ... filter to delete one Isin_master
     *   }
     * })
     * 
     */
    delete<T extends isin_masterDeleteArgs>(args: SelectSubset<T, isin_masterDeleteArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Isin_master.
     * @param {isin_masterUpdateArgs} args - Arguments to update one Isin_master.
     * @example
     * // Update one Isin_master
     * const isin_master = await prisma.isin_master.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends isin_masterUpdateArgs>(args: SelectSubset<T, isin_masterUpdateArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Isin_masters.
     * @param {isin_masterDeleteManyArgs} args - Arguments to filter Isin_masters to delete.
     * @example
     * // Delete a few Isin_masters
     * const { count } = await prisma.isin_master.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends isin_masterDeleteManyArgs>(args?: SelectSubset<T, isin_masterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Isin_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_masterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Isin_masters
     * const isin_master = await prisma.isin_master.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends isin_masterUpdateManyArgs>(args: SelectSubset<T, isin_masterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Isin_master.
     * @param {isin_masterUpsertArgs} args - Arguments to update or create a Isin_master.
     * @example
     * // Update or create a Isin_master
     * const isin_master = await prisma.isin_master.upsert({
     *   create: {
     *     // ... data to create a Isin_master
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Isin_master we want to update
     *   }
     * })
     */
    upsert<T extends isin_masterUpsertArgs>(args: SelectSubset<T, isin_masterUpsertArgs<ExtArgs>>): Prisma__isin_masterClient<$Result.GetResult<Prisma.$isin_masterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Isin_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_masterCountArgs} args - Arguments to filter Isin_masters to count.
     * @example
     * // Count the number of Isin_masters
     * const count = await prisma.isin_master.count({
     *   where: {
     *     // ... the filter for the Isin_masters we want to count
     *   }
     * })
    **/
    count<T extends isin_masterCountArgs>(
      args?: Subset<T, isin_masterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Isin_masterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Isin_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Isin_masterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Isin_masterAggregateArgs>(args: Subset<T, Isin_masterAggregateArgs>): Prisma.PrismaPromise<GetIsin_masterAggregateType<T>>

    /**
     * Group by Isin_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {isin_masterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends isin_masterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: isin_masterGroupByArgs['orderBy'] }
        : { orderBy?: isin_masterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, isin_masterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIsin_masterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the isin_master model
   */
  readonly fields: isin_masterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for isin_master.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__isin_masterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    isin_coupon_schedule<T extends isin_master$isin_coupon_scheduleArgs<ExtArgs> = {}>(args?: Subset<T, isin_master$isin_coupon_scheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$isin_coupon_schedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the isin_master model
   */
  interface isin_masterFieldRefs {
    readonly id: FieldRef<"isin_master", 'Int'>
    readonly isin_issuer: FieldRef<"isin_master", 'String'>
    readonly isin_number: FieldRef<"isin_master", 'String'>
    readonly issue_date: FieldRef<"isin_master", 'DateTime'>
    readonly maturity_date: FieldRef<"isin_master", 'DateTime'>
    readonly coupon_rate: FieldRef<"isin_master", 'Decimal'>
    readonly series: FieldRef<"isin_master", 'String'>
    readonly coupon_date_1: FieldRef<"isin_master", 'DateTime'>
    readonly coupon_date_2: FieldRef<"isin_master", 'DateTime'>
    readonly day_basis: FieldRef<"isin_master", 'Int'>
    readonly currency: FieldRef<"isin_master", 'String'>
    readonly created_at: FieldRef<"isin_master", 'DateTime'>
    readonly updated_at: FieldRef<"isin_master", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * isin_master findUnique
   */
  export type isin_masterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * Filter, which isin_master to fetch.
     */
    where: isin_masterWhereUniqueInput
  }

  /**
   * isin_master findUniqueOrThrow
   */
  export type isin_masterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * Filter, which isin_master to fetch.
     */
    where: isin_masterWhereUniqueInput
  }

  /**
   * isin_master findFirst
   */
  export type isin_masterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * Filter, which isin_master to fetch.
     */
    where?: isin_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_masters to fetch.
     */
    orderBy?: isin_masterOrderByWithRelationInput | isin_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for isin_masters.
     */
    cursor?: isin_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of isin_masters.
     */
    distinct?: Isin_masterScalarFieldEnum | Isin_masterScalarFieldEnum[]
  }

  /**
   * isin_master findFirstOrThrow
   */
  export type isin_masterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * Filter, which isin_master to fetch.
     */
    where?: isin_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_masters to fetch.
     */
    orderBy?: isin_masterOrderByWithRelationInput | isin_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for isin_masters.
     */
    cursor?: isin_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of isin_masters.
     */
    distinct?: Isin_masterScalarFieldEnum | Isin_masterScalarFieldEnum[]
  }

  /**
   * isin_master findMany
   */
  export type isin_masterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * Filter, which isin_masters to fetch.
     */
    where?: isin_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of isin_masters to fetch.
     */
    orderBy?: isin_masterOrderByWithRelationInput | isin_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing isin_masters.
     */
    cursor?: isin_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` isin_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` isin_masters.
     */
    skip?: number
    distinct?: Isin_masterScalarFieldEnum | Isin_masterScalarFieldEnum[]
  }

  /**
   * isin_master create
   */
  export type isin_masterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * The data needed to create a isin_master.
     */
    data: XOR<isin_masterCreateInput, isin_masterUncheckedCreateInput>
  }

  /**
   * isin_master createMany
   */
  export type isin_masterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many isin_masters.
     */
    data: isin_masterCreateManyInput | isin_masterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * isin_master update
   */
  export type isin_masterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * The data needed to update a isin_master.
     */
    data: XOR<isin_masterUpdateInput, isin_masterUncheckedUpdateInput>
    /**
     * Choose, which isin_master to update.
     */
    where: isin_masterWhereUniqueInput
  }

  /**
   * isin_master updateMany
   */
  export type isin_masterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update isin_masters.
     */
    data: XOR<isin_masterUpdateManyMutationInput, isin_masterUncheckedUpdateManyInput>
    /**
     * Filter which isin_masters to update
     */
    where?: isin_masterWhereInput
    /**
     * Limit how many isin_masters to update.
     */
    limit?: number
  }

  /**
   * isin_master upsert
   */
  export type isin_masterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * The filter to search for the isin_master to update in case it exists.
     */
    where: isin_masterWhereUniqueInput
    /**
     * In case the isin_master found by the `where` argument doesn't exist, create a new isin_master with this data.
     */
    create: XOR<isin_masterCreateInput, isin_masterUncheckedCreateInput>
    /**
     * In case the isin_master was found with the provided `where` argument, update it with this data.
     */
    update: XOR<isin_masterUpdateInput, isin_masterUncheckedUpdateInput>
  }

  /**
   * isin_master delete
   */
  export type isin_masterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
    /**
     * Filter which isin_master to delete.
     */
    where: isin_masterWhereUniqueInput
  }

  /**
   * isin_master deleteMany
   */
  export type isin_masterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which isin_masters to delete
     */
    where?: isin_masterWhereInput
    /**
     * Limit how many isin_masters to delete.
     */
    limit?: number
  }

  /**
   * isin_master.isin_coupon_schedule
   */
  export type isin_master$isin_coupon_scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_coupon_schedule
     */
    select?: isin_coupon_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_coupon_schedule
     */
    omit?: isin_coupon_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_coupon_scheduleInclude<ExtArgs> | null
    where?: isin_coupon_scheduleWhereInput
    orderBy?: isin_coupon_scheduleOrderByWithRelationInput | isin_coupon_scheduleOrderByWithRelationInput[]
    cursor?: isin_coupon_scheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Isin_coupon_scheduleScalarFieldEnum | Isin_coupon_scheduleScalarFieldEnum[]
  }

  /**
   * isin_master without action
   */
  export type isin_masterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the isin_master
     */
    select?: isin_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the isin_master
     */
    omit?: isin_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: isin_masterInclude<ExtArgs> | null
  }


  /**
   * Model ledger_entries
   */

  export type AggregateLedger_entries = {
    _count: Ledger_entriesCountAggregateOutputType | null
    _avg: Ledger_entriesAvgAggregateOutputType | null
    _sum: Ledger_entriesSumAggregateOutputType | null
    _min: Ledger_entriesMinAggregateOutputType | null
    _max: Ledger_entriesMaxAggregateOutputType | null
  }

  export type Ledger_entriesAvgAggregateOutputType = {
    id: number | null
    account_id: number | null
    debit_amount: Decimal | null
    credit_amount: Decimal | null
  }

  export type Ledger_entriesSumAggregateOutputType = {
    id: number | null
    account_id: number | null
    debit_amount: Decimal | null
    credit_amount: Decimal | null
  }

  export type Ledger_entriesMinAggregateOutputType = {
    id: number | null
    account_id: number | null
    entry_date: Date | null
    debit_amount: Decimal | null
    credit_amount: Decimal | null
    currency: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    deal_number: string | null
  }

  export type Ledger_entriesMaxAggregateOutputType = {
    id: number | null
    account_id: number | null
    entry_date: Date | null
    debit_amount: Decimal | null
    credit_amount: Decimal | null
    currency: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    deal_number: string | null
  }

  export type Ledger_entriesCountAggregateOutputType = {
    id: number
    account_id: number
    entry_date: number
    debit_amount: number
    credit_amount: number
    currency: number
    description: number
    created_at: number
    updated_at: number
    deal_number: number
    _all: number
  }


  export type Ledger_entriesAvgAggregateInputType = {
    id?: true
    account_id?: true
    debit_amount?: true
    credit_amount?: true
  }

  export type Ledger_entriesSumAggregateInputType = {
    id?: true
    account_id?: true
    debit_amount?: true
    credit_amount?: true
  }

  export type Ledger_entriesMinAggregateInputType = {
    id?: true
    account_id?: true
    entry_date?: true
    debit_amount?: true
    credit_amount?: true
    currency?: true
    description?: true
    created_at?: true
    updated_at?: true
    deal_number?: true
  }

  export type Ledger_entriesMaxAggregateInputType = {
    id?: true
    account_id?: true
    entry_date?: true
    debit_amount?: true
    credit_amount?: true
    currency?: true
    description?: true
    created_at?: true
    updated_at?: true
    deal_number?: true
  }

  export type Ledger_entriesCountAggregateInputType = {
    id?: true
    account_id?: true
    entry_date?: true
    debit_amount?: true
    credit_amount?: true
    currency?: true
    description?: true
    created_at?: true
    updated_at?: true
    deal_number?: true
    _all?: true
  }

  export type Ledger_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ledger_entries to aggregate.
     */
    where?: ledger_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_entries to fetch.
     */
    orderBy?: ledger_entriesOrderByWithRelationInput | ledger_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ledger_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ledger_entries
    **/
    _count?: true | Ledger_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ledger_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ledger_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ledger_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ledger_entriesMaxAggregateInputType
  }

  export type GetLedger_entriesAggregateType<T extends Ledger_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateLedger_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedger_entries[P]>
      : GetScalarType<T[P], AggregateLedger_entries[P]>
  }




  export type ledger_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ledger_entriesWhereInput
    orderBy?: ledger_entriesOrderByWithAggregationInput | ledger_entriesOrderByWithAggregationInput[]
    by: Ledger_entriesScalarFieldEnum[] | Ledger_entriesScalarFieldEnum
    having?: ledger_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ledger_entriesCountAggregateInputType | true
    _avg?: Ledger_entriesAvgAggregateInputType
    _sum?: Ledger_entriesSumAggregateInputType
    _min?: Ledger_entriesMinAggregateInputType
    _max?: Ledger_entriesMaxAggregateInputType
  }

  export type Ledger_entriesGroupByOutputType = {
    id: number
    account_id: number
    entry_date: Date
    debit_amount: Decimal | null
    credit_amount: Decimal | null
    currency: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    deal_number: string | null
    _count: Ledger_entriesCountAggregateOutputType | null
    _avg: Ledger_entriesAvgAggregateOutputType | null
    _sum: Ledger_entriesSumAggregateOutputType | null
    _min: Ledger_entriesMinAggregateOutputType | null
    _max: Ledger_entriesMaxAggregateOutputType | null
  }

  type GetLedger_entriesGroupByPayload<T extends ledger_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ledger_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ledger_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ledger_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Ledger_entriesGroupByOutputType[P]>
        }
      >
    >


  export type ledger_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    entry_date?: boolean
    debit_amount?: boolean
    credit_amount?: boolean
    currency?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    deal_number?: boolean
    chart_of_accounts?: boolean | chart_of_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledger_entries"]>



  export type ledger_entriesSelectScalar = {
    id?: boolean
    account_id?: boolean
    entry_date?: boolean
    debit_amount?: boolean
    credit_amount?: boolean
    currency?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    deal_number?: boolean
  }

  export type ledger_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "entry_date" | "debit_amount" | "credit_amount" | "currency" | "description" | "created_at" | "updated_at" | "deal_number", ExtArgs["result"]["ledger_entries"]>
  export type ledger_entriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chart_of_accounts?: boolean | chart_of_accountsDefaultArgs<ExtArgs>
  }

  export type $ledger_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ledger_entries"
    objects: {
      chart_of_accounts: Prisma.$chart_of_accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      account_id: number
      entry_date: Date
      debit_amount: Prisma.Decimal | null
      credit_amount: Prisma.Decimal | null
      currency: string | null
      description: string | null
      created_at: Date | null
      updated_at: Date | null
      deal_number: string | null
    }, ExtArgs["result"]["ledger_entries"]>
    composites: {}
  }

  type ledger_entriesGetPayload<S extends boolean | null | undefined | ledger_entriesDefaultArgs> = $Result.GetResult<Prisma.$ledger_entriesPayload, S>

  type ledger_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ledger_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ledger_entriesCountAggregateInputType | true
    }

  export interface ledger_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ledger_entries'], meta: { name: 'ledger_entries' } }
    /**
     * Find zero or one Ledger_entries that matches the filter.
     * @param {ledger_entriesFindUniqueArgs} args - Arguments to find a Ledger_entries
     * @example
     * // Get one Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ledger_entriesFindUniqueArgs>(args: SelectSubset<T, ledger_entriesFindUniqueArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ledger_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ledger_entriesFindUniqueOrThrowArgs} args - Arguments to find a Ledger_entries
     * @example
     * // Get one Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ledger_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, ledger_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ledger_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_entriesFindFirstArgs} args - Arguments to find a Ledger_entries
     * @example
     * // Get one Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ledger_entriesFindFirstArgs>(args?: SelectSubset<T, ledger_entriesFindFirstArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ledger_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_entriesFindFirstOrThrowArgs} args - Arguments to find a Ledger_entries
     * @example
     * // Get one Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ledger_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, ledger_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ledger_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.findMany()
     * 
     * // Get first 10 Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledger_entriesWithIdOnly = await prisma.ledger_entries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ledger_entriesFindManyArgs>(args?: SelectSubset<T, ledger_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ledger_entries.
     * @param {ledger_entriesCreateArgs} args - Arguments to create a Ledger_entries.
     * @example
     * // Create one Ledger_entries
     * const Ledger_entries = await prisma.ledger_entries.create({
     *   data: {
     *     // ... data to create a Ledger_entries
     *   }
     * })
     * 
     */
    create<T extends ledger_entriesCreateArgs>(args: SelectSubset<T, ledger_entriesCreateArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ledger_entries.
     * @param {ledger_entriesCreateManyArgs} args - Arguments to create many Ledger_entries.
     * @example
     * // Create many Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ledger_entriesCreateManyArgs>(args?: SelectSubset<T, ledger_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ledger_entries.
     * @param {ledger_entriesDeleteArgs} args - Arguments to delete one Ledger_entries.
     * @example
     * // Delete one Ledger_entries
     * const Ledger_entries = await prisma.ledger_entries.delete({
     *   where: {
     *     // ... filter to delete one Ledger_entries
     *   }
     * })
     * 
     */
    delete<T extends ledger_entriesDeleteArgs>(args: SelectSubset<T, ledger_entriesDeleteArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ledger_entries.
     * @param {ledger_entriesUpdateArgs} args - Arguments to update one Ledger_entries.
     * @example
     * // Update one Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ledger_entriesUpdateArgs>(args: SelectSubset<T, ledger_entriesUpdateArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ledger_entries.
     * @param {ledger_entriesDeleteManyArgs} args - Arguments to filter Ledger_entries to delete.
     * @example
     * // Delete a few Ledger_entries
     * const { count } = await prisma.ledger_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ledger_entriesDeleteManyArgs>(args?: SelectSubset<T, ledger_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ledger_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ledger_entriesUpdateManyArgs>(args: SelectSubset<T, ledger_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ledger_entries.
     * @param {ledger_entriesUpsertArgs} args - Arguments to update or create a Ledger_entries.
     * @example
     * // Update or create a Ledger_entries
     * const ledger_entries = await prisma.ledger_entries.upsert({
     *   create: {
     *     // ... data to create a Ledger_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ledger_entries we want to update
     *   }
     * })
     */
    upsert<T extends ledger_entriesUpsertArgs>(args: SelectSubset<T, ledger_entriesUpsertArgs<ExtArgs>>): Prisma__ledger_entriesClient<$Result.GetResult<Prisma.$ledger_entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ledger_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_entriesCountArgs} args - Arguments to filter Ledger_entries to count.
     * @example
     * // Count the number of Ledger_entries
     * const count = await prisma.ledger_entries.count({
     *   where: {
     *     // ... the filter for the Ledger_entries we want to count
     *   }
     * })
    **/
    count<T extends ledger_entriesCountArgs>(
      args?: Subset<T, ledger_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ledger_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ledger_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ledger_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ledger_entriesAggregateArgs>(args: Subset<T, Ledger_entriesAggregateArgs>): Prisma.PrismaPromise<GetLedger_entriesAggregateType<T>>

    /**
     * Group by Ledger_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ledger_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ledger_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ledger_entriesGroupByArgs['orderBy'] }
        : { orderBy?: ledger_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ledger_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedger_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ledger_entries model
   */
  readonly fields: ledger_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ledger_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ledger_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chart_of_accounts<T extends chart_of_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chart_of_accountsDefaultArgs<ExtArgs>>): Prisma__chart_of_accountsClient<$Result.GetResult<Prisma.$chart_of_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ledger_entries model
   */
  interface ledger_entriesFieldRefs {
    readonly id: FieldRef<"ledger_entries", 'Int'>
    readonly account_id: FieldRef<"ledger_entries", 'Int'>
    readonly entry_date: FieldRef<"ledger_entries", 'DateTime'>
    readonly debit_amount: FieldRef<"ledger_entries", 'Decimal'>
    readonly credit_amount: FieldRef<"ledger_entries", 'Decimal'>
    readonly currency: FieldRef<"ledger_entries", 'String'>
    readonly description: FieldRef<"ledger_entries", 'String'>
    readonly created_at: FieldRef<"ledger_entries", 'DateTime'>
    readonly updated_at: FieldRef<"ledger_entries", 'DateTime'>
    readonly deal_number: FieldRef<"ledger_entries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ledger_entries findUnique
   */
  export type ledger_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * Filter, which ledger_entries to fetch.
     */
    where: ledger_entriesWhereUniqueInput
  }

  /**
   * ledger_entries findUniqueOrThrow
   */
  export type ledger_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * Filter, which ledger_entries to fetch.
     */
    where: ledger_entriesWhereUniqueInput
  }

  /**
   * ledger_entries findFirst
   */
  export type ledger_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * Filter, which ledger_entries to fetch.
     */
    where?: ledger_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_entries to fetch.
     */
    orderBy?: ledger_entriesOrderByWithRelationInput | ledger_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ledger_entries.
     */
    cursor?: ledger_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ledger_entries.
     */
    distinct?: Ledger_entriesScalarFieldEnum | Ledger_entriesScalarFieldEnum[]
  }

  /**
   * ledger_entries findFirstOrThrow
   */
  export type ledger_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * Filter, which ledger_entries to fetch.
     */
    where?: ledger_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_entries to fetch.
     */
    orderBy?: ledger_entriesOrderByWithRelationInput | ledger_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ledger_entries.
     */
    cursor?: ledger_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ledger_entries.
     */
    distinct?: Ledger_entriesScalarFieldEnum | Ledger_entriesScalarFieldEnum[]
  }

  /**
   * ledger_entries findMany
   */
  export type ledger_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * Filter, which ledger_entries to fetch.
     */
    where?: ledger_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ledger_entries to fetch.
     */
    orderBy?: ledger_entriesOrderByWithRelationInput | ledger_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ledger_entries.
     */
    cursor?: ledger_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ledger_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ledger_entries.
     */
    skip?: number
    distinct?: Ledger_entriesScalarFieldEnum | Ledger_entriesScalarFieldEnum[]
  }

  /**
   * ledger_entries create
   */
  export type ledger_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * The data needed to create a ledger_entries.
     */
    data: XOR<ledger_entriesCreateInput, ledger_entriesUncheckedCreateInput>
  }

  /**
   * ledger_entries createMany
   */
  export type ledger_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ledger_entries.
     */
    data: ledger_entriesCreateManyInput | ledger_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ledger_entries update
   */
  export type ledger_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * The data needed to update a ledger_entries.
     */
    data: XOR<ledger_entriesUpdateInput, ledger_entriesUncheckedUpdateInput>
    /**
     * Choose, which ledger_entries to update.
     */
    where: ledger_entriesWhereUniqueInput
  }

  /**
   * ledger_entries updateMany
   */
  export type ledger_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ledger_entries.
     */
    data: XOR<ledger_entriesUpdateManyMutationInput, ledger_entriesUncheckedUpdateManyInput>
    /**
     * Filter which ledger_entries to update
     */
    where?: ledger_entriesWhereInput
    /**
     * Limit how many ledger_entries to update.
     */
    limit?: number
  }

  /**
   * ledger_entries upsert
   */
  export type ledger_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * The filter to search for the ledger_entries to update in case it exists.
     */
    where: ledger_entriesWhereUniqueInput
    /**
     * In case the ledger_entries found by the `where` argument doesn't exist, create a new ledger_entries with this data.
     */
    create: XOR<ledger_entriesCreateInput, ledger_entriesUncheckedCreateInput>
    /**
     * In case the ledger_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ledger_entriesUpdateInput, ledger_entriesUncheckedUpdateInput>
  }

  /**
   * ledger_entries delete
   */
  export type ledger_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
    /**
     * Filter which ledger_entries to delete.
     */
    where: ledger_entriesWhereUniqueInput
  }

  /**
   * ledger_entries deleteMany
   */
  export type ledger_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ledger_entries to delete
     */
    where?: ledger_entriesWhereInput
    /**
     * Limit how many ledger_entries to delete.
     */
    limit?: number
  }

  /**
   * ledger_entries without action
   */
  export type ledger_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ledger_entries
     */
    select?: ledger_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ledger_entries
     */
    omit?: ledger_entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ledger_entriesInclude<ExtArgs> | null
  }


  /**
   * Model money_market_deals
   */

  export type AggregateMoney_market_deals = {
    _count: Money_market_dealsCountAggregateOutputType | null
    _avg: Money_market_dealsAvgAggregateOutputType | null
    _sum: Money_market_dealsSumAggregateOutputType | null
    _min: Money_market_dealsMinAggregateOutputType | null
    _max: Money_market_dealsMaxAggregateOutputType | null
  }

  export type Money_market_dealsAvgAggregateOutputType = {
    id: number | null
    counterparty_id: number | null
    principal_amount: Decimal | null
    interest_rate: Decimal | null
    tenor: number | null
    interest_amount: Decimal | null
    maturity_value: Decimal | null
  }

  export type Money_market_dealsSumAggregateOutputType = {
    id: number | null
    counterparty_id: number | null
    principal_amount: Decimal | null
    interest_rate: Decimal | null
    tenor: number | null
    interest_amount: Decimal | null
    maturity_value: Decimal | null
  }

  export type Money_market_dealsMinAggregateOutputType = {
    id: number | null
    deal_number: string | null
    trade_date: Date | null
    value_date: Date | null
    maturity_date: Date | null
    counterparty_type: $Enums.money_market_deals_counterparty_type | null
    counterparty_id: number | null
    product_type: string | null
    currency: string | null
    principal_amount: Decimal | null
    interest_rate: Decimal | null
    tenor: number | null
    interest_amount: Decimal | null
    maturity_value: Decimal | null
    settlement_mode: string | null
    remarks: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Money_market_dealsMaxAggregateOutputType = {
    id: number | null
    deal_number: string | null
    trade_date: Date | null
    value_date: Date | null
    maturity_date: Date | null
    counterparty_type: $Enums.money_market_deals_counterparty_type | null
    counterparty_id: number | null
    product_type: string | null
    currency: string | null
    principal_amount: Decimal | null
    interest_rate: Decimal | null
    tenor: number | null
    interest_amount: Decimal | null
    maturity_value: Decimal | null
    settlement_mode: string | null
    remarks: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Money_market_dealsCountAggregateOutputType = {
    id: number
    deal_number: number
    trade_date: number
    value_date: number
    maturity_date: number
    counterparty_type: number
    counterparty_id: number
    product_type: number
    currency: number
    principal_amount: number
    interest_rate: number
    tenor: number
    interest_amount: number
    maturity_value: number
    settlement_mode: number
    remarks: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Money_market_dealsAvgAggregateInputType = {
    id?: true
    counterparty_id?: true
    principal_amount?: true
    interest_rate?: true
    tenor?: true
    interest_amount?: true
    maturity_value?: true
  }

  export type Money_market_dealsSumAggregateInputType = {
    id?: true
    counterparty_id?: true
    principal_amount?: true
    interest_rate?: true
    tenor?: true
    interest_amount?: true
    maturity_value?: true
  }

  export type Money_market_dealsMinAggregateInputType = {
    id?: true
    deal_number?: true
    trade_date?: true
    value_date?: true
    maturity_date?: true
    counterparty_type?: true
    counterparty_id?: true
    product_type?: true
    currency?: true
    principal_amount?: true
    interest_rate?: true
    tenor?: true
    interest_amount?: true
    maturity_value?: true
    settlement_mode?: true
    remarks?: true
    created_at?: true
    updated_at?: true
  }

  export type Money_market_dealsMaxAggregateInputType = {
    id?: true
    deal_number?: true
    trade_date?: true
    value_date?: true
    maturity_date?: true
    counterparty_type?: true
    counterparty_id?: true
    product_type?: true
    currency?: true
    principal_amount?: true
    interest_rate?: true
    tenor?: true
    interest_amount?: true
    maturity_value?: true
    settlement_mode?: true
    remarks?: true
    created_at?: true
    updated_at?: true
  }

  export type Money_market_dealsCountAggregateInputType = {
    id?: true
    deal_number?: true
    trade_date?: true
    value_date?: true
    maturity_date?: true
    counterparty_type?: true
    counterparty_id?: true
    product_type?: true
    currency?: true
    principal_amount?: true
    interest_rate?: true
    tenor?: true
    interest_amount?: true
    maturity_value?: true
    settlement_mode?: true
    remarks?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Money_market_dealsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which money_market_deals to aggregate.
     */
    where?: money_market_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of money_market_deals to fetch.
     */
    orderBy?: money_market_dealsOrderByWithRelationInput | money_market_dealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: money_market_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` money_market_deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` money_market_deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned money_market_deals
    **/
    _count?: true | Money_market_dealsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Money_market_dealsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Money_market_dealsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Money_market_dealsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Money_market_dealsMaxAggregateInputType
  }

  export type GetMoney_market_dealsAggregateType<T extends Money_market_dealsAggregateArgs> = {
        [P in keyof T & keyof AggregateMoney_market_deals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoney_market_deals[P]>
      : GetScalarType<T[P], AggregateMoney_market_deals[P]>
  }




  export type money_market_dealsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: money_market_dealsWhereInput
    orderBy?: money_market_dealsOrderByWithAggregationInput | money_market_dealsOrderByWithAggregationInput[]
    by: Money_market_dealsScalarFieldEnum[] | Money_market_dealsScalarFieldEnum
    having?: money_market_dealsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Money_market_dealsCountAggregateInputType | true
    _avg?: Money_market_dealsAvgAggregateInputType
    _sum?: Money_market_dealsSumAggregateInputType
    _min?: Money_market_dealsMinAggregateInputType
    _max?: Money_market_dealsMaxAggregateInputType
  }

  export type Money_market_dealsGroupByOutputType = {
    id: number
    deal_number: string
    trade_date: Date
    value_date: Date
    maturity_date: Date
    counterparty_type: $Enums.money_market_deals_counterparty_type
    counterparty_id: number
    product_type: string
    currency: string
    principal_amount: Decimal
    interest_rate: Decimal
    tenor: number
    interest_amount: Decimal
    maturity_value: Decimal
    settlement_mode: string | null
    remarks: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Money_market_dealsCountAggregateOutputType | null
    _avg: Money_market_dealsAvgAggregateOutputType | null
    _sum: Money_market_dealsSumAggregateOutputType | null
    _min: Money_market_dealsMinAggregateOutputType | null
    _max: Money_market_dealsMaxAggregateOutputType | null
  }

  type GetMoney_market_dealsGroupByPayload<T extends money_market_dealsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Money_market_dealsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Money_market_dealsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Money_market_dealsGroupByOutputType[P]>
            : GetScalarType<T[P], Money_market_dealsGroupByOutputType[P]>
        }
      >
    >


  export type money_market_dealsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deal_number?: boolean
    trade_date?: boolean
    value_date?: boolean
    maturity_date?: boolean
    counterparty_type?: boolean
    counterparty_id?: boolean
    product_type?: boolean
    currency?: boolean
    principal_amount?: boolean
    interest_rate?: boolean
    tenor?: boolean
    interest_amount?: boolean
    maturity_value?: boolean
    settlement_mode?: boolean
    remarks?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["money_market_deals"]>



  export type money_market_dealsSelectScalar = {
    id?: boolean
    deal_number?: boolean
    trade_date?: boolean
    value_date?: boolean
    maturity_date?: boolean
    counterparty_type?: boolean
    counterparty_id?: boolean
    product_type?: boolean
    currency?: boolean
    principal_amount?: boolean
    interest_rate?: boolean
    tenor?: boolean
    interest_amount?: boolean
    maturity_value?: boolean
    settlement_mode?: boolean
    remarks?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type money_market_dealsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deal_number" | "trade_date" | "value_date" | "maturity_date" | "counterparty_type" | "counterparty_id" | "product_type" | "currency" | "principal_amount" | "interest_rate" | "tenor" | "interest_amount" | "maturity_value" | "settlement_mode" | "remarks" | "created_at" | "updated_at", ExtArgs["result"]["money_market_deals"]>

  export type $money_market_dealsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "money_market_deals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deal_number: string
      trade_date: Date
      value_date: Date
      maturity_date: Date
      counterparty_type: $Enums.money_market_deals_counterparty_type
      counterparty_id: number
      product_type: string
      currency: string
      principal_amount: Prisma.Decimal
      interest_rate: Prisma.Decimal
      tenor: number
      interest_amount: Prisma.Decimal
      maturity_value: Prisma.Decimal
      settlement_mode: string | null
      remarks: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["money_market_deals"]>
    composites: {}
  }

  type money_market_dealsGetPayload<S extends boolean | null | undefined | money_market_dealsDefaultArgs> = $Result.GetResult<Prisma.$money_market_dealsPayload, S>

  type money_market_dealsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<money_market_dealsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Money_market_dealsCountAggregateInputType | true
    }

  export interface money_market_dealsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['money_market_deals'], meta: { name: 'money_market_deals' } }
    /**
     * Find zero or one Money_market_deals that matches the filter.
     * @param {money_market_dealsFindUniqueArgs} args - Arguments to find a Money_market_deals
     * @example
     * // Get one Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends money_market_dealsFindUniqueArgs>(args: SelectSubset<T, money_market_dealsFindUniqueArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Money_market_deals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {money_market_dealsFindUniqueOrThrowArgs} args - Arguments to find a Money_market_deals
     * @example
     * // Get one Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends money_market_dealsFindUniqueOrThrowArgs>(args: SelectSubset<T, money_market_dealsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Money_market_deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {money_market_dealsFindFirstArgs} args - Arguments to find a Money_market_deals
     * @example
     * // Get one Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends money_market_dealsFindFirstArgs>(args?: SelectSubset<T, money_market_dealsFindFirstArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Money_market_deals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {money_market_dealsFindFirstOrThrowArgs} args - Arguments to find a Money_market_deals
     * @example
     * // Get one Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends money_market_dealsFindFirstOrThrowArgs>(args?: SelectSubset<T, money_market_dealsFindFirstOrThrowArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Money_market_deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {money_market_dealsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.findMany()
     * 
     * // Get first 10 Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const money_market_dealsWithIdOnly = await prisma.money_market_deals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends money_market_dealsFindManyArgs>(args?: SelectSubset<T, money_market_dealsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Money_market_deals.
     * @param {money_market_dealsCreateArgs} args - Arguments to create a Money_market_deals.
     * @example
     * // Create one Money_market_deals
     * const Money_market_deals = await prisma.money_market_deals.create({
     *   data: {
     *     // ... data to create a Money_market_deals
     *   }
     * })
     * 
     */
    create<T extends money_market_dealsCreateArgs>(args: SelectSubset<T, money_market_dealsCreateArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Money_market_deals.
     * @param {money_market_dealsCreateManyArgs} args - Arguments to create many Money_market_deals.
     * @example
     * // Create many Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends money_market_dealsCreateManyArgs>(args?: SelectSubset<T, money_market_dealsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Money_market_deals.
     * @param {money_market_dealsDeleteArgs} args - Arguments to delete one Money_market_deals.
     * @example
     * // Delete one Money_market_deals
     * const Money_market_deals = await prisma.money_market_deals.delete({
     *   where: {
     *     // ... filter to delete one Money_market_deals
     *   }
     * })
     * 
     */
    delete<T extends money_market_dealsDeleteArgs>(args: SelectSubset<T, money_market_dealsDeleteArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Money_market_deals.
     * @param {money_market_dealsUpdateArgs} args - Arguments to update one Money_market_deals.
     * @example
     * // Update one Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends money_market_dealsUpdateArgs>(args: SelectSubset<T, money_market_dealsUpdateArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Money_market_deals.
     * @param {money_market_dealsDeleteManyArgs} args - Arguments to filter Money_market_deals to delete.
     * @example
     * // Delete a few Money_market_deals
     * const { count } = await prisma.money_market_deals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends money_market_dealsDeleteManyArgs>(args?: SelectSubset<T, money_market_dealsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Money_market_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {money_market_dealsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends money_market_dealsUpdateManyArgs>(args: SelectSubset<T, money_market_dealsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Money_market_deals.
     * @param {money_market_dealsUpsertArgs} args - Arguments to update or create a Money_market_deals.
     * @example
     * // Update or create a Money_market_deals
     * const money_market_deals = await prisma.money_market_deals.upsert({
     *   create: {
     *     // ... data to create a Money_market_deals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Money_market_deals we want to update
     *   }
     * })
     */
    upsert<T extends money_market_dealsUpsertArgs>(args: SelectSubset<T, money_market_dealsUpsertArgs<ExtArgs>>): Prisma__money_market_dealsClient<$Result.GetResult<Prisma.$money_market_dealsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Money_market_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {money_market_dealsCountArgs} args - Arguments to filter Money_market_deals to count.
     * @example
     * // Count the number of Money_market_deals
     * const count = await prisma.money_market_deals.count({
     *   where: {
     *     // ... the filter for the Money_market_deals we want to count
     *   }
     * })
    **/
    count<T extends money_market_dealsCountArgs>(
      args?: Subset<T, money_market_dealsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Money_market_dealsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Money_market_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Money_market_dealsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Money_market_dealsAggregateArgs>(args: Subset<T, Money_market_dealsAggregateArgs>): Prisma.PrismaPromise<GetMoney_market_dealsAggregateType<T>>

    /**
     * Group by Money_market_deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {money_market_dealsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends money_market_dealsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: money_market_dealsGroupByArgs['orderBy'] }
        : { orderBy?: money_market_dealsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, money_market_dealsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoney_market_dealsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the money_market_deals model
   */
  readonly fields: money_market_dealsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for money_market_deals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__money_market_dealsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the money_market_deals model
   */
  interface money_market_dealsFieldRefs {
    readonly id: FieldRef<"money_market_deals", 'Int'>
    readonly deal_number: FieldRef<"money_market_deals", 'String'>
    readonly trade_date: FieldRef<"money_market_deals", 'DateTime'>
    readonly value_date: FieldRef<"money_market_deals", 'DateTime'>
    readonly maturity_date: FieldRef<"money_market_deals", 'DateTime'>
    readonly counterparty_type: FieldRef<"money_market_deals", 'money_market_deals_counterparty_type'>
    readonly counterparty_id: FieldRef<"money_market_deals", 'Int'>
    readonly product_type: FieldRef<"money_market_deals", 'String'>
    readonly currency: FieldRef<"money_market_deals", 'String'>
    readonly principal_amount: FieldRef<"money_market_deals", 'Decimal'>
    readonly interest_rate: FieldRef<"money_market_deals", 'Decimal'>
    readonly tenor: FieldRef<"money_market_deals", 'Int'>
    readonly interest_amount: FieldRef<"money_market_deals", 'Decimal'>
    readonly maturity_value: FieldRef<"money_market_deals", 'Decimal'>
    readonly settlement_mode: FieldRef<"money_market_deals", 'String'>
    readonly remarks: FieldRef<"money_market_deals", 'String'>
    readonly created_at: FieldRef<"money_market_deals", 'DateTime'>
    readonly updated_at: FieldRef<"money_market_deals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * money_market_deals findUnique
   */
  export type money_market_dealsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * Filter, which money_market_deals to fetch.
     */
    where: money_market_dealsWhereUniqueInput
  }

  /**
   * money_market_deals findUniqueOrThrow
   */
  export type money_market_dealsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * Filter, which money_market_deals to fetch.
     */
    where: money_market_dealsWhereUniqueInput
  }

  /**
   * money_market_deals findFirst
   */
  export type money_market_dealsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * Filter, which money_market_deals to fetch.
     */
    where?: money_market_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of money_market_deals to fetch.
     */
    orderBy?: money_market_dealsOrderByWithRelationInput | money_market_dealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for money_market_deals.
     */
    cursor?: money_market_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` money_market_deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` money_market_deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of money_market_deals.
     */
    distinct?: Money_market_dealsScalarFieldEnum | Money_market_dealsScalarFieldEnum[]
  }

  /**
   * money_market_deals findFirstOrThrow
   */
  export type money_market_dealsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * Filter, which money_market_deals to fetch.
     */
    where?: money_market_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of money_market_deals to fetch.
     */
    orderBy?: money_market_dealsOrderByWithRelationInput | money_market_dealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for money_market_deals.
     */
    cursor?: money_market_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` money_market_deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` money_market_deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of money_market_deals.
     */
    distinct?: Money_market_dealsScalarFieldEnum | Money_market_dealsScalarFieldEnum[]
  }

  /**
   * money_market_deals findMany
   */
  export type money_market_dealsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * Filter, which money_market_deals to fetch.
     */
    where?: money_market_dealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of money_market_deals to fetch.
     */
    orderBy?: money_market_dealsOrderByWithRelationInput | money_market_dealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing money_market_deals.
     */
    cursor?: money_market_dealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` money_market_deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` money_market_deals.
     */
    skip?: number
    distinct?: Money_market_dealsScalarFieldEnum | Money_market_dealsScalarFieldEnum[]
  }

  /**
   * money_market_deals create
   */
  export type money_market_dealsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * The data needed to create a money_market_deals.
     */
    data: XOR<money_market_dealsCreateInput, money_market_dealsUncheckedCreateInput>
  }

  /**
   * money_market_deals createMany
   */
  export type money_market_dealsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many money_market_deals.
     */
    data: money_market_dealsCreateManyInput | money_market_dealsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * money_market_deals update
   */
  export type money_market_dealsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * The data needed to update a money_market_deals.
     */
    data: XOR<money_market_dealsUpdateInput, money_market_dealsUncheckedUpdateInput>
    /**
     * Choose, which money_market_deals to update.
     */
    where: money_market_dealsWhereUniqueInput
  }

  /**
   * money_market_deals updateMany
   */
  export type money_market_dealsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update money_market_deals.
     */
    data: XOR<money_market_dealsUpdateManyMutationInput, money_market_dealsUncheckedUpdateManyInput>
    /**
     * Filter which money_market_deals to update
     */
    where?: money_market_dealsWhereInput
    /**
     * Limit how many money_market_deals to update.
     */
    limit?: number
  }

  /**
   * money_market_deals upsert
   */
  export type money_market_dealsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * The filter to search for the money_market_deals to update in case it exists.
     */
    where: money_market_dealsWhereUniqueInput
    /**
     * In case the money_market_deals found by the `where` argument doesn't exist, create a new money_market_deals with this data.
     */
    create: XOR<money_market_dealsCreateInput, money_market_dealsUncheckedCreateInput>
    /**
     * In case the money_market_deals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<money_market_dealsUpdateInput, money_market_dealsUncheckedUpdateInput>
  }

  /**
   * money_market_deals delete
   */
  export type money_market_dealsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
    /**
     * Filter which money_market_deals to delete.
     */
    where: money_market_dealsWhereUniqueInput
  }

  /**
   * money_market_deals deleteMany
   */
  export type money_market_dealsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which money_market_deals to delete
     */
    where?: money_market_dealsWhereInput
    /**
     * Limit how many money_market_deals to delete.
     */
    limit?: number
  }

  /**
   * money_market_deals without action
   */
  export type money_market_dealsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the money_market_deals
     */
    select?: money_market_dealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the money_market_deals
     */
    omit?: money_market_dealsOmit<ExtArgs> | null
  }


  /**
   * Model portfolio_master
   */

  export type AggregatePortfolio_master = {
    _count: Portfolio_masterCountAggregateOutputType | null
    _avg: Portfolio_masterAvgAggregateOutputType | null
    _sum: Portfolio_masterSumAggregateOutputType | null
    _min: Portfolio_masterMinAggregateOutputType | null
    _max: Portfolio_masterMaxAggregateOutputType | null
  }

  export type Portfolio_masterAvgAggregateOutputType = {
    target_yield_return: Decimal | null
  }

  export type Portfolio_masterSumAggregateOutputType = {
    target_yield_return: Decimal | null
  }

  export type Portfolio_masterMinAggregateOutputType = {
    portfolio_id: string | null
    portfolio_name: string | null
    portfolio_type: string | null
    entity_business_unit: string | null
    fund_manager_user_id: string | null
    base_currency: string | null
    benchmark: string | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.portfolio_master_status | null
    risk_profile: $Enums.portfolio_master_risk_profile | null
    investment_horizon: $Enums.portfolio_master_investment_horizon | null
    target_yield_return: Decimal | null
    compliance_rules_id: string | null
    notes_description: string | null
    parent_portfolio_id: string | null
    valuation_method: string | null
    accounting_treatment: string | null
    rebalancing_frequency: string | null
    external_reference_code: string | null
    tags_categories: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Portfolio_masterMaxAggregateOutputType = {
    portfolio_id: string | null
    portfolio_name: string | null
    portfolio_type: string | null
    entity_business_unit: string | null
    fund_manager_user_id: string | null
    base_currency: string | null
    benchmark: string | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.portfolio_master_status | null
    risk_profile: $Enums.portfolio_master_risk_profile | null
    investment_horizon: $Enums.portfolio_master_investment_horizon | null
    target_yield_return: Decimal | null
    compliance_rules_id: string | null
    notes_description: string | null
    parent_portfolio_id: string | null
    valuation_method: string | null
    accounting_treatment: string | null
    rebalancing_frequency: string | null
    external_reference_code: string | null
    tags_categories: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Portfolio_masterCountAggregateOutputType = {
    portfolio_id: number
    portfolio_name: number
    portfolio_type: number
    entity_business_unit: number
    fund_manager_user_id: number
    base_currency: number
    benchmark: number
    start_date: number
    end_date: number
    status: number
    risk_profile: number
    investment_horizon: number
    target_yield_return: number
    compliance_rules_id: number
    notes_description: number
    parent_portfolio_id: number
    valuation_method: number
    accounting_treatment: number
    rebalancing_frequency: number
    external_reference_code: number
    tags_categories: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Portfolio_masterAvgAggregateInputType = {
    target_yield_return?: true
  }

  export type Portfolio_masterSumAggregateInputType = {
    target_yield_return?: true
  }

  export type Portfolio_masterMinAggregateInputType = {
    portfolio_id?: true
    portfolio_name?: true
    portfolio_type?: true
    entity_business_unit?: true
    fund_manager_user_id?: true
    base_currency?: true
    benchmark?: true
    start_date?: true
    end_date?: true
    status?: true
    risk_profile?: true
    investment_horizon?: true
    target_yield_return?: true
    compliance_rules_id?: true
    notes_description?: true
    parent_portfolio_id?: true
    valuation_method?: true
    accounting_treatment?: true
    rebalancing_frequency?: true
    external_reference_code?: true
    tags_categories?: true
    created_at?: true
    updated_at?: true
  }

  export type Portfolio_masterMaxAggregateInputType = {
    portfolio_id?: true
    portfolio_name?: true
    portfolio_type?: true
    entity_business_unit?: true
    fund_manager_user_id?: true
    base_currency?: true
    benchmark?: true
    start_date?: true
    end_date?: true
    status?: true
    risk_profile?: true
    investment_horizon?: true
    target_yield_return?: true
    compliance_rules_id?: true
    notes_description?: true
    parent_portfolio_id?: true
    valuation_method?: true
    accounting_treatment?: true
    rebalancing_frequency?: true
    external_reference_code?: true
    tags_categories?: true
    created_at?: true
    updated_at?: true
  }

  export type Portfolio_masterCountAggregateInputType = {
    portfolio_id?: true
    portfolio_name?: true
    portfolio_type?: true
    entity_business_unit?: true
    fund_manager_user_id?: true
    base_currency?: true
    benchmark?: true
    start_date?: true
    end_date?: true
    status?: true
    risk_profile?: true
    investment_horizon?: true
    target_yield_return?: true
    compliance_rules_id?: true
    notes_description?: true
    parent_portfolio_id?: true
    valuation_method?: true
    accounting_treatment?: true
    rebalancing_frequency?: true
    external_reference_code?: true
    tags_categories?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Portfolio_masterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which portfolio_master to aggregate.
     */
    where?: portfolio_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolio_masters to fetch.
     */
    orderBy?: portfolio_masterOrderByWithRelationInput | portfolio_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: portfolio_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolio_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolio_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned portfolio_masters
    **/
    _count?: true | Portfolio_masterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Portfolio_masterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Portfolio_masterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Portfolio_masterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Portfolio_masterMaxAggregateInputType
  }

  export type GetPortfolio_masterAggregateType<T extends Portfolio_masterAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio_master]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio_master[P]>
      : GetScalarType<T[P], AggregatePortfolio_master[P]>
  }




  export type portfolio_masterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: portfolio_masterWhereInput
    orderBy?: portfolio_masterOrderByWithAggregationInput | portfolio_masterOrderByWithAggregationInput[]
    by: Portfolio_masterScalarFieldEnum[] | Portfolio_masterScalarFieldEnum
    having?: portfolio_masterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Portfolio_masterCountAggregateInputType | true
    _avg?: Portfolio_masterAvgAggregateInputType
    _sum?: Portfolio_masterSumAggregateInputType
    _min?: Portfolio_masterMinAggregateInputType
    _max?: Portfolio_masterMaxAggregateInputType
  }

  export type Portfolio_masterGroupByOutputType = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type: string | null
    entity_business_unit: string | null
    fund_manager_user_id: string | null
    base_currency: string | null
    benchmark: string | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.portfolio_master_status | null
    risk_profile: $Enums.portfolio_master_risk_profile | null
    investment_horizon: $Enums.portfolio_master_investment_horizon | null
    target_yield_return: Decimal | null
    compliance_rules_id: string | null
    notes_description: string | null
    parent_portfolio_id: string | null
    valuation_method: string | null
    accounting_treatment: string | null
    rebalancing_frequency: string | null
    external_reference_code: string | null
    tags_categories: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Portfolio_masterCountAggregateOutputType | null
    _avg: Portfolio_masterAvgAggregateOutputType | null
    _sum: Portfolio_masterSumAggregateOutputType | null
    _min: Portfolio_masterMinAggregateOutputType | null
    _max: Portfolio_masterMaxAggregateOutputType | null
  }

  type GetPortfolio_masterGroupByPayload<T extends portfolio_masterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Portfolio_masterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Portfolio_masterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Portfolio_masterGroupByOutputType[P]>
            : GetScalarType<T[P], Portfolio_masterGroupByOutputType[P]>
        }
      >
    >


  export type portfolio_masterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolio_id?: boolean
    portfolio_name?: boolean
    portfolio_type?: boolean
    entity_business_unit?: boolean
    fund_manager_user_id?: boolean
    base_currency?: boolean
    benchmark?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    risk_profile?: boolean
    investment_horizon?: boolean
    target_yield_return?: boolean
    compliance_rules_id?: boolean
    notes_description?: boolean
    parent_portfolio_id?: boolean
    valuation_method?: boolean
    accounting_treatment?: boolean
    rebalancing_frequency?: boolean
    external_reference_code?: boolean
    tags_categories?: boolean
    created_at?: boolean
    updated_at?: boolean
    portfolio_master?: boolean | portfolio_master$portfolio_masterArgs<ExtArgs>
    other_portfolio_master?: boolean | portfolio_master$other_portfolio_masterArgs<ExtArgs>
    _count?: boolean | Portfolio_masterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio_master"]>



  export type portfolio_masterSelectScalar = {
    portfolio_id?: boolean
    portfolio_name?: boolean
    portfolio_type?: boolean
    entity_business_unit?: boolean
    fund_manager_user_id?: boolean
    base_currency?: boolean
    benchmark?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    risk_profile?: boolean
    investment_horizon?: boolean
    target_yield_return?: boolean
    compliance_rules_id?: boolean
    notes_description?: boolean
    parent_portfolio_id?: boolean
    valuation_method?: boolean
    accounting_treatment?: boolean
    rebalancing_frequency?: boolean
    external_reference_code?: boolean
    tags_categories?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type portfolio_masterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"portfolio_id" | "portfolio_name" | "portfolio_type" | "entity_business_unit" | "fund_manager_user_id" | "base_currency" | "benchmark" | "start_date" | "end_date" | "status" | "risk_profile" | "investment_horizon" | "target_yield_return" | "compliance_rules_id" | "notes_description" | "parent_portfolio_id" | "valuation_method" | "accounting_treatment" | "rebalancing_frequency" | "external_reference_code" | "tags_categories" | "created_at" | "updated_at", ExtArgs["result"]["portfolio_master"]>
  export type portfolio_masterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio_master?: boolean | portfolio_master$portfolio_masterArgs<ExtArgs>
    other_portfolio_master?: boolean | portfolio_master$other_portfolio_masterArgs<ExtArgs>
    _count?: boolean | Portfolio_masterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $portfolio_masterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "portfolio_master"
    objects: {
      portfolio_master: Prisma.$portfolio_masterPayload<ExtArgs> | null
      other_portfolio_master: Prisma.$portfolio_masterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      portfolio_id: string
      portfolio_name: string
      portfolio_type: string | null
      entity_business_unit: string | null
      fund_manager_user_id: string | null
      base_currency: string | null
      benchmark: string | null
      start_date: Date | null
      end_date: Date | null
      status: $Enums.portfolio_master_status | null
      risk_profile: $Enums.portfolio_master_risk_profile | null
      investment_horizon: $Enums.portfolio_master_investment_horizon | null
      target_yield_return: Prisma.Decimal | null
      compliance_rules_id: string | null
      notes_description: string | null
      parent_portfolio_id: string | null
      valuation_method: string | null
      accounting_treatment: string | null
      rebalancing_frequency: string | null
      external_reference_code: string | null
      tags_categories: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["portfolio_master"]>
    composites: {}
  }

  type portfolio_masterGetPayload<S extends boolean | null | undefined | portfolio_masterDefaultArgs> = $Result.GetResult<Prisma.$portfolio_masterPayload, S>

  type portfolio_masterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<portfolio_masterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Portfolio_masterCountAggregateInputType | true
    }

  export interface portfolio_masterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['portfolio_master'], meta: { name: 'portfolio_master' } }
    /**
     * Find zero or one Portfolio_master that matches the filter.
     * @param {portfolio_masterFindUniqueArgs} args - Arguments to find a Portfolio_master
     * @example
     * // Get one Portfolio_master
     * const portfolio_master = await prisma.portfolio_master.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends portfolio_masterFindUniqueArgs>(args: SelectSubset<T, portfolio_masterFindUniqueArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Portfolio_master that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {portfolio_masterFindUniqueOrThrowArgs} args - Arguments to find a Portfolio_master
     * @example
     * // Get one Portfolio_master
     * const portfolio_master = await prisma.portfolio_master.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends portfolio_masterFindUniqueOrThrowArgs>(args: SelectSubset<T, portfolio_masterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio_master that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_masterFindFirstArgs} args - Arguments to find a Portfolio_master
     * @example
     * // Get one Portfolio_master
     * const portfolio_master = await prisma.portfolio_master.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends portfolio_masterFindFirstArgs>(args?: SelectSubset<T, portfolio_masterFindFirstArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio_master that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_masterFindFirstOrThrowArgs} args - Arguments to find a Portfolio_master
     * @example
     * // Get one Portfolio_master
     * const portfolio_master = await prisma.portfolio_master.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends portfolio_masterFindFirstOrThrowArgs>(args?: SelectSubset<T, portfolio_masterFindFirstOrThrowArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Portfolio_masters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_masterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolio_masters
     * const portfolio_masters = await prisma.portfolio_master.findMany()
     * 
     * // Get first 10 Portfolio_masters
     * const portfolio_masters = await prisma.portfolio_master.findMany({ take: 10 })
     * 
     * // Only select the `portfolio_id`
     * const portfolio_masterWithPortfolio_idOnly = await prisma.portfolio_master.findMany({ select: { portfolio_id: true } })
     * 
     */
    findMany<T extends portfolio_masterFindManyArgs>(args?: SelectSubset<T, portfolio_masterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Portfolio_master.
     * @param {portfolio_masterCreateArgs} args - Arguments to create a Portfolio_master.
     * @example
     * // Create one Portfolio_master
     * const Portfolio_master = await prisma.portfolio_master.create({
     *   data: {
     *     // ... data to create a Portfolio_master
     *   }
     * })
     * 
     */
    create<T extends portfolio_masterCreateArgs>(args: SelectSubset<T, portfolio_masterCreateArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Portfolio_masters.
     * @param {portfolio_masterCreateManyArgs} args - Arguments to create many Portfolio_masters.
     * @example
     * // Create many Portfolio_masters
     * const portfolio_master = await prisma.portfolio_master.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends portfolio_masterCreateManyArgs>(args?: SelectSubset<T, portfolio_masterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Portfolio_master.
     * @param {portfolio_masterDeleteArgs} args - Arguments to delete one Portfolio_master.
     * @example
     * // Delete one Portfolio_master
     * const Portfolio_master = await prisma.portfolio_master.delete({
     *   where: {
     *     // ... filter to delete one Portfolio_master
     *   }
     * })
     * 
     */
    delete<T extends portfolio_masterDeleteArgs>(args: SelectSubset<T, portfolio_masterDeleteArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Portfolio_master.
     * @param {portfolio_masterUpdateArgs} args - Arguments to update one Portfolio_master.
     * @example
     * // Update one Portfolio_master
     * const portfolio_master = await prisma.portfolio_master.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends portfolio_masterUpdateArgs>(args: SelectSubset<T, portfolio_masterUpdateArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Portfolio_masters.
     * @param {portfolio_masterDeleteManyArgs} args - Arguments to filter Portfolio_masters to delete.
     * @example
     * // Delete a few Portfolio_masters
     * const { count } = await prisma.portfolio_master.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends portfolio_masterDeleteManyArgs>(args?: SelectSubset<T, portfolio_masterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolio_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_masterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolio_masters
     * const portfolio_master = await prisma.portfolio_master.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends portfolio_masterUpdateManyArgs>(args: SelectSubset<T, portfolio_masterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Portfolio_master.
     * @param {portfolio_masterUpsertArgs} args - Arguments to update or create a Portfolio_master.
     * @example
     * // Update or create a Portfolio_master
     * const portfolio_master = await prisma.portfolio_master.upsert({
     *   create: {
     *     // ... data to create a Portfolio_master
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio_master we want to update
     *   }
     * })
     */
    upsert<T extends portfolio_masterUpsertArgs>(args: SelectSubset<T, portfolio_masterUpsertArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Portfolio_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_masterCountArgs} args - Arguments to filter Portfolio_masters to count.
     * @example
     * // Count the number of Portfolio_masters
     * const count = await prisma.portfolio_master.count({
     *   where: {
     *     // ... the filter for the Portfolio_masters we want to count
     *   }
     * })
    **/
    count<T extends portfolio_masterCountArgs>(
      args?: Subset<T, portfolio_masterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Portfolio_masterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Portfolio_masterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Portfolio_masterAggregateArgs>(args: Subset<T, Portfolio_masterAggregateArgs>): Prisma.PrismaPromise<GetPortfolio_masterAggregateType<T>>

    /**
     * Group by Portfolio_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolio_masterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends portfolio_masterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: portfolio_masterGroupByArgs['orderBy'] }
        : { orderBy?: portfolio_masterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, portfolio_masterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolio_masterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the portfolio_master model
   */
  readonly fields: portfolio_masterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for portfolio_master.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__portfolio_masterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio_master<T extends portfolio_master$portfolio_masterArgs<ExtArgs> = {}>(args?: Subset<T, portfolio_master$portfolio_masterArgs<ExtArgs>>): Prisma__portfolio_masterClient<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_portfolio_master<T extends portfolio_master$other_portfolio_masterArgs<ExtArgs> = {}>(args?: Subset<T, portfolio_master$other_portfolio_masterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$portfolio_masterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the portfolio_master model
   */
  interface portfolio_masterFieldRefs {
    readonly portfolio_id: FieldRef<"portfolio_master", 'String'>
    readonly portfolio_name: FieldRef<"portfolio_master", 'String'>
    readonly portfolio_type: FieldRef<"portfolio_master", 'String'>
    readonly entity_business_unit: FieldRef<"portfolio_master", 'String'>
    readonly fund_manager_user_id: FieldRef<"portfolio_master", 'String'>
    readonly base_currency: FieldRef<"portfolio_master", 'String'>
    readonly benchmark: FieldRef<"portfolio_master", 'String'>
    readonly start_date: FieldRef<"portfolio_master", 'DateTime'>
    readonly end_date: FieldRef<"portfolio_master", 'DateTime'>
    readonly status: FieldRef<"portfolio_master", 'portfolio_master_status'>
    readonly risk_profile: FieldRef<"portfolio_master", 'portfolio_master_risk_profile'>
    readonly investment_horizon: FieldRef<"portfolio_master", 'portfolio_master_investment_horizon'>
    readonly target_yield_return: FieldRef<"portfolio_master", 'Decimal'>
    readonly compliance_rules_id: FieldRef<"portfolio_master", 'String'>
    readonly notes_description: FieldRef<"portfolio_master", 'String'>
    readonly parent_portfolio_id: FieldRef<"portfolio_master", 'String'>
    readonly valuation_method: FieldRef<"portfolio_master", 'String'>
    readonly accounting_treatment: FieldRef<"portfolio_master", 'String'>
    readonly rebalancing_frequency: FieldRef<"portfolio_master", 'String'>
    readonly external_reference_code: FieldRef<"portfolio_master", 'String'>
    readonly tags_categories: FieldRef<"portfolio_master", 'String'>
    readonly created_at: FieldRef<"portfolio_master", 'DateTime'>
    readonly updated_at: FieldRef<"portfolio_master", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * portfolio_master findUnique
   */
  export type portfolio_masterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * Filter, which portfolio_master to fetch.
     */
    where: portfolio_masterWhereUniqueInput
  }

  /**
   * portfolio_master findUniqueOrThrow
   */
  export type portfolio_masterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * Filter, which portfolio_master to fetch.
     */
    where: portfolio_masterWhereUniqueInput
  }

  /**
   * portfolio_master findFirst
   */
  export type portfolio_masterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * Filter, which portfolio_master to fetch.
     */
    where?: portfolio_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolio_masters to fetch.
     */
    orderBy?: portfolio_masterOrderByWithRelationInput | portfolio_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portfolio_masters.
     */
    cursor?: portfolio_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolio_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolio_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portfolio_masters.
     */
    distinct?: Portfolio_masterScalarFieldEnum | Portfolio_masterScalarFieldEnum[]
  }

  /**
   * portfolio_master findFirstOrThrow
   */
  export type portfolio_masterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * Filter, which portfolio_master to fetch.
     */
    where?: portfolio_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolio_masters to fetch.
     */
    orderBy?: portfolio_masterOrderByWithRelationInput | portfolio_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portfolio_masters.
     */
    cursor?: portfolio_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolio_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolio_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portfolio_masters.
     */
    distinct?: Portfolio_masterScalarFieldEnum | Portfolio_masterScalarFieldEnum[]
  }

  /**
   * portfolio_master findMany
   */
  export type portfolio_masterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * Filter, which portfolio_masters to fetch.
     */
    where?: portfolio_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolio_masters to fetch.
     */
    orderBy?: portfolio_masterOrderByWithRelationInput | portfolio_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing portfolio_masters.
     */
    cursor?: portfolio_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolio_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolio_masters.
     */
    skip?: number
    distinct?: Portfolio_masterScalarFieldEnum | Portfolio_masterScalarFieldEnum[]
  }

  /**
   * portfolio_master create
   */
  export type portfolio_masterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * The data needed to create a portfolio_master.
     */
    data: XOR<portfolio_masterCreateInput, portfolio_masterUncheckedCreateInput>
  }

  /**
   * portfolio_master createMany
   */
  export type portfolio_masterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many portfolio_masters.
     */
    data: portfolio_masterCreateManyInput | portfolio_masterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * portfolio_master update
   */
  export type portfolio_masterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * The data needed to update a portfolio_master.
     */
    data: XOR<portfolio_masterUpdateInput, portfolio_masterUncheckedUpdateInput>
    /**
     * Choose, which portfolio_master to update.
     */
    where: portfolio_masterWhereUniqueInput
  }

  /**
   * portfolio_master updateMany
   */
  export type portfolio_masterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update portfolio_masters.
     */
    data: XOR<portfolio_masterUpdateManyMutationInput, portfolio_masterUncheckedUpdateManyInput>
    /**
     * Filter which portfolio_masters to update
     */
    where?: portfolio_masterWhereInput
    /**
     * Limit how many portfolio_masters to update.
     */
    limit?: number
  }

  /**
   * portfolio_master upsert
   */
  export type portfolio_masterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * The filter to search for the portfolio_master to update in case it exists.
     */
    where: portfolio_masterWhereUniqueInput
    /**
     * In case the portfolio_master found by the `where` argument doesn't exist, create a new portfolio_master with this data.
     */
    create: XOR<portfolio_masterCreateInput, portfolio_masterUncheckedCreateInput>
    /**
     * In case the portfolio_master was found with the provided `where` argument, update it with this data.
     */
    update: XOR<portfolio_masterUpdateInput, portfolio_masterUncheckedUpdateInput>
  }

  /**
   * portfolio_master delete
   */
  export type portfolio_masterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    /**
     * Filter which portfolio_master to delete.
     */
    where: portfolio_masterWhereUniqueInput
  }

  /**
   * portfolio_master deleteMany
   */
  export type portfolio_masterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which portfolio_masters to delete
     */
    where?: portfolio_masterWhereInput
    /**
     * Limit how many portfolio_masters to delete.
     */
    limit?: number
  }

  /**
   * portfolio_master.portfolio_master
   */
  export type portfolio_master$portfolio_masterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    where?: portfolio_masterWhereInput
  }

  /**
   * portfolio_master.other_portfolio_master
   */
  export type portfolio_master$other_portfolio_masterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
    where?: portfolio_masterWhereInput
    orderBy?: portfolio_masterOrderByWithRelationInput | portfolio_masterOrderByWithRelationInput[]
    cursor?: portfolio_masterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Portfolio_masterScalarFieldEnum | Portfolio_masterScalarFieldEnum[]
  }

  /**
   * portfolio_master without action
   */
  export type portfolio_masterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolio_master
     */
    select?: portfolio_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the portfolio_master
     */
    omit?: portfolio_masterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolio_masterInclude<ExtArgs> | null
  }


  /**
   * Model securities
   */

  export type AggregateSecurities = {
    _count: SecuritiesCountAggregateOutputType | null
    _avg: SecuritiesAvgAggregateOutputType | null
    _sum: SecuritiesSumAggregateOutputType | null
    _min: SecuritiesMinAggregateOutputType | null
    _max: SecuritiesMaxAggregateOutputType | null
  }

  export type SecuritiesAvgAggregateOutputType = {
    id: number | null
  }

  export type SecuritiesSumAggregateOutputType = {
    id: number | null
  }

  export type SecuritiesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type SecuritiesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type SecuritiesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SecuritiesAvgAggregateInputType = {
    id?: true
  }

  export type SecuritiesSumAggregateInputType = {
    id?: true
  }

  export type SecuritiesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SecuritiesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SecuritiesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SecuritiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which securities to aggregate.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned securities
    **/
    _count?: true | SecuritiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecuritiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecuritiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritiesMaxAggregateInputType
  }

  export type GetSecuritiesAggregateType<T extends SecuritiesAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurities[P]>
      : GetScalarType<T[P], AggregateSecurities[P]>
  }




  export type securitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: securitiesWhereInput
    orderBy?: securitiesOrderByWithAggregationInput | securitiesOrderByWithAggregationInput[]
    by: SecuritiesScalarFieldEnum[] | SecuritiesScalarFieldEnum
    having?: securitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritiesCountAggregateInputType | true
    _avg?: SecuritiesAvgAggregateInputType
    _sum?: SecuritiesSumAggregateInputType
    _min?: SecuritiesMinAggregateInputType
    _max?: SecuritiesMaxAggregateInputType
  }

  export type SecuritiesGroupByOutputType = {
    id: number
    name: string
    _count: SecuritiesCountAggregateOutputType | null
    _avg: SecuritiesAvgAggregateOutputType | null
    _sum: SecuritiesSumAggregateOutputType | null
    _min: SecuritiesMinAggregateOutputType | null
    _max: SecuritiesMaxAggregateOutputType | null
  }

  type GetSecuritiesGroupByPayload<T extends securitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecuritiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritiesGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritiesGroupByOutputType[P]>
        }
      >
    >


  export type securitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["securities"]>



  export type securitiesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type securitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["securities"]>

  export type $securitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "securities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["securities"]>
    composites: {}
  }

  type securitiesGetPayload<S extends boolean | null | undefined | securitiesDefaultArgs> = $Result.GetResult<Prisma.$securitiesPayload, S>

  type securitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<securitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecuritiesCountAggregateInputType | true
    }

  export interface securitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['securities'], meta: { name: 'securities' } }
    /**
     * Find zero or one Securities that matches the filter.
     * @param {securitiesFindUniqueArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends securitiesFindUniqueArgs>(args: SelectSubset<T, securitiesFindUniqueArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Securities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {securitiesFindUniqueOrThrowArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends securitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, securitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Securities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesFindFirstArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends securitiesFindFirstArgs>(args?: SelectSubset<T, securitiesFindFirstArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Securities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesFindFirstOrThrowArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends securitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, securitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Securities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Securities
     * const securities = await prisma.securities.findMany()
     * 
     * // Get first 10 Securities
     * const securities = await prisma.securities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securitiesWithIdOnly = await prisma.securities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends securitiesFindManyArgs>(args?: SelectSubset<T, securitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Securities.
     * @param {securitiesCreateArgs} args - Arguments to create a Securities.
     * @example
     * // Create one Securities
     * const Securities = await prisma.securities.create({
     *   data: {
     *     // ... data to create a Securities
     *   }
     * })
     * 
     */
    create<T extends securitiesCreateArgs>(args: SelectSubset<T, securitiesCreateArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Securities.
     * @param {securitiesCreateManyArgs} args - Arguments to create many Securities.
     * @example
     * // Create many Securities
     * const securities = await prisma.securities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends securitiesCreateManyArgs>(args?: SelectSubset<T, securitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Securities.
     * @param {securitiesDeleteArgs} args - Arguments to delete one Securities.
     * @example
     * // Delete one Securities
     * const Securities = await prisma.securities.delete({
     *   where: {
     *     // ... filter to delete one Securities
     *   }
     * })
     * 
     */
    delete<T extends securitiesDeleteArgs>(args: SelectSubset<T, securitiesDeleteArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Securities.
     * @param {securitiesUpdateArgs} args - Arguments to update one Securities.
     * @example
     * // Update one Securities
     * const securities = await prisma.securities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends securitiesUpdateArgs>(args: SelectSubset<T, securitiesUpdateArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Securities.
     * @param {securitiesDeleteManyArgs} args - Arguments to filter Securities to delete.
     * @example
     * // Delete a few Securities
     * const { count } = await prisma.securities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends securitiesDeleteManyArgs>(args?: SelectSubset<T, securitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Securities
     * const securities = await prisma.securities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends securitiesUpdateManyArgs>(args: SelectSubset<T, securitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Securities.
     * @param {securitiesUpsertArgs} args - Arguments to update or create a Securities.
     * @example
     * // Update or create a Securities
     * const securities = await prisma.securities.upsert({
     *   create: {
     *     // ... data to create a Securities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Securities we want to update
     *   }
     * })
     */
    upsert<T extends securitiesUpsertArgs>(args: SelectSubset<T, securitiesUpsertArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesCountArgs} args - Arguments to filter Securities to count.
     * @example
     * // Count the number of Securities
     * const count = await prisma.securities.count({
     *   where: {
     *     // ... the filter for the Securities we want to count
     *   }
     * })
    **/
    count<T extends securitiesCountArgs>(
      args?: Subset<T, securitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritiesAggregateArgs>(args: Subset<T, SecuritiesAggregateArgs>): Prisma.PrismaPromise<GetSecuritiesAggregateType<T>>

    /**
     * Group by Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends securitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: securitiesGroupByArgs['orderBy'] }
        : { orderBy?: securitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, securitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the securities model
   */
  readonly fields: securitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for securities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__securitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the securities model
   */
  interface securitiesFieldRefs {
    readonly id: FieldRef<"securities", 'Int'>
    readonly name: FieldRef<"securities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * securities findUnique
   */
  export type securitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities findUniqueOrThrow
   */
  export type securitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities findFirst
   */
  export type securitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for securities.
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of securities.
     */
    distinct?: SecuritiesScalarFieldEnum | SecuritiesScalarFieldEnum[]
  }

  /**
   * securities findFirstOrThrow
   */
  export type securitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for securities.
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of securities.
     */
    distinct?: SecuritiesScalarFieldEnum | SecuritiesScalarFieldEnum[]
  }

  /**
   * securities findMany
   */
  export type securitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing securities.
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    distinct?: SecuritiesScalarFieldEnum | SecuritiesScalarFieldEnum[]
  }

  /**
   * securities create
   */
  export type securitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * The data needed to create a securities.
     */
    data: XOR<securitiesCreateInput, securitiesUncheckedCreateInput>
  }

  /**
   * securities createMany
   */
  export type securitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many securities.
     */
    data: securitiesCreateManyInput | securitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * securities update
   */
  export type securitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * The data needed to update a securities.
     */
    data: XOR<securitiesUpdateInput, securitiesUncheckedUpdateInput>
    /**
     * Choose, which securities to update.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities updateMany
   */
  export type securitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update securities.
     */
    data: XOR<securitiesUpdateManyMutationInput, securitiesUncheckedUpdateManyInput>
    /**
     * Filter which securities to update
     */
    where?: securitiesWhereInput
    /**
     * Limit how many securities to update.
     */
    limit?: number
  }

  /**
   * securities upsert
   */
  export type securitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * The filter to search for the securities to update in case it exists.
     */
    where: securitiesWhereUniqueInput
    /**
     * In case the securities found by the `where` argument doesn't exist, create a new securities with this data.
     */
    create: XOR<securitiesCreateInput, securitiesUncheckedCreateInput>
    /**
     * In case the securities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<securitiesUpdateInput, securitiesUncheckedUpdateInput>
  }

  /**
   * securities delete
   */
  export type securitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Filter which securities to delete.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities deleteMany
   */
  export type securitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which securities to delete
     */
    where?: securitiesWhereInput
    /**
     * Limit how many securities to delete.
     */
    limit?: number
  }

  /**
   * securities without action
   */
  export type securitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
  }


  /**
   * Model settlement_accounts
   */

  export type AggregateSettlement_accounts = {
    _count: Settlement_accountsCountAggregateOutputType | null
    _avg: Settlement_accountsAvgAggregateOutputType | null
    _sum: Settlement_accountsSumAggregateOutputType | null
    _min: Settlement_accountsMinAggregateOutputType | null
    _max: Settlement_accountsMaxAggregateOutputType | null
  }

  export type Settlement_accountsAvgAggregateOutputType = {
    id: number | null
  }

  export type Settlement_accountsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Settlement_accountsMinAggregateOutputType = {
    id: bigint | null
    bank_name: string | null
    bank_payment_code: string | null
    bank_code: string | null
    address_building_number: string | null
    address_street_name: string | null
    address_street_name2: string | null
    address_city: string | null
    address_province: string | null
    address_zip_code: string | null
    address_country: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_mobile: string | null
    contact_fax: string | null
    contact_email: string | null
    account_type: string | null
    bank_account_number: string | null
    bank_branch: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Settlement_accountsMaxAggregateOutputType = {
    id: bigint | null
    bank_name: string | null
    bank_payment_code: string | null
    bank_code: string | null
    address_building_number: string | null
    address_street_name: string | null
    address_street_name2: string | null
    address_city: string | null
    address_province: string | null
    address_zip_code: string | null
    address_country: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_mobile: string | null
    contact_fax: string | null
    contact_email: string | null
    account_type: string | null
    bank_account_number: string | null
    bank_branch: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Settlement_accountsCountAggregateOutputType = {
    id: number
    bank_name: number
    bank_payment_code: number
    bank_code: number
    address_building_number: number
    address_street_name: number
    address_street_name2: number
    address_city: number
    address_province: number
    address_zip_code: number
    address_country: number
    contact_name: number
    contact_phone: number
    contact_mobile: number
    contact_fax: number
    contact_email: number
    account_type: number
    bank_account_number: number
    bank_branch: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Settlement_accountsAvgAggregateInputType = {
    id?: true
  }

  export type Settlement_accountsSumAggregateInputType = {
    id?: true
  }

  export type Settlement_accountsMinAggregateInputType = {
    id?: true
    bank_name?: true
    bank_payment_code?: true
    bank_code?: true
    address_building_number?: true
    address_street_name?: true
    address_street_name2?: true
    address_city?: true
    address_province?: true
    address_zip_code?: true
    address_country?: true
    contact_name?: true
    contact_phone?: true
    contact_mobile?: true
    contact_fax?: true
    contact_email?: true
    account_type?: true
    bank_account_number?: true
    bank_branch?: true
    created_at?: true
    updated_at?: true
  }

  export type Settlement_accountsMaxAggregateInputType = {
    id?: true
    bank_name?: true
    bank_payment_code?: true
    bank_code?: true
    address_building_number?: true
    address_street_name?: true
    address_street_name2?: true
    address_city?: true
    address_province?: true
    address_zip_code?: true
    address_country?: true
    contact_name?: true
    contact_phone?: true
    contact_mobile?: true
    contact_fax?: true
    contact_email?: true
    account_type?: true
    bank_account_number?: true
    bank_branch?: true
    created_at?: true
    updated_at?: true
  }

  export type Settlement_accountsCountAggregateInputType = {
    id?: true
    bank_name?: true
    bank_payment_code?: true
    bank_code?: true
    address_building_number?: true
    address_street_name?: true
    address_street_name2?: true
    address_city?: true
    address_province?: true
    address_zip_code?: true
    address_country?: true
    contact_name?: true
    contact_phone?: true
    contact_mobile?: true
    contact_fax?: true
    contact_email?: true
    account_type?: true
    bank_account_number?: true
    bank_branch?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Settlement_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settlement_accounts to aggregate.
     */
    where?: settlement_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlement_accounts to fetch.
     */
    orderBy?: settlement_accountsOrderByWithRelationInput | settlement_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settlement_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlement_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlement_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settlement_accounts
    **/
    _count?: true | Settlement_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Settlement_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Settlement_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Settlement_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Settlement_accountsMaxAggregateInputType
  }

  export type GetSettlement_accountsAggregateType<T extends Settlement_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlement_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlement_accounts[P]>
      : GetScalarType<T[P], AggregateSettlement_accounts[P]>
  }




  export type settlement_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settlement_accountsWhereInput
    orderBy?: settlement_accountsOrderByWithAggregationInput | settlement_accountsOrderByWithAggregationInput[]
    by: Settlement_accountsScalarFieldEnum[] | Settlement_accountsScalarFieldEnum
    having?: settlement_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Settlement_accountsCountAggregateInputType | true
    _avg?: Settlement_accountsAvgAggregateInputType
    _sum?: Settlement_accountsSumAggregateInputType
    _min?: Settlement_accountsMinAggregateInputType
    _max?: Settlement_accountsMaxAggregateInputType
  }

  export type Settlement_accountsGroupByOutputType = {
    id: bigint
    bank_name: string
    bank_payment_code: string | null
    bank_code: string | null
    address_building_number: string | null
    address_street_name: string | null
    address_street_name2: string | null
    address_city: string | null
    address_province: string | null
    address_zip_code: string | null
    address_country: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_mobile: string | null
    contact_fax: string | null
    contact_email: string | null
    account_type: string | null
    bank_account_number: string | null
    bank_branch: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Settlement_accountsCountAggregateOutputType | null
    _avg: Settlement_accountsAvgAggregateOutputType | null
    _sum: Settlement_accountsSumAggregateOutputType | null
    _min: Settlement_accountsMinAggregateOutputType | null
    _max: Settlement_accountsMaxAggregateOutputType | null
  }

  type GetSettlement_accountsGroupByPayload<T extends settlement_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Settlement_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Settlement_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Settlement_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Settlement_accountsGroupByOutputType[P]>
        }
      >
    >


  export type settlement_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_name?: boolean
    bank_payment_code?: boolean
    bank_code?: boolean
    address_building_number?: boolean
    address_street_name?: boolean
    address_street_name2?: boolean
    address_city?: boolean
    address_province?: boolean
    address_zip_code?: boolean
    address_country?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    contact_mobile?: boolean
    contact_fax?: boolean
    contact_email?: boolean
    account_type?: boolean
    bank_account_number?: boolean
    bank_branch?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settlement_accounts"]>



  export type settlement_accountsSelectScalar = {
    id?: boolean
    bank_name?: boolean
    bank_payment_code?: boolean
    bank_code?: boolean
    address_building_number?: boolean
    address_street_name?: boolean
    address_street_name2?: boolean
    address_city?: boolean
    address_province?: boolean
    address_zip_code?: boolean
    address_country?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    contact_mobile?: boolean
    contact_fax?: boolean
    contact_email?: boolean
    account_type?: boolean
    bank_account_number?: boolean
    bank_branch?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type settlement_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bank_name" | "bank_payment_code" | "bank_code" | "address_building_number" | "address_street_name" | "address_street_name2" | "address_city" | "address_province" | "address_zip_code" | "address_country" | "contact_name" | "contact_phone" | "contact_mobile" | "contact_fax" | "contact_email" | "account_type" | "bank_account_number" | "bank_branch" | "created_at" | "updated_at", ExtArgs["result"]["settlement_accounts"]>

  export type $settlement_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settlement_accounts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      bank_name: string
      bank_payment_code: string | null
      bank_code: string | null
      address_building_number: string | null
      address_street_name: string | null
      address_street_name2: string | null
      address_city: string | null
      address_province: string | null
      address_zip_code: string | null
      address_country: string | null
      contact_name: string | null
      contact_phone: string | null
      contact_mobile: string | null
      contact_fax: string | null
      contact_email: string | null
      account_type: string | null
      bank_account_number: string | null
      bank_branch: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["settlement_accounts"]>
    composites: {}
  }

  type settlement_accountsGetPayload<S extends boolean | null | undefined | settlement_accountsDefaultArgs> = $Result.GetResult<Prisma.$settlement_accountsPayload, S>

  type settlement_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settlement_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Settlement_accountsCountAggregateInputType | true
    }

  export interface settlement_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settlement_accounts'], meta: { name: 'settlement_accounts' } }
    /**
     * Find zero or one Settlement_accounts that matches the filter.
     * @param {settlement_accountsFindUniqueArgs} args - Arguments to find a Settlement_accounts
     * @example
     * // Get one Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settlement_accountsFindUniqueArgs>(args: SelectSubset<T, settlement_accountsFindUniqueArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settlement_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settlement_accountsFindUniqueOrThrowArgs} args - Arguments to find a Settlement_accounts
     * @example
     * // Get one Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settlement_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, settlement_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlement_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlement_accountsFindFirstArgs} args - Arguments to find a Settlement_accounts
     * @example
     * // Get one Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settlement_accountsFindFirstArgs>(args?: SelectSubset<T, settlement_accountsFindFirstArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlement_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlement_accountsFindFirstOrThrowArgs} args - Arguments to find a Settlement_accounts
     * @example
     * // Get one Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settlement_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, settlement_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settlement_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlement_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.findMany()
     * 
     * // Get first 10 Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlement_accountsWithIdOnly = await prisma.settlement_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends settlement_accountsFindManyArgs>(args?: SelectSubset<T, settlement_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settlement_accounts.
     * @param {settlement_accountsCreateArgs} args - Arguments to create a Settlement_accounts.
     * @example
     * // Create one Settlement_accounts
     * const Settlement_accounts = await prisma.settlement_accounts.create({
     *   data: {
     *     // ... data to create a Settlement_accounts
     *   }
     * })
     * 
     */
    create<T extends settlement_accountsCreateArgs>(args: SelectSubset<T, settlement_accountsCreateArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settlement_accounts.
     * @param {settlement_accountsCreateManyArgs} args - Arguments to create many Settlement_accounts.
     * @example
     * // Create many Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settlement_accountsCreateManyArgs>(args?: SelectSubset<T, settlement_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settlement_accounts.
     * @param {settlement_accountsDeleteArgs} args - Arguments to delete one Settlement_accounts.
     * @example
     * // Delete one Settlement_accounts
     * const Settlement_accounts = await prisma.settlement_accounts.delete({
     *   where: {
     *     // ... filter to delete one Settlement_accounts
     *   }
     * })
     * 
     */
    delete<T extends settlement_accountsDeleteArgs>(args: SelectSubset<T, settlement_accountsDeleteArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settlement_accounts.
     * @param {settlement_accountsUpdateArgs} args - Arguments to update one Settlement_accounts.
     * @example
     * // Update one Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settlement_accountsUpdateArgs>(args: SelectSubset<T, settlement_accountsUpdateArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settlement_accounts.
     * @param {settlement_accountsDeleteManyArgs} args - Arguments to filter Settlement_accounts to delete.
     * @example
     * // Delete a few Settlement_accounts
     * const { count } = await prisma.settlement_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settlement_accountsDeleteManyArgs>(args?: SelectSubset<T, settlement_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlement_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlement_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settlement_accountsUpdateManyArgs>(args: SelectSubset<T, settlement_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settlement_accounts.
     * @param {settlement_accountsUpsertArgs} args - Arguments to update or create a Settlement_accounts.
     * @example
     * // Update or create a Settlement_accounts
     * const settlement_accounts = await prisma.settlement_accounts.upsert({
     *   create: {
     *     // ... data to create a Settlement_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settlement_accounts we want to update
     *   }
     * })
     */
    upsert<T extends settlement_accountsUpsertArgs>(args: SelectSubset<T, settlement_accountsUpsertArgs<ExtArgs>>): Prisma__settlement_accountsClient<$Result.GetResult<Prisma.$settlement_accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settlement_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlement_accountsCountArgs} args - Arguments to filter Settlement_accounts to count.
     * @example
     * // Count the number of Settlement_accounts
     * const count = await prisma.settlement_accounts.count({
     *   where: {
     *     // ... the filter for the Settlement_accounts we want to count
     *   }
     * })
    **/
    count<T extends settlement_accountsCountArgs>(
      args?: Subset<T, settlement_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Settlement_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settlement_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Settlement_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Settlement_accountsAggregateArgs>(args: Subset<T, Settlement_accountsAggregateArgs>): Prisma.PrismaPromise<GetSettlement_accountsAggregateType<T>>

    /**
     * Group by Settlement_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settlement_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settlement_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settlement_accountsGroupByArgs['orderBy'] }
        : { orderBy?: settlement_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settlement_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlement_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settlement_accounts model
   */
  readonly fields: settlement_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settlement_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settlement_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settlement_accounts model
   */
  interface settlement_accountsFieldRefs {
    readonly id: FieldRef<"settlement_accounts", 'BigInt'>
    readonly bank_name: FieldRef<"settlement_accounts", 'String'>
    readonly bank_payment_code: FieldRef<"settlement_accounts", 'String'>
    readonly bank_code: FieldRef<"settlement_accounts", 'String'>
    readonly address_building_number: FieldRef<"settlement_accounts", 'String'>
    readonly address_street_name: FieldRef<"settlement_accounts", 'String'>
    readonly address_street_name2: FieldRef<"settlement_accounts", 'String'>
    readonly address_city: FieldRef<"settlement_accounts", 'String'>
    readonly address_province: FieldRef<"settlement_accounts", 'String'>
    readonly address_zip_code: FieldRef<"settlement_accounts", 'String'>
    readonly address_country: FieldRef<"settlement_accounts", 'String'>
    readonly contact_name: FieldRef<"settlement_accounts", 'String'>
    readonly contact_phone: FieldRef<"settlement_accounts", 'String'>
    readonly contact_mobile: FieldRef<"settlement_accounts", 'String'>
    readonly contact_fax: FieldRef<"settlement_accounts", 'String'>
    readonly contact_email: FieldRef<"settlement_accounts", 'String'>
    readonly account_type: FieldRef<"settlement_accounts", 'String'>
    readonly bank_account_number: FieldRef<"settlement_accounts", 'String'>
    readonly bank_branch: FieldRef<"settlement_accounts", 'String'>
    readonly created_at: FieldRef<"settlement_accounts", 'DateTime'>
    readonly updated_at: FieldRef<"settlement_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * settlement_accounts findUnique
   */
  export type settlement_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * Filter, which settlement_accounts to fetch.
     */
    where: settlement_accountsWhereUniqueInput
  }

  /**
   * settlement_accounts findUniqueOrThrow
   */
  export type settlement_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * Filter, which settlement_accounts to fetch.
     */
    where: settlement_accountsWhereUniqueInput
  }

  /**
   * settlement_accounts findFirst
   */
  export type settlement_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * Filter, which settlement_accounts to fetch.
     */
    where?: settlement_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlement_accounts to fetch.
     */
    orderBy?: settlement_accountsOrderByWithRelationInput | settlement_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settlement_accounts.
     */
    cursor?: settlement_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlement_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlement_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settlement_accounts.
     */
    distinct?: Settlement_accountsScalarFieldEnum | Settlement_accountsScalarFieldEnum[]
  }

  /**
   * settlement_accounts findFirstOrThrow
   */
  export type settlement_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * Filter, which settlement_accounts to fetch.
     */
    where?: settlement_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlement_accounts to fetch.
     */
    orderBy?: settlement_accountsOrderByWithRelationInput | settlement_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settlement_accounts.
     */
    cursor?: settlement_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlement_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlement_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settlement_accounts.
     */
    distinct?: Settlement_accountsScalarFieldEnum | Settlement_accountsScalarFieldEnum[]
  }

  /**
   * settlement_accounts findMany
   */
  export type settlement_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * Filter, which settlement_accounts to fetch.
     */
    where?: settlement_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settlement_accounts to fetch.
     */
    orderBy?: settlement_accountsOrderByWithRelationInput | settlement_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settlement_accounts.
     */
    cursor?: settlement_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settlement_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settlement_accounts.
     */
    skip?: number
    distinct?: Settlement_accountsScalarFieldEnum | Settlement_accountsScalarFieldEnum[]
  }

  /**
   * settlement_accounts create
   */
  export type settlement_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * The data needed to create a settlement_accounts.
     */
    data: XOR<settlement_accountsCreateInput, settlement_accountsUncheckedCreateInput>
  }

  /**
   * settlement_accounts createMany
   */
  export type settlement_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settlement_accounts.
     */
    data: settlement_accountsCreateManyInput | settlement_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settlement_accounts update
   */
  export type settlement_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * The data needed to update a settlement_accounts.
     */
    data: XOR<settlement_accountsUpdateInput, settlement_accountsUncheckedUpdateInput>
    /**
     * Choose, which settlement_accounts to update.
     */
    where: settlement_accountsWhereUniqueInput
  }

  /**
   * settlement_accounts updateMany
   */
  export type settlement_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settlement_accounts.
     */
    data: XOR<settlement_accountsUpdateManyMutationInput, settlement_accountsUncheckedUpdateManyInput>
    /**
     * Filter which settlement_accounts to update
     */
    where?: settlement_accountsWhereInput
    /**
     * Limit how many settlement_accounts to update.
     */
    limit?: number
  }

  /**
   * settlement_accounts upsert
   */
  export type settlement_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * The filter to search for the settlement_accounts to update in case it exists.
     */
    where: settlement_accountsWhereUniqueInput
    /**
     * In case the settlement_accounts found by the `where` argument doesn't exist, create a new settlement_accounts with this data.
     */
    create: XOR<settlement_accountsCreateInput, settlement_accountsUncheckedCreateInput>
    /**
     * In case the settlement_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settlement_accountsUpdateInput, settlement_accountsUncheckedUpdateInput>
  }

  /**
   * settlement_accounts delete
   */
  export type settlement_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
    /**
     * Filter which settlement_accounts to delete.
     */
    where: settlement_accountsWhereUniqueInput
  }

  /**
   * settlement_accounts deleteMany
   */
  export type settlement_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settlement_accounts to delete
     */
    where?: settlement_accountsWhereInput
    /**
     * Limit how many settlement_accounts to delete.
     */
    limit?: number
  }

  /**
   * settlement_accounts without action
   */
  export type settlement_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settlement_accounts
     */
    select?: settlement_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settlement_accounts
     */
    omit?: settlement_accountsOmit<ExtArgs> | null
  }


  /**
   * Model strategy_master
   */

  export type AggregateStrategy_master = {
    _count: Strategy_masterCountAggregateOutputType | null
    _min: Strategy_masterMinAggregateOutputType | null
    _max: Strategy_masterMaxAggregateOutputType | null
  }

  export type Strategy_masterMinAggregateOutputType = {
    strategy_id: string | null
    portfolio_name: string | null
    strategy_type: string | null
    entity_business_unit: string | null
  }

  export type Strategy_masterMaxAggregateOutputType = {
    strategy_id: string | null
    portfolio_name: string | null
    strategy_type: string | null
    entity_business_unit: string | null
  }

  export type Strategy_masterCountAggregateOutputType = {
    strategy_id: number
    portfolio_name: number
    strategy_type: number
    entity_business_unit: number
    _all: number
  }


  export type Strategy_masterMinAggregateInputType = {
    strategy_id?: true
    portfolio_name?: true
    strategy_type?: true
    entity_business_unit?: true
  }

  export type Strategy_masterMaxAggregateInputType = {
    strategy_id?: true
    portfolio_name?: true
    strategy_type?: true
    entity_business_unit?: true
  }

  export type Strategy_masterCountAggregateInputType = {
    strategy_id?: true
    portfolio_name?: true
    strategy_type?: true
    entity_business_unit?: true
    _all?: true
  }

  export type Strategy_masterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which strategy_master to aggregate.
     */
    where?: strategy_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_masters to fetch.
     */
    orderBy?: strategy_masterOrderByWithRelationInput | strategy_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: strategy_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned strategy_masters
    **/
    _count?: true | Strategy_masterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Strategy_masterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Strategy_masterMaxAggregateInputType
  }

  export type GetStrategy_masterAggregateType<T extends Strategy_masterAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategy_master]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategy_master[P]>
      : GetScalarType<T[P], AggregateStrategy_master[P]>
  }




  export type strategy_masterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: strategy_masterWhereInput
    orderBy?: strategy_masterOrderByWithAggregationInput | strategy_masterOrderByWithAggregationInput[]
    by: Strategy_masterScalarFieldEnum[] | Strategy_masterScalarFieldEnum
    having?: strategy_masterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Strategy_masterCountAggregateInputType | true
    _min?: Strategy_masterMinAggregateInputType
    _max?: Strategy_masterMaxAggregateInputType
  }

  export type Strategy_masterGroupByOutputType = {
    strategy_id: string
    portfolio_name: string
    strategy_type: string | null
    entity_business_unit: string | null
    _count: Strategy_masterCountAggregateOutputType | null
    _min: Strategy_masterMinAggregateOutputType | null
    _max: Strategy_masterMaxAggregateOutputType | null
  }

  type GetStrategy_masterGroupByPayload<T extends strategy_masterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Strategy_masterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Strategy_masterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Strategy_masterGroupByOutputType[P]>
            : GetScalarType<T[P], Strategy_masterGroupByOutputType[P]>
        }
      >
    >


  export type strategy_masterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    strategy_id?: boolean
    portfolio_name?: boolean
    strategy_type?: boolean
    entity_business_unit?: boolean
  }, ExtArgs["result"]["strategy_master"]>



  export type strategy_masterSelectScalar = {
    strategy_id?: boolean
    portfolio_name?: boolean
    strategy_type?: boolean
    entity_business_unit?: boolean
  }

  export type strategy_masterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"strategy_id" | "portfolio_name" | "strategy_type" | "entity_business_unit", ExtArgs["result"]["strategy_master"]>

  export type $strategy_masterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "strategy_master"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      strategy_id: string
      portfolio_name: string
      strategy_type: string | null
      entity_business_unit: string | null
    }, ExtArgs["result"]["strategy_master"]>
    composites: {}
  }

  type strategy_masterGetPayload<S extends boolean | null | undefined | strategy_masterDefaultArgs> = $Result.GetResult<Prisma.$strategy_masterPayload, S>

  type strategy_masterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<strategy_masterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Strategy_masterCountAggregateInputType | true
    }

  export interface strategy_masterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['strategy_master'], meta: { name: 'strategy_master' } }
    /**
     * Find zero or one Strategy_master that matches the filter.
     * @param {strategy_masterFindUniqueArgs} args - Arguments to find a Strategy_master
     * @example
     * // Get one Strategy_master
     * const strategy_master = await prisma.strategy_master.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends strategy_masterFindUniqueArgs>(args: SelectSubset<T, strategy_masterFindUniqueArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Strategy_master that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {strategy_masterFindUniqueOrThrowArgs} args - Arguments to find a Strategy_master
     * @example
     * // Get one Strategy_master
     * const strategy_master = await prisma.strategy_master.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends strategy_masterFindUniqueOrThrowArgs>(args: SelectSubset<T, strategy_masterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strategy_master that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_masterFindFirstArgs} args - Arguments to find a Strategy_master
     * @example
     * // Get one Strategy_master
     * const strategy_master = await prisma.strategy_master.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends strategy_masterFindFirstArgs>(args?: SelectSubset<T, strategy_masterFindFirstArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strategy_master that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_masterFindFirstOrThrowArgs} args - Arguments to find a Strategy_master
     * @example
     * // Get one Strategy_master
     * const strategy_master = await prisma.strategy_master.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends strategy_masterFindFirstOrThrowArgs>(args?: SelectSubset<T, strategy_masterFindFirstOrThrowArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Strategy_masters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_masterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strategy_masters
     * const strategy_masters = await prisma.strategy_master.findMany()
     * 
     * // Get first 10 Strategy_masters
     * const strategy_masters = await prisma.strategy_master.findMany({ take: 10 })
     * 
     * // Only select the `strategy_id`
     * const strategy_masterWithStrategy_idOnly = await prisma.strategy_master.findMany({ select: { strategy_id: true } })
     * 
     */
    findMany<T extends strategy_masterFindManyArgs>(args?: SelectSubset<T, strategy_masterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Strategy_master.
     * @param {strategy_masterCreateArgs} args - Arguments to create a Strategy_master.
     * @example
     * // Create one Strategy_master
     * const Strategy_master = await prisma.strategy_master.create({
     *   data: {
     *     // ... data to create a Strategy_master
     *   }
     * })
     * 
     */
    create<T extends strategy_masterCreateArgs>(args: SelectSubset<T, strategy_masterCreateArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Strategy_masters.
     * @param {strategy_masterCreateManyArgs} args - Arguments to create many Strategy_masters.
     * @example
     * // Create many Strategy_masters
     * const strategy_master = await prisma.strategy_master.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends strategy_masterCreateManyArgs>(args?: SelectSubset<T, strategy_masterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Strategy_master.
     * @param {strategy_masterDeleteArgs} args - Arguments to delete one Strategy_master.
     * @example
     * // Delete one Strategy_master
     * const Strategy_master = await prisma.strategy_master.delete({
     *   where: {
     *     // ... filter to delete one Strategy_master
     *   }
     * })
     * 
     */
    delete<T extends strategy_masterDeleteArgs>(args: SelectSubset<T, strategy_masterDeleteArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Strategy_master.
     * @param {strategy_masterUpdateArgs} args - Arguments to update one Strategy_master.
     * @example
     * // Update one Strategy_master
     * const strategy_master = await prisma.strategy_master.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends strategy_masterUpdateArgs>(args: SelectSubset<T, strategy_masterUpdateArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Strategy_masters.
     * @param {strategy_masterDeleteManyArgs} args - Arguments to filter Strategy_masters to delete.
     * @example
     * // Delete a few Strategy_masters
     * const { count } = await prisma.strategy_master.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends strategy_masterDeleteManyArgs>(args?: SelectSubset<T, strategy_masterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strategy_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_masterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strategy_masters
     * const strategy_master = await prisma.strategy_master.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends strategy_masterUpdateManyArgs>(args: SelectSubset<T, strategy_masterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Strategy_master.
     * @param {strategy_masterUpsertArgs} args - Arguments to update or create a Strategy_master.
     * @example
     * // Update or create a Strategy_master
     * const strategy_master = await prisma.strategy_master.upsert({
     *   create: {
     *     // ... data to create a Strategy_master
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strategy_master we want to update
     *   }
     * })
     */
    upsert<T extends strategy_masterUpsertArgs>(args: SelectSubset<T, strategy_masterUpsertArgs<ExtArgs>>): Prisma__strategy_masterClient<$Result.GetResult<Prisma.$strategy_masterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Strategy_masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_masterCountArgs} args - Arguments to filter Strategy_masters to count.
     * @example
     * // Count the number of Strategy_masters
     * const count = await prisma.strategy_master.count({
     *   where: {
     *     // ... the filter for the Strategy_masters we want to count
     *   }
     * })
    **/
    count<T extends strategy_masterCountArgs>(
      args?: Subset<T, strategy_masterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Strategy_masterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strategy_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strategy_masterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Strategy_masterAggregateArgs>(args: Subset<T, Strategy_masterAggregateArgs>): Prisma.PrismaPromise<GetStrategy_masterAggregateType<T>>

    /**
     * Group by Strategy_master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_masterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends strategy_masterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: strategy_masterGroupByArgs['orderBy'] }
        : { orderBy?: strategy_masterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, strategy_masterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategy_masterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the strategy_master model
   */
  readonly fields: strategy_masterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for strategy_master.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__strategy_masterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the strategy_master model
   */
  interface strategy_masterFieldRefs {
    readonly strategy_id: FieldRef<"strategy_master", 'String'>
    readonly portfolio_name: FieldRef<"strategy_master", 'String'>
    readonly strategy_type: FieldRef<"strategy_master", 'String'>
    readonly entity_business_unit: FieldRef<"strategy_master", 'String'>
  }
    

  // Custom InputTypes
  /**
   * strategy_master findUnique
   */
  export type strategy_masterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * Filter, which strategy_master to fetch.
     */
    where: strategy_masterWhereUniqueInput
  }

  /**
   * strategy_master findUniqueOrThrow
   */
  export type strategy_masterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * Filter, which strategy_master to fetch.
     */
    where: strategy_masterWhereUniqueInput
  }

  /**
   * strategy_master findFirst
   */
  export type strategy_masterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * Filter, which strategy_master to fetch.
     */
    where?: strategy_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_masters to fetch.
     */
    orderBy?: strategy_masterOrderByWithRelationInput | strategy_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for strategy_masters.
     */
    cursor?: strategy_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of strategy_masters.
     */
    distinct?: Strategy_masterScalarFieldEnum | Strategy_masterScalarFieldEnum[]
  }

  /**
   * strategy_master findFirstOrThrow
   */
  export type strategy_masterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * Filter, which strategy_master to fetch.
     */
    where?: strategy_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_masters to fetch.
     */
    orderBy?: strategy_masterOrderByWithRelationInput | strategy_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for strategy_masters.
     */
    cursor?: strategy_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of strategy_masters.
     */
    distinct?: Strategy_masterScalarFieldEnum | Strategy_masterScalarFieldEnum[]
  }

  /**
   * strategy_master findMany
   */
  export type strategy_masterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * Filter, which strategy_masters to fetch.
     */
    where?: strategy_masterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_masters to fetch.
     */
    orderBy?: strategy_masterOrderByWithRelationInput | strategy_masterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing strategy_masters.
     */
    cursor?: strategy_masterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_masters.
     */
    skip?: number
    distinct?: Strategy_masterScalarFieldEnum | Strategy_masterScalarFieldEnum[]
  }

  /**
   * strategy_master create
   */
  export type strategy_masterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * The data needed to create a strategy_master.
     */
    data: XOR<strategy_masterCreateInput, strategy_masterUncheckedCreateInput>
  }

  /**
   * strategy_master createMany
   */
  export type strategy_masterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many strategy_masters.
     */
    data: strategy_masterCreateManyInput | strategy_masterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * strategy_master update
   */
  export type strategy_masterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * The data needed to update a strategy_master.
     */
    data: XOR<strategy_masterUpdateInput, strategy_masterUncheckedUpdateInput>
    /**
     * Choose, which strategy_master to update.
     */
    where: strategy_masterWhereUniqueInput
  }

  /**
   * strategy_master updateMany
   */
  export type strategy_masterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update strategy_masters.
     */
    data: XOR<strategy_masterUpdateManyMutationInput, strategy_masterUncheckedUpdateManyInput>
    /**
     * Filter which strategy_masters to update
     */
    where?: strategy_masterWhereInput
    /**
     * Limit how many strategy_masters to update.
     */
    limit?: number
  }

  /**
   * strategy_master upsert
   */
  export type strategy_masterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * The filter to search for the strategy_master to update in case it exists.
     */
    where: strategy_masterWhereUniqueInput
    /**
     * In case the strategy_master found by the `where` argument doesn't exist, create a new strategy_master with this data.
     */
    create: XOR<strategy_masterCreateInput, strategy_masterUncheckedCreateInput>
    /**
     * In case the strategy_master was found with the provided `where` argument, update it with this data.
     */
    update: XOR<strategy_masterUpdateInput, strategy_masterUncheckedUpdateInput>
  }

  /**
   * strategy_master delete
   */
  export type strategy_masterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
    /**
     * Filter which strategy_master to delete.
     */
    where: strategy_masterWhereUniqueInput
  }

  /**
   * strategy_master deleteMany
   */
  export type strategy_masterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which strategy_masters to delete
     */
    where?: strategy_masterWhereInput
    /**
     * Limit how many strategy_masters to delete.
     */
    limit?: number
  }

  /**
   * strategy_master without action
   */
  export type strategy_masterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_master
     */
    select?: strategy_masterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the strategy_master
     */
    omit?: strategy_masterOmit<ExtArgs> | null
  }


  /**
   * Model transaction_types
   */

  export type AggregateTransaction_types = {
    _count: Transaction_typesCountAggregateOutputType | null
    _avg: Transaction_typesAvgAggregateOutputType | null
    _sum: Transaction_typesSumAggregateOutputType | null
    _min: Transaction_typesMinAggregateOutputType | null
    _max: Transaction_typesMaxAggregateOutputType | null
  }

  export type Transaction_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Transaction_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Transaction_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Transaction_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Transaction_typesCountAggregateOutputType = {
    id: number
    name: number
    category: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Transaction_typesAvgAggregateInputType = {
    id?: true
  }

  export type Transaction_typesSumAggregateInputType = {
    id?: true
  }

  export type Transaction_typesMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    created_at?: true
    updated_at?: true
  }

  export type Transaction_typesMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    created_at?: true
    updated_at?: true
  }

  export type Transaction_typesCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Transaction_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_types to aggregate.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaction_types
    **/
    _count?: true | Transaction_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Transaction_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Transaction_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaction_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaction_typesMaxAggregateInputType
  }

  export type GetTransaction_typesAggregateType<T extends Transaction_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction_types[P]>
      : GetScalarType<T[P], AggregateTransaction_types[P]>
  }




  export type transaction_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaction_typesWhereInput
    orderBy?: transaction_typesOrderByWithAggregationInput | transaction_typesOrderByWithAggregationInput[]
    by: Transaction_typesScalarFieldEnum[] | Transaction_typesScalarFieldEnum
    having?: transaction_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaction_typesCountAggregateInputType | true
    _avg?: Transaction_typesAvgAggregateInputType
    _sum?: Transaction_typesSumAggregateInputType
    _min?: Transaction_typesMinAggregateInputType
    _max?: Transaction_typesMaxAggregateInputType
  }

  export type Transaction_typesGroupByOutputType = {
    id: number
    name: string
    category: string
    created_at: Date | null
    updated_at: Date | null
    _count: Transaction_typesCountAggregateOutputType | null
    _avg: Transaction_typesAvgAggregateOutputType | null
    _sum: Transaction_typesSumAggregateOutputType | null
    _min: Transaction_typesMinAggregateOutputType | null
    _max: Transaction_typesMaxAggregateOutputType | null
  }

  type GetTransaction_typesGroupByPayload<T extends transaction_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaction_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaction_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaction_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Transaction_typesGroupByOutputType[P]>
        }
      >
    >


  export type transaction_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["transaction_types"]>



  export type transaction_typesSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type transaction_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "created_at" | "updated_at", ExtArgs["result"]["transaction_types"]>

  export type $transaction_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["transaction_types"]>
    composites: {}
  }

  type transaction_typesGetPayload<S extends boolean | null | undefined | transaction_typesDefaultArgs> = $Result.GetResult<Prisma.$transaction_typesPayload, S>

  type transaction_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transaction_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Transaction_typesCountAggregateInputType | true
    }

  export interface transaction_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction_types'], meta: { name: 'transaction_types' } }
    /**
     * Find zero or one Transaction_types that matches the filter.
     * @param {transaction_typesFindUniqueArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaction_typesFindUniqueArgs>(args: SelectSubset<T, transaction_typesFindUniqueArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transaction_typesFindUniqueOrThrowArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaction_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, transaction_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesFindFirstArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaction_typesFindFirstArgs>(args?: SelectSubset<T, transaction_typesFindFirstArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesFindFirstOrThrowArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaction_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, transaction_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transaction_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaction_types
     * const transaction_types = await prisma.transaction_types.findMany()
     * 
     * // Get first 10 Transaction_types
     * const transaction_types = await prisma.transaction_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaction_typesWithIdOnly = await prisma.transaction_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaction_typesFindManyArgs>(args?: SelectSubset<T, transaction_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction_types.
     * @param {transaction_typesCreateArgs} args - Arguments to create a Transaction_types.
     * @example
     * // Create one Transaction_types
     * const Transaction_types = await prisma.transaction_types.create({
     *   data: {
     *     // ... data to create a Transaction_types
     *   }
     * })
     * 
     */
    create<T extends transaction_typesCreateArgs>(args: SelectSubset<T, transaction_typesCreateArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transaction_types.
     * @param {transaction_typesCreateManyArgs} args - Arguments to create many Transaction_types.
     * @example
     * // Create many Transaction_types
     * const transaction_types = await prisma.transaction_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaction_typesCreateManyArgs>(args?: SelectSubset<T, transaction_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction_types.
     * @param {transaction_typesDeleteArgs} args - Arguments to delete one Transaction_types.
     * @example
     * // Delete one Transaction_types
     * const Transaction_types = await prisma.transaction_types.delete({
     *   where: {
     *     // ... filter to delete one Transaction_types
     *   }
     * })
     * 
     */
    delete<T extends transaction_typesDeleteArgs>(args: SelectSubset<T, transaction_typesDeleteArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction_types.
     * @param {transaction_typesUpdateArgs} args - Arguments to update one Transaction_types.
     * @example
     * // Update one Transaction_types
     * const transaction_types = await prisma.transaction_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaction_typesUpdateArgs>(args: SelectSubset<T, transaction_typesUpdateArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transaction_types.
     * @param {transaction_typesDeleteManyArgs} args - Arguments to filter Transaction_types to delete.
     * @example
     * // Delete a few Transaction_types
     * const { count } = await prisma.transaction_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaction_typesDeleteManyArgs>(args?: SelectSubset<T, transaction_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaction_types
     * const transaction_types = await prisma.transaction_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaction_typesUpdateManyArgs>(args: SelectSubset<T, transaction_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction_types.
     * @param {transaction_typesUpsertArgs} args - Arguments to update or create a Transaction_types.
     * @example
     * // Update or create a Transaction_types
     * const transaction_types = await prisma.transaction_types.upsert({
     *   create: {
     *     // ... data to create a Transaction_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction_types we want to update
     *   }
     * })
     */
    upsert<T extends transaction_typesUpsertArgs>(args: SelectSubset<T, transaction_typesUpsertArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesCountArgs} args - Arguments to filter Transaction_types to count.
     * @example
     * // Count the number of Transaction_types
     * const count = await prisma.transaction_types.count({
     *   where: {
     *     // ... the filter for the Transaction_types we want to count
     *   }
     * })
    **/
    count<T extends transaction_typesCountArgs>(
      args?: Subset<T, transaction_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaction_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaction_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaction_typesAggregateArgs>(args: Subset<T, Transaction_typesAggregateArgs>): Prisma.PrismaPromise<GetTransaction_typesAggregateType<T>>

    /**
     * Group by Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaction_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaction_typesGroupByArgs['orderBy'] }
        : { orderBy?: transaction_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaction_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaction_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction_types model
   */
  readonly fields: transaction_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaction_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction_types model
   */
  interface transaction_typesFieldRefs {
    readonly id: FieldRef<"transaction_types", 'Int'>
    readonly name: FieldRef<"transaction_types", 'String'>
    readonly category: FieldRef<"transaction_types", 'String'>
    readonly created_at: FieldRef<"transaction_types", 'DateTime'>
    readonly updated_at: FieldRef<"transaction_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaction_types findUnique
   */
  export type transaction_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types findUniqueOrThrow
   */
  export type transaction_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types findFirst
   */
  export type transaction_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_types.
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_types.
     */
    distinct?: Transaction_typesScalarFieldEnum | Transaction_typesScalarFieldEnum[]
  }

  /**
   * transaction_types findFirstOrThrow
   */
  export type transaction_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_types.
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_types.
     */
    distinct?: Transaction_typesScalarFieldEnum | Transaction_typesScalarFieldEnum[]
  }

  /**
   * transaction_types findMany
   */
  export type transaction_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaction_types.
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    distinct?: Transaction_typesScalarFieldEnum | Transaction_typesScalarFieldEnum[]
  }

  /**
   * transaction_types create
   */
  export type transaction_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a transaction_types.
     */
    data: XOR<transaction_typesCreateInput, transaction_typesUncheckedCreateInput>
  }

  /**
   * transaction_types createMany
   */
  export type transaction_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaction_types.
     */
    data: transaction_typesCreateManyInput | transaction_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction_types update
   */
  export type transaction_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a transaction_types.
     */
    data: XOR<transaction_typesUpdateInput, transaction_typesUncheckedUpdateInput>
    /**
     * Choose, which transaction_types to update.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types updateMany
   */
  export type transaction_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaction_types.
     */
    data: XOR<transaction_typesUpdateManyMutationInput, transaction_typesUncheckedUpdateManyInput>
    /**
     * Filter which transaction_types to update
     */
    where?: transaction_typesWhereInput
    /**
     * Limit how many transaction_types to update.
     */
    limit?: number
  }

  /**
   * transaction_types upsert
   */
  export type transaction_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the transaction_types to update in case it exists.
     */
    where: transaction_typesWhereUniqueInput
    /**
     * In case the transaction_types found by the `where` argument doesn't exist, create a new transaction_types with this data.
     */
    create: XOR<transaction_typesCreateInput, transaction_typesUncheckedCreateInput>
    /**
     * In case the transaction_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaction_typesUpdateInput, transaction_typesUncheckedUpdateInput>
  }

  /**
   * transaction_types delete
   */
  export type transaction_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Filter which transaction_types to delete.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types deleteMany
   */
  export type transaction_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_types to delete
     */
    where?: transaction_typesWhereInput
    /**
     * Limit how many transaction_types to delete.
     */
    limit?: number
  }

  /**
   * transaction_types without action
   */
  export type transaction_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    limit_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    limit_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role: $Enums.users_role | null
    created_at: Date | null
    allowed_tabs: string | null
    limit_id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role: $Enums.users_role | null
    created_at: Date | null
    allowed_tabs: string | null
    limit_id: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    password: number
    role: number
    created_at: number
    allowed_tabs: number
    limit_id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    limit_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    limit_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    created_at?: true
    allowed_tabs?: true
    limit_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    created_at?: true
    allowed_tabs?: true
    limit_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    created_at?: true
    allowed_tabs?: true
    limit_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    username: string
    password: string
    role: $Enums.users_role
    created_at: Date | null
    allowed_tabs: string | null
    limit_id: number | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    allowed_tabs?: boolean
    limit_id?: boolean
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    allowed_tabs?: boolean
    limit_id?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "role" | "created_at" | "allowed_tabs" | "limit_id", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      role: $Enums.users_role
      created_at: Date | null
      allowed_tabs: string | null
      limit_id: number | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly username: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'users_role'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly allowed_tabs: FieldRef<"users", 'String'>
    readonly limit_id: FieldRef<"users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Account_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    created_at: 'created_at'
  };

  export type Account_typesScalarFieldEnum = (typeof Account_typesScalarFieldEnum)[keyof typeof Account_typesScalarFieldEnum]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    balance: 'balance',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const BrokersScalarFieldEnum: {
    id: 'id',
    broker_code: 'broker_code',
    broker_name: 'broker_name',
    building_number: 'building_number',
    street_name: 'street_name',
    street_name2: 'street_name2',
    city: 'city',
    province: 'province',
    zip_code: 'zip_code',
    country: 'country',
    contact_name: 'contact_name',
    contact_phone: 'contact_phone',
    contact_mobile: 'contact_mobile',
    contact_fax: 'contact_fax',
    contact_email: 'contact_email',
    broker_type: 'broker_type',
    brokerage_method: 'brokerage_method',
    brokerage_cal_method_id: 'brokerage_cal_method_id',
    brokerage_input_percentage: 'brokerage_input_percentage',
    brokerage_settlement_method_id: 'brokerage_settlement_method_id',
    settlement_account_number: 'settlement_account_number',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BrokersScalarFieldEnum = (typeof BrokersScalarFieldEnum)[keyof typeof BrokersScalarFieldEnum]


  export const Chart_of_accountsScalarFieldEnum: {
    id: 'id',
    account_code: 'account_code',
    name: 'name',
    account_type_id: 'account_type_id',
    parent_account_id: 'parent_account_id',
    description: 'description',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Chart_of_accountsScalarFieldEnum = (typeof Chart_of_accountsScalarFieldEnum)[keyof typeof Chart_of_accountsScalarFieldEnum]


  export const Counterparty_limitsScalarFieldEnum: {
    id: 'id',
    counterparty_id: 'counterparty_id',
    counterparty_type: 'counterparty_type',
    overall_exposure_limit: 'overall_exposure_limit',
    currency_limit: 'currency_limit',
    product_money_market_limit: 'product_money_market_limit',
    product_fx_limit: 'product_fx_limit',
    product_derivative_limit: 'product_derivative_limit',
    product_repo_limit: 'product_repo_limit',
    product_reverse_repo_limit: 'product_reverse_repo_limit',
    product_gsec_limit: 'product_gsec_limit',
    product_sell_and_buy_back_limit: 'product_sell_and_buy_back_limit',
    product_buy_and_sell_back_limit: 'product_buy_and_sell_back_limit',
    tenor_limit: 'tenor_limit',
    settlement_risk_limit: 'settlement_risk_limit',
    country_limit: 'country_limit',
    group_limit: 'group_limit',
    intraday_limit: 'intraday_limit',
    created_at: 'created_at',
    product_transaction_limit: 'product_transaction_limit',
    currency: 'currency'
  };

  export type Counterparty_limitsScalarFieldEnum = (typeof Counterparty_limitsScalarFieldEnum)[keyof typeof Counterparty_limitsScalarFieldEnum]


  export const Counterparty_master_individualScalarFieldEnum: {
    id: 'id',
    title: 'title',
    short_name: 'short_name',
    long_name: 'long_name',
    id_type: 'id_type',
    house_number: 'house_number',
    street_name: 'street_name',
    province: 'province',
    postal_code: 'postal_code',
    city: 'city',
    country: 'country',
    telephone: 'telephone',
    email: 'email',
    mobile: 'mobile',
    created_at: 'created_at'
  };

  export type Counterparty_master_individualScalarFieldEnum = (typeof Counterparty_master_individualScalarFieldEnum)[keyof typeof Counterparty_master_individualScalarFieldEnum]


  export const Counterparty_master_jointScalarFieldEnum: {
    id: 'id',
    title: 'title',
    short_name: 'short_name',
    long_name: 'long_name',
    id_type: 'id_type',
    house_number: 'house_number',
    street_name: 'street_name',
    province: 'province',
    postal_code: 'postal_code',
    city: 'city',
    country: 'country',
    telephone: 'telephone',
    email: 'email',
    mobile: 'mobile',
    created_at: 'created_at'
  };

  export type Counterparty_master_jointScalarFieldEnum = (typeof Counterparty_master_jointScalarFieldEnum)[keyof typeof Counterparty_master_jointScalarFieldEnum]


  export const GsecScalarFieldEnum: {
    id: 'id',
    trade_type: 'trade_type',
    transaction_type: 'transaction_type',
    counterparty: 'counterparty',
    deal_number: 'deal_number',
    isin: 'isin',
    face_value: 'face_value',
    value_date: 'value_date',
    next_coupon_date: 'next_coupon_date',
    last_coupon_date: 'last_coupon_date',
    number_of_days_interest_accrued: 'number_of_days_interest_accrued',
    number_of_days_for_coupon_period: 'number_of_days_for_coupon_period',
    accrued_interest: 'accrued_interest',
    coupon_interest: 'coupon_interest',
    clean_price: 'clean_price',
    dirty_price: 'dirty_price',
    accrued_interest_calculation: 'accrued_interest_calculation',
    accrued_interest_six_decimals: 'accrued_interest_six_decimals',
    accrued_interest_for_100: 'accrued_interest_for_100',
    settlement_amount: 'settlement_amount',
    settlement_mode: 'settlement_mode',
    issue_date: 'issue_date',
    maturity_date: 'maturity_date',
    coupon_dates: 'coupon_dates',
    yield: 'yield',
    portfolio: 'portfolio',
    clean_price_adjustment: 'clean_price_adjustment',
    accrued_interest_adjustment: 'accrued_interest_adjustment',
    broker: 'broker',
    strategy: 'strategy',
    status: 'status',
    comment: 'comment',
    created_by: 'created_by',
    stratergy: 'stratergy',
    created_at: 'created_at',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    authorized_by: 'authorized_by',
    authorized_at: 'authorized_at',
    brokerage: 'brokerage',
    currency: 'currency'
  };

  export type GsecScalarFieldEnum = (typeof GsecScalarFieldEnum)[keyof typeof GsecScalarFieldEnum]


  export const Isin_coupon_scheduleScalarFieldEnum: {
    id: 'id',
    isin: 'isin',
    coupon_number: 'coupon_number',
    coupon_date: 'coupon_date',
    coupon_amount: 'coupon_amount',
    principal: 'principal'
  };

  export type Isin_coupon_scheduleScalarFieldEnum = (typeof Isin_coupon_scheduleScalarFieldEnum)[keyof typeof Isin_coupon_scheduleScalarFieldEnum]


  export const Isin_masterScalarFieldEnum: {
    id: 'id',
    isin_issuer: 'isin_issuer',
    isin_number: 'isin_number',
    issue_date: 'issue_date',
    maturity_date: 'maturity_date',
    coupon_rate: 'coupon_rate',
    series: 'series',
    coupon_date_1: 'coupon_date_1',
    coupon_date_2: 'coupon_date_2',
    day_basis: 'day_basis',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Isin_masterScalarFieldEnum = (typeof Isin_masterScalarFieldEnum)[keyof typeof Isin_masterScalarFieldEnum]


  export const Ledger_entriesScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    entry_date: 'entry_date',
    debit_amount: 'debit_amount',
    credit_amount: 'credit_amount',
    currency: 'currency',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deal_number: 'deal_number'
  };

  export type Ledger_entriesScalarFieldEnum = (typeof Ledger_entriesScalarFieldEnum)[keyof typeof Ledger_entriesScalarFieldEnum]


  export const Money_market_dealsScalarFieldEnum: {
    id: 'id',
    deal_number: 'deal_number',
    trade_date: 'trade_date',
    value_date: 'value_date',
    maturity_date: 'maturity_date',
    counterparty_type: 'counterparty_type',
    counterparty_id: 'counterparty_id',
    product_type: 'product_type',
    currency: 'currency',
    principal_amount: 'principal_amount',
    interest_rate: 'interest_rate',
    tenor: 'tenor',
    interest_amount: 'interest_amount',
    maturity_value: 'maturity_value',
    settlement_mode: 'settlement_mode',
    remarks: 'remarks',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Money_market_dealsScalarFieldEnum = (typeof Money_market_dealsScalarFieldEnum)[keyof typeof Money_market_dealsScalarFieldEnum]


  export const Portfolio_masterScalarFieldEnum: {
    portfolio_id: 'portfolio_id',
    portfolio_name: 'portfolio_name',
    portfolio_type: 'portfolio_type',
    entity_business_unit: 'entity_business_unit',
    fund_manager_user_id: 'fund_manager_user_id',
    base_currency: 'base_currency',
    benchmark: 'benchmark',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    risk_profile: 'risk_profile',
    investment_horizon: 'investment_horizon',
    target_yield_return: 'target_yield_return',
    compliance_rules_id: 'compliance_rules_id',
    notes_description: 'notes_description',
    parent_portfolio_id: 'parent_portfolio_id',
    valuation_method: 'valuation_method',
    accounting_treatment: 'accounting_treatment',
    rebalancing_frequency: 'rebalancing_frequency',
    external_reference_code: 'external_reference_code',
    tags_categories: 'tags_categories',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Portfolio_masterScalarFieldEnum = (typeof Portfolio_masterScalarFieldEnum)[keyof typeof Portfolio_masterScalarFieldEnum]


  export const SecuritiesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SecuritiesScalarFieldEnum = (typeof SecuritiesScalarFieldEnum)[keyof typeof SecuritiesScalarFieldEnum]


  export const Settlement_accountsScalarFieldEnum: {
    id: 'id',
    bank_name: 'bank_name',
    bank_payment_code: 'bank_payment_code',
    bank_code: 'bank_code',
    address_building_number: 'address_building_number',
    address_street_name: 'address_street_name',
    address_street_name2: 'address_street_name2',
    address_city: 'address_city',
    address_province: 'address_province',
    address_zip_code: 'address_zip_code',
    address_country: 'address_country',
    contact_name: 'contact_name',
    contact_phone: 'contact_phone',
    contact_mobile: 'contact_mobile',
    contact_fax: 'contact_fax',
    contact_email: 'contact_email',
    account_type: 'account_type',
    bank_account_number: 'bank_account_number',
    bank_branch: 'bank_branch',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Settlement_accountsScalarFieldEnum = (typeof Settlement_accountsScalarFieldEnum)[keyof typeof Settlement_accountsScalarFieldEnum]


  export const Strategy_masterScalarFieldEnum: {
    strategy_id: 'strategy_id',
    portfolio_name: 'portfolio_name',
    strategy_type: 'strategy_type',
    entity_business_unit: 'entity_business_unit'
  };

  export type Strategy_masterScalarFieldEnum = (typeof Strategy_masterScalarFieldEnum)[keyof typeof Strategy_masterScalarFieldEnum]


  export const Transaction_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Transaction_typesScalarFieldEnum = (typeof Transaction_typesScalarFieldEnum)[keyof typeof Transaction_typesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    role: 'role',
    created_at: 'created_at',
    allowed_tabs: 'allowed_tabs',
    limit_id: 'limit_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const account_typesOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type account_typesOrderByRelevanceFieldEnum = (typeof account_typesOrderByRelevanceFieldEnum)[keyof typeof account_typesOrderByRelevanceFieldEnum]


  export const accountsOrderByRelevanceFieldEnum: {
    name: 'name',
    type: 'type'
  };

  export type accountsOrderByRelevanceFieldEnum = (typeof accountsOrderByRelevanceFieldEnum)[keyof typeof accountsOrderByRelevanceFieldEnum]


  export const brokersOrderByRelevanceFieldEnum: {
    broker_code: 'broker_code',
    broker_name: 'broker_name',
    building_number: 'building_number',
    street_name: 'street_name',
    street_name2: 'street_name2',
    city: 'city',
    province: 'province',
    zip_code: 'zip_code',
    country: 'country',
    contact_name: 'contact_name',
    contact_phone: 'contact_phone',
    contact_mobile: 'contact_mobile',
    contact_fax: 'contact_fax',
    contact_email: 'contact_email',
    broker_type: 'broker_type',
    brokerage_method: 'brokerage_method',
    settlement_account_number: 'settlement_account_number'
  };

  export type brokersOrderByRelevanceFieldEnum = (typeof brokersOrderByRelevanceFieldEnum)[keyof typeof brokersOrderByRelevanceFieldEnum]


  export const chart_of_accountsOrderByRelevanceFieldEnum: {
    account_code: 'account_code',
    name: 'name',
    description: 'description'
  };

  export type chart_of_accountsOrderByRelevanceFieldEnum = (typeof chart_of_accountsOrderByRelevanceFieldEnum)[keyof typeof chart_of_accountsOrderByRelevanceFieldEnum]


  export const counterparty_limitsOrderByRelevanceFieldEnum: {
    currency_limit: 'currency_limit',
    currency: 'currency'
  };

  export type counterparty_limitsOrderByRelevanceFieldEnum = (typeof counterparty_limitsOrderByRelevanceFieldEnum)[keyof typeof counterparty_limitsOrderByRelevanceFieldEnum]


  export const counterparty_master_individualOrderByRelevanceFieldEnum: {
    title: 'title',
    short_name: 'short_name',
    long_name: 'long_name',
    id_type: 'id_type',
    house_number: 'house_number',
    street_name: 'street_name',
    province: 'province',
    postal_code: 'postal_code',
    city: 'city',
    country: 'country',
    telephone: 'telephone',
    email: 'email',
    mobile: 'mobile'
  };

  export type counterparty_master_individualOrderByRelevanceFieldEnum = (typeof counterparty_master_individualOrderByRelevanceFieldEnum)[keyof typeof counterparty_master_individualOrderByRelevanceFieldEnum]


  export const counterparty_master_jointOrderByRelevanceFieldEnum: {
    title: 'title',
    short_name: 'short_name',
    long_name: 'long_name',
    id_type: 'id_type',
    house_number: 'house_number',
    street_name: 'street_name',
    province: 'province',
    postal_code: 'postal_code',
    city: 'city',
    country: 'country',
    telephone: 'telephone',
    email: 'email',
    mobile: 'mobile'
  };

  export type counterparty_master_jointOrderByRelevanceFieldEnum = (typeof counterparty_master_jointOrderByRelevanceFieldEnum)[keyof typeof counterparty_master_jointOrderByRelevanceFieldEnum]


  export const gsecOrderByRelevanceFieldEnum: {
    trade_type: 'trade_type',
    transaction_type: 'transaction_type',
    counterparty: 'counterparty',
    deal_number: 'deal_number',
    isin: 'isin',
    settlement_mode: 'settlement_mode',
    coupon_dates: 'coupon_dates',
    portfolio: 'portfolio',
    clean_price_adjustment: 'clean_price_adjustment',
    accrued_interest_adjustment: 'accrued_interest_adjustment',
    broker: 'broker',
    strategy: 'strategy',
    status: 'status',
    comment: 'comment',
    stratergy: 'stratergy',
    currency: 'currency'
  };

  export type gsecOrderByRelevanceFieldEnum = (typeof gsecOrderByRelevanceFieldEnum)[keyof typeof gsecOrderByRelevanceFieldEnum]


  export const isin_coupon_scheduleOrderByRelevanceFieldEnum: {
    isin: 'isin'
  };

  export type isin_coupon_scheduleOrderByRelevanceFieldEnum = (typeof isin_coupon_scheduleOrderByRelevanceFieldEnum)[keyof typeof isin_coupon_scheduleOrderByRelevanceFieldEnum]


  export const isin_masterOrderByRelevanceFieldEnum: {
    isin_issuer: 'isin_issuer',
    isin_number: 'isin_number',
    series: 'series',
    currency: 'currency'
  };

  export type isin_masterOrderByRelevanceFieldEnum = (typeof isin_masterOrderByRelevanceFieldEnum)[keyof typeof isin_masterOrderByRelevanceFieldEnum]


  export const ledger_entriesOrderByRelevanceFieldEnum: {
    currency: 'currency',
    description: 'description',
    deal_number: 'deal_number'
  };

  export type ledger_entriesOrderByRelevanceFieldEnum = (typeof ledger_entriesOrderByRelevanceFieldEnum)[keyof typeof ledger_entriesOrderByRelevanceFieldEnum]


  export const money_market_dealsOrderByRelevanceFieldEnum: {
    deal_number: 'deal_number',
    product_type: 'product_type',
    currency: 'currency',
    settlement_mode: 'settlement_mode',
    remarks: 'remarks'
  };

  export type money_market_dealsOrderByRelevanceFieldEnum = (typeof money_market_dealsOrderByRelevanceFieldEnum)[keyof typeof money_market_dealsOrderByRelevanceFieldEnum]


  export const portfolio_masterOrderByRelevanceFieldEnum: {
    portfolio_id: 'portfolio_id',
    portfolio_name: 'portfolio_name',
    portfolio_type: 'portfolio_type',
    entity_business_unit: 'entity_business_unit',
    fund_manager_user_id: 'fund_manager_user_id',
    base_currency: 'base_currency',
    benchmark: 'benchmark',
    compliance_rules_id: 'compliance_rules_id',
    notes_description: 'notes_description',
    parent_portfolio_id: 'parent_portfolio_id',
    valuation_method: 'valuation_method',
    accounting_treatment: 'accounting_treatment',
    rebalancing_frequency: 'rebalancing_frequency',
    external_reference_code: 'external_reference_code',
    tags_categories: 'tags_categories'
  };

  export type portfolio_masterOrderByRelevanceFieldEnum = (typeof portfolio_masterOrderByRelevanceFieldEnum)[keyof typeof portfolio_masterOrderByRelevanceFieldEnum]


  export const securitiesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type securitiesOrderByRelevanceFieldEnum = (typeof securitiesOrderByRelevanceFieldEnum)[keyof typeof securitiesOrderByRelevanceFieldEnum]


  export const settlement_accountsOrderByRelevanceFieldEnum: {
    bank_name: 'bank_name',
    bank_payment_code: 'bank_payment_code',
    bank_code: 'bank_code',
    address_building_number: 'address_building_number',
    address_street_name: 'address_street_name',
    address_street_name2: 'address_street_name2',
    address_city: 'address_city',
    address_province: 'address_province',
    address_zip_code: 'address_zip_code',
    address_country: 'address_country',
    contact_name: 'contact_name',
    contact_phone: 'contact_phone',
    contact_mobile: 'contact_mobile',
    contact_fax: 'contact_fax',
    contact_email: 'contact_email',
    account_type: 'account_type',
    bank_account_number: 'bank_account_number',
    bank_branch: 'bank_branch'
  };

  export type settlement_accountsOrderByRelevanceFieldEnum = (typeof settlement_accountsOrderByRelevanceFieldEnum)[keyof typeof settlement_accountsOrderByRelevanceFieldEnum]


  export const strategy_masterOrderByRelevanceFieldEnum: {
    strategy_id: 'strategy_id',
    portfolio_name: 'portfolio_name',
    strategy_type: 'strategy_type',
    entity_business_unit: 'entity_business_unit'
  };

  export type strategy_masterOrderByRelevanceFieldEnum = (typeof strategy_masterOrderByRelevanceFieldEnum)[keyof typeof strategy_masterOrderByRelevanceFieldEnum]


  export const transaction_typesOrderByRelevanceFieldEnum: {
    name: 'name',
    category: 'category'
  };

  export type transaction_typesOrderByRelevanceFieldEnum = (typeof transaction_typesOrderByRelevanceFieldEnum)[keyof typeof transaction_typesOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password',
    allowed_tabs: 'allowed_tabs'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'account_types_category'
   */
  export type Enumaccount_types_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'account_types_category'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'counterparty_limits_counterparty_type'
   */
  export type Enumcounterparty_limits_counterparty_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'counterparty_limits_counterparty_type'>
    


  /**
   * Reference to a field of type 'money_market_deals_counterparty_type'
   */
  export type Enummoney_market_deals_counterparty_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'money_market_deals_counterparty_type'>
    


  /**
   * Reference to a field of type 'portfolio_master_status'
   */
  export type Enumportfolio_master_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'portfolio_master_status'>
    


  /**
   * Reference to a field of type 'portfolio_master_risk_profile'
   */
  export type Enumportfolio_master_risk_profileFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'portfolio_master_risk_profile'>
    


  /**
   * Reference to a field of type 'portfolio_master_investment_horizon'
   */
  export type Enumportfolio_master_investment_horizonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'portfolio_master_investment_horizon'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'users_role'
   */
  export type Enumusers_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_role'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type account_typesWhereInput = {
    AND?: account_typesWhereInput | account_typesWhereInput[]
    OR?: account_typesWhereInput[]
    NOT?: account_typesWhereInput | account_typesWhereInput[]
    id?: IntFilter<"account_types"> | number
    name?: StringFilter<"account_types"> | string
    category?: Enumaccount_types_categoryFilter<"account_types"> | $Enums.account_types_category
    description?: StringNullableFilter<"account_types"> | string | null
    created_at?: DateTimeNullableFilter<"account_types"> | Date | string | null
    chart_of_accounts?: Chart_of_accountsListRelationFilter
  }

  export type account_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    chart_of_accounts?: chart_of_accountsOrderByRelationAggregateInput
    _relevance?: account_typesOrderByRelevanceInput
  }

  export type account_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: account_typesWhereInput | account_typesWhereInput[]
    OR?: account_typesWhereInput[]
    NOT?: account_typesWhereInput | account_typesWhereInput[]
    category?: Enumaccount_types_categoryFilter<"account_types"> | $Enums.account_types_category
    description?: StringNullableFilter<"account_types"> | string | null
    created_at?: DateTimeNullableFilter<"account_types"> | Date | string | null
    chart_of_accounts?: Chart_of_accountsListRelationFilter
  }, "id" | "name">

  export type account_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: account_typesCountOrderByAggregateInput
    _avg?: account_typesAvgOrderByAggregateInput
    _max?: account_typesMaxOrderByAggregateInput
    _min?: account_typesMinOrderByAggregateInput
    _sum?: account_typesSumOrderByAggregateInput
  }

  export type account_typesScalarWhereWithAggregatesInput = {
    AND?: account_typesScalarWhereWithAggregatesInput | account_typesScalarWhereWithAggregatesInput[]
    OR?: account_typesScalarWhereWithAggregatesInput[]
    NOT?: account_typesScalarWhereWithAggregatesInput | account_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"account_types"> | number
    name?: StringWithAggregatesFilter<"account_types"> | string
    category?: Enumaccount_types_categoryWithAggregatesFilter<"account_types"> | $Enums.account_types_category
    description?: StringNullableWithAggregatesFilter<"account_types"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"account_types"> | Date | string | null
  }

  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: IntFilter<"accounts"> | number
    name?: StringFilter<"accounts"> | string
    type?: StringFilter<"accounts"> | string
    balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: accountsOrderByRelevanceInput
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    name?: StringFilter<"accounts"> | string
    type?: StringFilter<"accounts"> | string
    balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
  }, "id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accounts"> | number
    name?: StringWithAggregatesFilter<"accounts"> | string
    type?: StringWithAggregatesFilter<"accounts"> | string
    balance?: DecimalNullableWithAggregatesFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"accounts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"accounts"> | Date | string | null
  }

  export type brokersWhereInput = {
    AND?: brokersWhereInput | brokersWhereInput[]
    OR?: brokersWhereInput[]
    NOT?: brokersWhereInput | brokersWhereInput[]
    id?: IntFilter<"brokers"> | number
    broker_code?: StringFilter<"brokers"> | string
    broker_name?: StringFilter<"brokers"> | string
    building_number?: StringNullableFilter<"brokers"> | string | null
    street_name?: StringNullableFilter<"brokers"> | string | null
    street_name2?: StringNullableFilter<"brokers"> | string | null
    city?: StringNullableFilter<"brokers"> | string | null
    province?: StringNullableFilter<"brokers"> | string | null
    zip_code?: StringNullableFilter<"brokers"> | string | null
    country?: StringNullableFilter<"brokers"> | string | null
    contact_name?: StringNullableFilter<"brokers"> | string | null
    contact_phone?: StringNullableFilter<"brokers"> | string | null
    contact_mobile?: StringNullableFilter<"brokers"> | string | null
    contact_fax?: StringNullableFilter<"brokers"> | string | null
    contact_email?: StringNullableFilter<"brokers"> | string | null
    broker_type?: StringNullableFilter<"brokers"> | string | null
    brokerage_method?: StringNullableFilter<"brokers"> | string | null
    brokerage_cal_method_id?: IntNullableFilter<"brokers"> | number | null
    brokerage_input_percentage?: DecimalNullableFilter<"brokers"> | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: IntNullableFilter<"brokers"> | number | null
    settlement_account_number?: StringNullableFilter<"brokers"> | string | null
    created_at?: DateTimeNullableFilter<"brokers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"brokers"> | Date | string | null
  }

  export type brokersOrderByWithRelationInput = {
    id?: SortOrder
    broker_code?: SortOrder
    broker_name?: SortOrder
    building_number?: SortOrderInput | SortOrder
    street_name?: SortOrderInput | SortOrder
    street_name2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    zip_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    contact_mobile?: SortOrderInput | SortOrder
    contact_fax?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    broker_type?: SortOrderInput | SortOrder
    brokerage_method?: SortOrderInput | SortOrder
    brokerage_cal_method_id?: SortOrderInput | SortOrder
    brokerage_input_percentage?: SortOrderInput | SortOrder
    brokerage_settlement_method_id?: SortOrderInput | SortOrder
    settlement_account_number?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: brokersOrderByRelevanceInput
  }

  export type brokersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    broker_code?: string
    AND?: brokersWhereInput | brokersWhereInput[]
    OR?: brokersWhereInput[]
    NOT?: brokersWhereInput | brokersWhereInput[]
    broker_name?: StringFilter<"brokers"> | string
    building_number?: StringNullableFilter<"brokers"> | string | null
    street_name?: StringNullableFilter<"brokers"> | string | null
    street_name2?: StringNullableFilter<"brokers"> | string | null
    city?: StringNullableFilter<"brokers"> | string | null
    province?: StringNullableFilter<"brokers"> | string | null
    zip_code?: StringNullableFilter<"brokers"> | string | null
    country?: StringNullableFilter<"brokers"> | string | null
    contact_name?: StringNullableFilter<"brokers"> | string | null
    contact_phone?: StringNullableFilter<"brokers"> | string | null
    contact_mobile?: StringNullableFilter<"brokers"> | string | null
    contact_fax?: StringNullableFilter<"brokers"> | string | null
    contact_email?: StringNullableFilter<"brokers"> | string | null
    broker_type?: StringNullableFilter<"brokers"> | string | null
    brokerage_method?: StringNullableFilter<"brokers"> | string | null
    brokerage_cal_method_id?: IntNullableFilter<"brokers"> | number | null
    brokerage_input_percentage?: DecimalNullableFilter<"brokers"> | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: IntNullableFilter<"brokers"> | number | null
    settlement_account_number?: StringNullableFilter<"brokers"> | string | null
    created_at?: DateTimeNullableFilter<"brokers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"brokers"> | Date | string | null
  }, "id" | "broker_code">

  export type brokersOrderByWithAggregationInput = {
    id?: SortOrder
    broker_code?: SortOrder
    broker_name?: SortOrder
    building_number?: SortOrderInput | SortOrder
    street_name?: SortOrderInput | SortOrder
    street_name2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    zip_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    contact_mobile?: SortOrderInput | SortOrder
    contact_fax?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    broker_type?: SortOrderInput | SortOrder
    brokerage_method?: SortOrderInput | SortOrder
    brokerage_cal_method_id?: SortOrderInput | SortOrder
    brokerage_input_percentage?: SortOrderInput | SortOrder
    brokerage_settlement_method_id?: SortOrderInput | SortOrder
    settlement_account_number?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: brokersCountOrderByAggregateInput
    _avg?: brokersAvgOrderByAggregateInput
    _max?: brokersMaxOrderByAggregateInput
    _min?: brokersMinOrderByAggregateInput
    _sum?: brokersSumOrderByAggregateInput
  }

  export type brokersScalarWhereWithAggregatesInput = {
    AND?: brokersScalarWhereWithAggregatesInput | brokersScalarWhereWithAggregatesInput[]
    OR?: brokersScalarWhereWithAggregatesInput[]
    NOT?: brokersScalarWhereWithAggregatesInput | brokersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"brokers"> | number
    broker_code?: StringWithAggregatesFilter<"brokers"> | string
    broker_name?: StringWithAggregatesFilter<"brokers"> | string
    building_number?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    street_name?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    street_name2?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    city?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    province?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    zip_code?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    country?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    contact_name?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    contact_phone?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    contact_mobile?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    contact_fax?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    broker_type?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    brokerage_method?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    brokerage_cal_method_id?: IntNullableWithAggregatesFilter<"brokers"> | number | null
    brokerage_input_percentage?: DecimalNullableWithAggregatesFilter<"brokers"> | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: IntNullableWithAggregatesFilter<"brokers"> | number | null
    settlement_account_number?: StringNullableWithAggregatesFilter<"brokers"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"brokers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"brokers"> | Date | string | null
  }

  export type chart_of_accountsWhereInput = {
    AND?: chart_of_accountsWhereInput | chart_of_accountsWhereInput[]
    OR?: chart_of_accountsWhereInput[]
    NOT?: chart_of_accountsWhereInput | chart_of_accountsWhereInput[]
    id?: IntFilter<"chart_of_accounts"> | number
    account_code?: StringFilter<"chart_of_accounts"> | string
    name?: StringFilter<"chart_of_accounts"> | string
    account_type_id?: IntFilter<"chart_of_accounts"> | number
    parent_account_id?: IntNullableFilter<"chart_of_accounts"> | number | null
    description?: StringNullableFilter<"chart_of_accounts"> | string | null
    is_active?: BoolNullableFilter<"chart_of_accounts"> | boolean | null
    created_at?: DateTimeNullableFilter<"chart_of_accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chart_of_accounts"> | Date | string | null
    account_types?: XOR<Account_typesScalarRelationFilter, account_typesWhereInput>
    chart_of_accounts?: XOR<Chart_of_accountsNullableScalarRelationFilter, chart_of_accountsWhereInput> | null
    other_chart_of_accounts?: Chart_of_accountsListRelationFilter
    ledger_entries?: Ledger_entriesListRelationFilter
  }

  export type chart_of_accountsOrderByWithRelationInput = {
    id?: SortOrder
    account_code?: SortOrder
    name?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    account_types?: account_typesOrderByWithRelationInput
    chart_of_accounts?: chart_of_accountsOrderByWithRelationInput
    other_chart_of_accounts?: chart_of_accountsOrderByRelationAggregateInput
    ledger_entries?: ledger_entriesOrderByRelationAggregateInput
    _relevance?: chart_of_accountsOrderByRelevanceInput
  }

  export type chart_of_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    account_code?: string
    AND?: chart_of_accountsWhereInput | chart_of_accountsWhereInput[]
    OR?: chart_of_accountsWhereInput[]
    NOT?: chart_of_accountsWhereInput | chart_of_accountsWhereInput[]
    name?: StringFilter<"chart_of_accounts"> | string
    account_type_id?: IntFilter<"chart_of_accounts"> | number
    parent_account_id?: IntNullableFilter<"chart_of_accounts"> | number | null
    description?: StringNullableFilter<"chart_of_accounts"> | string | null
    is_active?: BoolNullableFilter<"chart_of_accounts"> | boolean | null
    created_at?: DateTimeNullableFilter<"chart_of_accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chart_of_accounts"> | Date | string | null
    account_types?: XOR<Account_typesScalarRelationFilter, account_typesWhereInput>
    chart_of_accounts?: XOR<Chart_of_accountsNullableScalarRelationFilter, chart_of_accountsWhereInput> | null
    other_chart_of_accounts?: Chart_of_accountsListRelationFilter
    ledger_entries?: Ledger_entriesListRelationFilter
  }, "id" | "account_code">

  export type chart_of_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    account_code?: SortOrder
    name?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: chart_of_accountsCountOrderByAggregateInput
    _avg?: chart_of_accountsAvgOrderByAggregateInput
    _max?: chart_of_accountsMaxOrderByAggregateInput
    _min?: chart_of_accountsMinOrderByAggregateInput
    _sum?: chart_of_accountsSumOrderByAggregateInput
  }

  export type chart_of_accountsScalarWhereWithAggregatesInput = {
    AND?: chart_of_accountsScalarWhereWithAggregatesInput | chart_of_accountsScalarWhereWithAggregatesInput[]
    OR?: chart_of_accountsScalarWhereWithAggregatesInput[]
    NOT?: chart_of_accountsScalarWhereWithAggregatesInput | chart_of_accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chart_of_accounts"> | number
    account_code?: StringWithAggregatesFilter<"chart_of_accounts"> | string
    name?: StringWithAggregatesFilter<"chart_of_accounts"> | string
    account_type_id?: IntWithAggregatesFilter<"chart_of_accounts"> | number
    parent_account_id?: IntNullableWithAggregatesFilter<"chart_of_accounts"> | number | null
    description?: StringNullableWithAggregatesFilter<"chart_of_accounts"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"chart_of_accounts"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"chart_of_accounts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"chart_of_accounts"> | Date | string | null
  }

  export type counterparty_limitsWhereInput = {
    AND?: counterparty_limitsWhereInput | counterparty_limitsWhereInput[]
    OR?: counterparty_limitsWhereInput[]
    NOT?: counterparty_limitsWhereInput | counterparty_limitsWhereInput[]
    id?: IntFilter<"counterparty_limits"> | number
    counterparty_id?: IntFilter<"counterparty_limits"> | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeFilter<"counterparty_limits"> | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    currency_limit?: StringNullableFilter<"counterparty_limits"> | string | null
    product_money_market_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    country_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    group_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"counterparty_limits"> | Date | string | null
    product_transaction_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"counterparty_limits"> | string | null
  }

  export type counterparty_limitsOrderByWithRelationInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    counterparty_type?: SortOrder
    overall_exposure_limit?: SortOrderInput | SortOrder
    currency_limit?: SortOrderInput | SortOrder
    product_money_market_limit?: SortOrderInput | SortOrder
    product_fx_limit?: SortOrderInput | SortOrder
    product_derivative_limit?: SortOrderInput | SortOrder
    product_repo_limit?: SortOrderInput | SortOrder
    product_reverse_repo_limit?: SortOrderInput | SortOrder
    product_gsec_limit?: SortOrderInput | SortOrder
    product_sell_and_buy_back_limit?: SortOrderInput | SortOrder
    product_buy_and_sell_back_limit?: SortOrderInput | SortOrder
    tenor_limit?: SortOrderInput | SortOrder
    settlement_risk_limit?: SortOrderInput | SortOrder
    country_limit?: SortOrderInput | SortOrder
    group_limit?: SortOrderInput | SortOrder
    intraday_limit?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    product_transaction_limit?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    _relevance?: counterparty_limitsOrderByRelevanceInput
  }

  export type counterparty_limitsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: counterparty_limitsWhereInput | counterparty_limitsWhereInput[]
    OR?: counterparty_limitsWhereInput[]
    NOT?: counterparty_limitsWhereInput | counterparty_limitsWhereInput[]
    counterparty_id?: IntFilter<"counterparty_limits"> | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeFilter<"counterparty_limits"> | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    currency_limit?: StringNullableFilter<"counterparty_limits"> | string | null
    product_money_market_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    country_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    group_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"counterparty_limits"> | Date | string | null
    product_transaction_limit?: DecimalNullableFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"counterparty_limits"> | string | null
  }, "id">

  export type counterparty_limitsOrderByWithAggregationInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    counterparty_type?: SortOrder
    overall_exposure_limit?: SortOrderInput | SortOrder
    currency_limit?: SortOrderInput | SortOrder
    product_money_market_limit?: SortOrderInput | SortOrder
    product_fx_limit?: SortOrderInput | SortOrder
    product_derivative_limit?: SortOrderInput | SortOrder
    product_repo_limit?: SortOrderInput | SortOrder
    product_reverse_repo_limit?: SortOrderInput | SortOrder
    product_gsec_limit?: SortOrderInput | SortOrder
    product_sell_and_buy_back_limit?: SortOrderInput | SortOrder
    product_buy_and_sell_back_limit?: SortOrderInput | SortOrder
    tenor_limit?: SortOrderInput | SortOrder
    settlement_risk_limit?: SortOrderInput | SortOrder
    country_limit?: SortOrderInput | SortOrder
    group_limit?: SortOrderInput | SortOrder
    intraday_limit?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    product_transaction_limit?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    _count?: counterparty_limitsCountOrderByAggregateInput
    _avg?: counterparty_limitsAvgOrderByAggregateInput
    _max?: counterparty_limitsMaxOrderByAggregateInput
    _min?: counterparty_limitsMinOrderByAggregateInput
    _sum?: counterparty_limitsSumOrderByAggregateInput
  }

  export type counterparty_limitsScalarWhereWithAggregatesInput = {
    AND?: counterparty_limitsScalarWhereWithAggregatesInput | counterparty_limitsScalarWhereWithAggregatesInput[]
    OR?: counterparty_limitsScalarWhereWithAggregatesInput[]
    NOT?: counterparty_limitsScalarWhereWithAggregatesInput | counterparty_limitsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"counterparty_limits"> | number
    counterparty_id?: IntWithAggregatesFilter<"counterparty_limits"> | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeWithAggregatesFilter<"counterparty_limits"> | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    currency_limit?: StringNullableWithAggregatesFilter<"counterparty_limits"> | string | null
    product_money_market_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    country_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    group_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"counterparty_limits"> | Date | string | null
    product_transaction_limit?: DecimalNullableWithAggregatesFilter<"counterparty_limits"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"counterparty_limits"> | string | null
  }

  export type counterparty_master_individualWhereInput = {
    AND?: counterparty_master_individualWhereInput | counterparty_master_individualWhereInput[]
    OR?: counterparty_master_individualWhereInput[]
    NOT?: counterparty_master_individualWhereInput | counterparty_master_individualWhereInput[]
    id?: IntFilter<"counterparty_master_individual"> | number
    title?: StringNullableFilter<"counterparty_master_individual"> | string | null
    short_name?: StringNullableFilter<"counterparty_master_individual"> | string | null
    long_name?: StringNullableFilter<"counterparty_master_individual"> | string | null
    id_type?: StringNullableFilter<"counterparty_master_individual"> | string | null
    house_number?: StringNullableFilter<"counterparty_master_individual"> | string | null
    street_name?: StringNullableFilter<"counterparty_master_individual"> | string | null
    province?: StringNullableFilter<"counterparty_master_individual"> | string | null
    postal_code?: StringNullableFilter<"counterparty_master_individual"> | string | null
    city?: StringNullableFilter<"counterparty_master_individual"> | string | null
    country?: StringNullableFilter<"counterparty_master_individual"> | string | null
    telephone?: StringNullableFilter<"counterparty_master_individual"> | string | null
    email?: StringNullableFilter<"counterparty_master_individual"> | string | null
    mobile?: StringNullableFilter<"counterparty_master_individual"> | string | null
    created_at?: DateTimeNullableFilter<"counterparty_master_individual"> | Date | string | null
  }

  export type counterparty_master_individualOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    short_name?: SortOrderInput | SortOrder
    long_name?: SortOrderInput | SortOrder
    id_type?: SortOrderInput | SortOrder
    house_number?: SortOrderInput | SortOrder
    street_name?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: counterparty_master_individualOrderByRelevanceInput
  }

  export type counterparty_master_individualWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: counterparty_master_individualWhereInput | counterparty_master_individualWhereInput[]
    OR?: counterparty_master_individualWhereInput[]
    NOT?: counterparty_master_individualWhereInput | counterparty_master_individualWhereInput[]
    title?: StringNullableFilter<"counterparty_master_individual"> | string | null
    short_name?: StringNullableFilter<"counterparty_master_individual"> | string | null
    long_name?: StringNullableFilter<"counterparty_master_individual"> | string | null
    id_type?: StringNullableFilter<"counterparty_master_individual"> | string | null
    house_number?: StringNullableFilter<"counterparty_master_individual"> | string | null
    street_name?: StringNullableFilter<"counterparty_master_individual"> | string | null
    province?: StringNullableFilter<"counterparty_master_individual"> | string | null
    postal_code?: StringNullableFilter<"counterparty_master_individual"> | string | null
    city?: StringNullableFilter<"counterparty_master_individual"> | string | null
    country?: StringNullableFilter<"counterparty_master_individual"> | string | null
    telephone?: StringNullableFilter<"counterparty_master_individual"> | string | null
    email?: StringNullableFilter<"counterparty_master_individual"> | string | null
    mobile?: StringNullableFilter<"counterparty_master_individual"> | string | null
    created_at?: DateTimeNullableFilter<"counterparty_master_individual"> | Date | string | null
  }, "id">

  export type counterparty_master_individualOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    short_name?: SortOrderInput | SortOrder
    long_name?: SortOrderInput | SortOrder
    id_type?: SortOrderInput | SortOrder
    house_number?: SortOrderInput | SortOrder
    street_name?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: counterparty_master_individualCountOrderByAggregateInput
    _avg?: counterparty_master_individualAvgOrderByAggregateInput
    _max?: counterparty_master_individualMaxOrderByAggregateInput
    _min?: counterparty_master_individualMinOrderByAggregateInput
    _sum?: counterparty_master_individualSumOrderByAggregateInput
  }

  export type counterparty_master_individualScalarWhereWithAggregatesInput = {
    AND?: counterparty_master_individualScalarWhereWithAggregatesInput | counterparty_master_individualScalarWhereWithAggregatesInput[]
    OR?: counterparty_master_individualScalarWhereWithAggregatesInput[]
    NOT?: counterparty_master_individualScalarWhereWithAggregatesInput | counterparty_master_individualScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"counterparty_master_individual"> | number
    title?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    short_name?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    long_name?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    id_type?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    house_number?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    street_name?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    province?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    city?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    country?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    email?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"counterparty_master_individual"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"counterparty_master_individual"> | Date | string | null
  }

  export type counterparty_master_jointWhereInput = {
    AND?: counterparty_master_jointWhereInput | counterparty_master_jointWhereInput[]
    OR?: counterparty_master_jointWhereInput[]
    NOT?: counterparty_master_jointWhereInput | counterparty_master_jointWhereInput[]
    id?: IntFilter<"counterparty_master_joint"> | number
    title?: StringFilter<"counterparty_master_joint"> | string
    short_name?: StringNullableFilter<"counterparty_master_joint"> | string | null
    long_name?: StringNullableFilter<"counterparty_master_joint"> | string | null
    id_type?: StringFilter<"counterparty_master_joint"> | string
    house_number?: StringNullableFilter<"counterparty_master_joint"> | string | null
    street_name?: StringNullableFilter<"counterparty_master_joint"> | string | null
    province?: StringNullableFilter<"counterparty_master_joint"> | string | null
    postal_code?: StringNullableFilter<"counterparty_master_joint"> | string | null
    city?: StringNullableFilter<"counterparty_master_joint"> | string | null
    country?: StringNullableFilter<"counterparty_master_joint"> | string | null
    telephone?: StringNullableFilter<"counterparty_master_joint"> | string | null
    email?: StringNullableFilter<"counterparty_master_joint"> | string | null
    mobile?: StringNullableFilter<"counterparty_master_joint"> | string | null
    created_at?: DateTimeNullableFilter<"counterparty_master_joint"> | Date | string | null
  }

  export type counterparty_master_jointOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrderInput | SortOrder
    long_name?: SortOrderInput | SortOrder
    id_type?: SortOrder
    house_number?: SortOrderInput | SortOrder
    street_name?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: counterparty_master_jointOrderByRelevanceInput
  }

  export type counterparty_master_jointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: counterparty_master_jointWhereInput | counterparty_master_jointWhereInput[]
    OR?: counterparty_master_jointWhereInput[]
    NOT?: counterparty_master_jointWhereInput | counterparty_master_jointWhereInput[]
    title?: StringFilter<"counterparty_master_joint"> | string
    short_name?: StringNullableFilter<"counterparty_master_joint"> | string | null
    long_name?: StringNullableFilter<"counterparty_master_joint"> | string | null
    id_type?: StringFilter<"counterparty_master_joint"> | string
    house_number?: StringNullableFilter<"counterparty_master_joint"> | string | null
    street_name?: StringNullableFilter<"counterparty_master_joint"> | string | null
    province?: StringNullableFilter<"counterparty_master_joint"> | string | null
    postal_code?: StringNullableFilter<"counterparty_master_joint"> | string | null
    city?: StringNullableFilter<"counterparty_master_joint"> | string | null
    country?: StringNullableFilter<"counterparty_master_joint"> | string | null
    telephone?: StringNullableFilter<"counterparty_master_joint"> | string | null
    email?: StringNullableFilter<"counterparty_master_joint"> | string | null
    mobile?: StringNullableFilter<"counterparty_master_joint"> | string | null
    created_at?: DateTimeNullableFilter<"counterparty_master_joint"> | Date | string | null
  }, "id">

  export type counterparty_master_jointOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrderInput | SortOrder
    long_name?: SortOrderInput | SortOrder
    id_type?: SortOrder
    house_number?: SortOrderInput | SortOrder
    street_name?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: counterparty_master_jointCountOrderByAggregateInput
    _avg?: counterparty_master_jointAvgOrderByAggregateInput
    _max?: counterparty_master_jointMaxOrderByAggregateInput
    _min?: counterparty_master_jointMinOrderByAggregateInput
    _sum?: counterparty_master_jointSumOrderByAggregateInput
  }

  export type counterparty_master_jointScalarWhereWithAggregatesInput = {
    AND?: counterparty_master_jointScalarWhereWithAggregatesInput | counterparty_master_jointScalarWhereWithAggregatesInput[]
    OR?: counterparty_master_jointScalarWhereWithAggregatesInput[]
    NOT?: counterparty_master_jointScalarWhereWithAggregatesInput | counterparty_master_jointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"counterparty_master_joint"> | number
    title?: StringWithAggregatesFilter<"counterparty_master_joint"> | string
    short_name?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    long_name?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    id_type?: StringWithAggregatesFilter<"counterparty_master_joint"> | string
    house_number?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    street_name?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    province?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    city?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    country?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    email?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"counterparty_master_joint"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"counterparty_master_joint"> | Date | string | null
  }

  export type gsecWhereInput = {
    AND?: gsecWhereInput | gsecWhereInput[]
    OR?: gsecWhereInput[]
    NOT?: gsecWhereInput | gsecWhereInput[]
    id?: IntFilter<"gsec"> | number
    trade_type?: StringNullableFilter<"gsec"> | string | null
    transaction_type?: StringNullableFilter<"gsec"> | string | null
    counterparty?: StringNullableFilter<"gsec"> | string | null
    deal_number?: StringNullableFilter<"gsec"> | string | null
    isin?: StringNullableFilter<"gsec"> | string | null
    face_value?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    value_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    next_coupon_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    last_coupon_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    number_of_days_interest_accrued?: IntNullableFilter<"gsec"> | number | null
    number_of_days_for_coupon_period?: IntNullableFilter<"gsec"> | number | null
    accrued_interest?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    clean_price?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    dirty_price?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: StringNullableFilter<"gsec"> | string | null
    issue_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    maturity_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    coupon_dates?: StringNullableFilter<"gsec"> | string | null
    yield?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    portfolio?: StringNullableFilter<"gsec"> | string | null
    clean_price_adjustment?: StringNullableFilter<"gsec"> | string | null
    accrued_interest_adjustment?: StringNullableFilter<"gsec"> | string | null
    broker?: StringNullableFilter<"gsec"> | string | null
    strategy?: StringNullableFilter<"gsec"> | string | null
    status?: StringNullableFilter<"gsec"> | string | null
    comment?: StringNullableFilter<"gsec"> | string | null
    created_by?: IntNullableFilter<"gsec"> | number | null
    stratergy?: StringNullableFilter<"gsec"> | string | null
    created_at?: DateTimeNullableFilter<"gsec"> | Date | string | null
    updated_by?: IntNullableFilter<"gsec"> | number | null
    updated_at?: DateTimeNullableFilter<"gsec"> | Date | string | null
    authorized_by?: IntNullableFilter<"gsec"> | number | null
    authorized_at?: DateTimeNullableFilter<"gsec"> | Date | string | null
    brokerage?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"gsec"> | string
  }

  export type gsecOrderByWithRelationInput = {
    id?: SortOrder
    trade_type?: SortOrderInput | SortOrder
    transaction_type?: SortOrderInput | SortOrder
    counterparty?: SortOrderInput | SortOrder
    deal_number?: SortOrderInput | SortOrder
    isin?: SortOrderInput | SortOrder
    face_value?: SortOrderInput | SortOrder
    value_date?: SortOrderInput | SortOrder
    next_coupon_date?: SortOrderInput | SortOrder
    last_coupon_date?: SortOrderInput | SortOrder
    number_of_days_interest_accrued?: SortOrderInput | SortOrder
    number_of_days_for_coupon_period?: SortOrderInput | SortOrder
    accrued_interest?: SortOrderInput | SortOrder
    coupon_interest?: SortOrderInput | SortOrder
    clean_price?: SortOrderInput | SortOrder
    dirty_price?: SortOrderInput | SortOrder
    accrued_interest_calculation?: SortOrderInput | SortOrder
    accrued_interest_six_decimals?: SortOrderInput | SortOrder
    accrued_interest_for_100?: SortOrderInput | SortOrder
    settlement_amount?: SortOrderInput | SortOrder
    settlement_mode?: SortOrderInput | SortOrder
    issue_date?: SortOrderInput | SortOrder
    maturity_date?: SortOrderInput | SortOrder
    coupon_dates?: SortOrderInput | SortOrder
    yield?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    clean_price_adjustment?: SortOrderInput | SortOrder
    accrued_interest_adjustment?: SortOrderInput | SortOrder
    broker?: SortOrderInput | SortOrder
    strategy?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    stratergy?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    authorized_by?: SortOrderInput | SortOrder
    authorized_at?: SortOrderInput | SortOrder
    brokerage?: SortOrderInput | SortOrder
    currency?: SortOrder
    _relevance?: gsecOrderByRelevanceInput
  }

  export type gsecWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: gsecWhereInput | gsecWhereInput[]
    OR?: gsecWhereInput[]
    NOT?: gsecWhereInput | gsecWhereInput[]
    trade_type?: StringNullableFilter<"gsec"> | string | null
    transaction_type?: StringNullableFilter<"gsec"> | string | null
    counterparty?: StringNullableFilter<"gsec"> | string | null
    deal_number?: StringNullableFilter<"gsec"> | string | null
    isin?: StringNullableFilter<"gsec"> | string | null
    face_value?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    value_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    next_coupon_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    last_coupon_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    number_of_days_interest_accrued?: IntNullableFilter<"gsec"> | number | null
    number_of_days_for_coupon_period?: IntNullableFilter<"gsec"> | number | null
    accrued_interest?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    clean_price?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    dirty_price?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: StringNullableFilter<"gsec"> | string | null
    issue_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    maturity_date?: DateTimeNullableFilter<"gsec"> | Date | string | null
    coupon_dates?: StringNullableFilter<"gsec"> | string | null
    yield?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    portfolio?: StringNullableFilter<"gsec"> | string | null
    clean_price_adjustment?: StringNullableFilter<"gsec"> | string | null
    accrued_interest_adjustment?: StringNullableFilter<"gsec"> | string | null
    broker?: StringNullableFilter<"gsec"> | string | null
    strategy?: StringNullableFilter<"gsec"> | string | null
    status?: StringNullableFilter<"gsec"> | string | null
    comment?: StringNullableFilter<"gsec"> | string | null
    created_by?: IntNullableFilter<"gsec"> | number | null
    stratergy?: StringNullableFilter<"gsec"> | string | null
    created_at?: DateTimeNullableFilter<"gsec"> | Date | string | null
    updated_by?: IntNullableFilter<"gsec"> | number | null
    updated_at?: DateTimeNullableFilter<"gsec"> | Date | string | null
    authorized_by?: IntNullableFilter<"gsec"> | number | null
    authorized_at?: DateTimeNullableFilter<"gsec"> | Date | string | null
    brokerage?: DecimalNullableFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"gsec"> | string
  }, "id">

  export type gsecOrderByWithAggregationInput = {
    id?: SortOrder
    trade_type?: SortOrderInput | SortOrder
    transaction_type?: SortOrderInput | SortOrder
    counterparty?: SortOrderInput | SortOrder
    deal_number?: SortOrderInput | SortOrder
    isin?: SortOrderInput | SortOrder
    face_value?: SortOrderInput | SortOrder
    value_date?: SortOrderInput | SortOrder
    next_coupon_date?: SortOrderInput | SortOrder
    last_coupon_date?: SortOrderInput | SortOrder
    number_of_days_interest_accrued?: SortOrderInput | SortOrder
    number_of_days_for_coupon_period?: SortOrderInput | SortOrder
    accrued_interest?: SortOrderInput | SortOrder
    coupon_interest?: SortOrderInput | SortOrder
    clean_price?: SortOrderInput | SortOrder
    dirty_price?: SortOrderInput | SortOrder
    accrued_interest_calculation?: SortOrderInput | SortOrder
    accrued_interest_six_decimals?: SortOrderInput | SortOrder
    accrued_interest_for_100?: SortOrderInput | SortOrder
    settlement_amount?: SortOrderInput | SortOrder
    settlement_mode?: SortOrderInput | SortOrder
    issue_date?: SortOrderInput | SortOrder
    maturity_date?: SortOrderInput | SortOrder
    coupon_dates?: SortOrderInput | SortOrder
    yield?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    clean_price_adjustment?: SortOrderInput | SortOrder
    accrued_interest_adjustment?: SortOrderInput | SortOrder
    broker?: SortOrderInput | SortOrder
    strategy?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    stratergy?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    authorized_by?: SortOrderInput | SortOrder
    authorized_at?: SortOrderInput | SortOrder
    brokerage?: SortOrderInput | SortOrder
    currency?: SortOrder
    _count?: gsecCountOrderByAggregateInput
    _avg?: gsecAvgOrderByAggregateInput
    _max?: gsecMaxOrderByAggregateInput
    _min?: gsecMinOrderByAggregateInput
    _sum?: gsecSumOrderByAggregateInput
  }

  export type gsecScalarWhereWithAggregatesInput = {
    AND?: gsecScalarWhereWithAggregatesInput | gsecScalarWhereWithAggregatesInput[]
    OR?: gsecScalarWhereWithAggregatesInput[]
    NOT?: gsecScalarWhereWithAggregatesInput | gsecScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"gsec"> | number
    trade_type?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    transaction_type?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    counterparty?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    deal_number?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    isin?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    face_value?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    value_date?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    next_coupon_date?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    last_coupon_date?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    number_of_days_interest_accrued?: IntNullableWithAggregatesFilter<"gsec"> | number | null
    number_of_days_for_coupon_period?: IntNullableWithAggregatesFilter<"gsec"> | number | null
    accrued_interest?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    clean_price?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    dirty_price?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    issue_date?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    maturity_date?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    coupon_dates?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    yield?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    portfolio?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    clean_price_adjustment?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    accrued_interest_adjustment?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    broker?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    strategy?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    status?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    comment?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    created_by?: IntNullableWithAggregatesFilter<"gsec"> | number | null
    stratergy?: StringNullableWithAggregatesFilter<"gsec"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    updated_by?: IntNullableWithAggregatesFilter<"gsec"> | number | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    authorized_by?: IntNullableWithAggregatesFilter<"gsec"> | number | null
    authorized_at?: DateTimeNullableWithAggregatesFilter<"gsec"> | Date | string | null
    brokerage?: DecimalNullableWithAggregatesFilter<"gsec"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"gsec"> | string
  }

  export type isin_coupon_scheduleWhereInput = {
    AND?: isin_coupon_scheduleWhereInput | isin_coupon_scheduleWhereInput[]
    OR?: isin_coupon_scheduleWhereInput[]
    NOT?: isin_coupon_scheduleWhereInput | isin_coupon_scheduleWhereInput[]
    id?: IntFilter<"isin_coupon_schedule"> | number
    isin?: StringFilter<"isin_coupon_schedule"> | string
    coupon_number?: IntFilter<"isin_coupon_schedule"> | number
    coupon_date?: DateTimeFilter<"isin_coupon_schedule"> | Date | string
    coupon_amount?: DecimalFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string
    principal?: DecimalNullableFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string | null
    isin_master?: XOR<Isin_masterScalarRelationFilter, isin_masterWhereInput>
  }

  export type isin_coupon_scheduleOrderByWithRelationInput = {
    id?: SortOrder
    isin?: SortOrder
    coupon_number?: SortOrder
    coupon_date?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrderInput | SortOrder
    isin_master?: isin_masterOrderByWithRelationInput
    _relevance?: isin_coupon_scheduleOrderByRelevanceInput
  }

  export type isin_coupon_scheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: isin_coupon_scheduleWhereInput | isin_coupon_scheduleWhereInput[]
    OR?: isin_coupon_scheduleWhereInput[]
    NOT?: isin_coupon_scheduleWhereInput | isin_coupon_scheduleWhereInput[]
    isin?: StringFilter<"isin_coupon_schedule"> | string
    coupon_number?: IntFilter<"isin_coupon_schedule"> | number
    coupon_date?: DateTimeFilter<"isin_coupon_schedule"> | Date | string
    coupon_amount?: DecimalFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string
    principal?: DecimalNullableFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string | null
    isin_master?: XOR<Isin_masterScalarRelationFilter, isin_masterWhereInput>
  }, "id">

  export type isin_coupon_scheduleOrderByWithAggregationInput = {
    id?: SortOrder
    isin?: SortOrder
    coupon_number?: SortOrder
    coupon_date?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrderInput | SortOrder
    _count?: isin_coupon_scheduleCountOrderByAggregateInput
    _avg?: isin_coupon_scheduleAvgOrderByAggregateInput
    _max?: isin_coupon_scheduleMaxOrderByAggregateInput
    _min?: isin_coupon_scheduleMinOrderByAggregateInput
    _sum?: isin_coupon_scheduleSumOrderByAggregateInput
  }

  export type isin_coupon_scheduleScalarWhereWithAggregatesInput = {
    AND?: isin_coupon_scheduleScalarWhereWithAggregatesInput | isin_coupon_scheduleScalarWhereWithAggregatesInput[]
    OR?: isin_coupon_scheduleScalarWhereWithAggregatesInput[]
    NOT?: isin_coupon_scheduleScalarWhereWithAggregatesInput | isin_coupon_scheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"isin_coupon_schedule"> | number
    isin?: StringWithAggregatesFilter<"isin_coupon_schedule"> | string
    coupon_number?: IntWithAggregatesFilter<"isin_coupon_schedule"> | number
    coupon_date?: DateTimeWithAggregatesFilter<"isin_coupon_schedule"> | Date | string
    coupon_amount?: DecimalWithAggregatesFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string
    principal?: DecimalNullableWithAggregatesFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string | null
  }

  export type isin_masterWhereInput = {
    AND?: isin_masterWhereInput | isin_masterWhereInput[]
    OR?: isin_masterWhereInput[]
    NOT?: isin_masterWhereInput | isin_masterWhereInput[]
    id?: IntFilter<"isin_master"> | number
    isin_issuer?: StringFilter<"isin_master"> | string
    isin_number?: StringFilter<"isin_master"> | string
    issue_date?: DateTimeFilter<"isin_master"> | Date | string
    maturity_date?: DateTimeFilter<"isin_master"> | Date | string
    coupon_rate?: DecimalFilter<"isin_master"> | Decimal | DecimalJsLike | number | string
    series?: StringNullableFilter<"isin_master"> | string | null
    coupon_date_1?: DateTimeFilter<"isin_master"> | Date | string
    coupon_date_2?: DateTimeFilter<"isin_master"> | Date | string
    day_basis?: IntFilter<"isin_master"> | number
    currency?: StringFilter<"isin_master"> | string
    created_at?: DateTimeFilter<"isin_master"> | Date | string
    updated_at?: DateTimeFilter<"isin_master"> | Date | string
    isin_coupon_schedule?: Isin_coupon_scheduleListRelationFilter
  }

  export type isin_masterOrderByWithRelationInput = {
    id?: SortOrder
    isin_issuer?: SortOrder
    isin_number?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_rate?: SortOrder
    series?: SortOrderInput | SortOrder
    coupon_date_1?: SortOrder
    coupon_date_2?: SortOrder
    day_basis?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isin_coupon_schedule?: isin_coupon_scheduleOrderByRelationAggregateInput
    _relevance?: isin_masterOrderByRelevanceInput
  }

  export type isin_masterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    isin_number?: string
    AND?: isin_masterWhereInput | isin_masterWhereInput[]
    OR?: isin_masterWhereInput[]
    NOT?: isin_masterWhereInput | isin_masterWhereInput[]
    isin_issuer?: StringFilter<"isin_master"> | string
    issue_date?: DateTimeFilter<"isin_master"> | Date | string
    maturity_date?: DateTimeFilter<"isin_master"> | Date | string
    coupon_rate?: DecimalFilter<"isin_master"> | Decimal | DecimalJsLike | number | string
    series?: StringNullableFilter<"isin_master"> | string | null
    coupon_date_1?: DateTimeFilter<"isin_master"> | Date | string
    coupon_date_2?: DateTimeFilter<"isin_master"> | Date | string
    day_basis?: IntFilter<"isin_master"> | number
    currency?: StringFilter<"isin_master"> | string
    created_at?: DateTimeFilter<"isin_master"> | Date | string
    updated_at?: DateTimeFilter<"isin_master"> | Date | string
    isin_coupon_schedule?: Isin_coupon_scheduleListRelationFilter
  }, "id" | "isin_number">

  export type isin_masterOrderByWithAggregationInput = {
    id?: SortOrder
    isin_issuer?: SortOrder
    isin_number?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_rate?: SortOrder
    series?: SortOrderInput | SortOrder
    coupon_date_1?: SortOrder
    coupon_date_2?: SortOrder
    day_basis?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: isin_masterCountOrderByAggregateInput
    _avg?: isin_masterAvgOrderByAggregateInput
    _max?: isin_masterMaxOrderByAggregateInput
    _min?: isin_masterMinOrderByAggregateInput
    _sum?: isin_masterSumOrderByAggregateInput
  }

  export type isin_masterScalarWhereWithAggregatesInput = {
    AND?: isin_masterScalarWhereWithAggregatesInput | isin_masterScalarWhereWithAggregatesInput[]
    OR?: isin_masterScalarWhereWithAggregatesInput[]
    NOT?: isin_masterScalarWhereWithAggregatesInput | isin_masterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"isin_master"> | number
    isin_issuer?: StringWithAggregatesFilter<"isin_master"> | string
    isin_number?: StringWithAggregatesFilter<"isin_master"> | string
    issue_date?: DateTimeWithAggregatesFilter<"isin_master"> | Date | string
    maturity_date?: DateTimeWithAggregatesFilter<"isin_master"> | Date | string
    coupon_rate?: DecimalWithAggregatesFilter<"isin_master"> | Decimal | DecimalJsLike | number | string
    series?: StringNullableWithAggregatesFilter<"isin_master"> | string | null
    coupon_date_1?: DateTimeWithAggregatesFilter<"isin_master"> | Date | string
    coupon_date_2?: DateTimeWithAggregatesFilter<"isin_master"> | Date | string
    day_basis?: IntWithAggregatesFilter<"isin_master"> | number
    currency?: StringWithAggregatesFilter<"isin_master"> | string
    created_at?: DateTimeWithAggregatesFilter<"isin_master"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"isin_master"> | Date | string
  }

  export type ledger_entriesWhereInput = {
    AND?: ledger_entriesWhereInput | ledger_entriesWhereInput[]
    OR?: ledger_entriesWhereInput[]
    NOT?: ledger_entriesWhereInput | ledger_entriesWhereInput[]
    id?: IntFilter<"ledger_entries"> | number
    account_id?: IntFilter<"ledger_entries"> | number
    entry_date?: DateTimeFilter<"ledger_entries"> | Date | string
    debit_amount?: DecimalNullableFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    credit_amount?: DecimalNullableFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"ledger_entries"> | string | null
    description?: StringNullableFilter<"ledger_entries"> | string | null
    created_at?: DateTimeNullableFilter<"ledger_entries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ledger_entries"> | Date | string | null
    deal_number?: StringNullableFilter<"ledger_entries"> | string | null
    chart_of_accounts?: XOR<Chart_of_accountsScalarRelationFilter, chart_of_accountsWhereInput>
  }

  export type ledger_entriesOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    entry_date?: SortOrder
    debit_amount?: SortOrderInput | SortOrder
    credit_amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deal_number?: SortOrderInput | SortOrder
    chart_of_accounts?: chart_of_accountsOrderByWithRelationInput
    _relevance?: ledger_entriesOrderByRelevanceInput
  }

  export type ledger_entriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ledger_entriesWhereInput | ledger_entriesWhereInput[]
    OR?: ledger_entriesWhereInput[]
    NOT?: ledger_entriesWhereInput | ledger_entriesWhereInput[]
    account_id?: IntFilter<"ledger_entries"> | number
    entry_date?: DateTimeFilter<"ledger_entries"> | Date | string
    debit_amount?: DecimalNullableFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    credit_amount?: DecimalNullableFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"ledger_entries"> | string | null
    description?: StringNullableFilter<"ledger_entries"> | string | null
    created_at?: DateTimeNullableFilter<"ledger_entries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ledger_entries"> | Date | string | null
    deal_number?: StringNullableFilter<"ledger_entries"> | string | null
    chart_of_accounts?: XOR<Chart_of_accountsScalarRelationFilter, chart_of_accountsWhereInput>
  }, "id">

  export type ledger_entriesOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    entry_date?: SortOrder
    debit_amount?: SortOrderInput | SortOrder
    credit_amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deal_number?: SortOrderInput | SortOrder
    _count?: ledger_entriesCountOrderByAggregateInput
    _avg?: ledger_entriesAvgOrderByAggregateInput
    _max?: ledger_entriesMaxOrderByAggregateInput
    _min?: ledger_entriesMinOrderByAggregateInput
    _sum?: ledger_entriesSumOrderByAggregateInput
  }

  export type ledger_entriesScalarWhereWithAggregatesInput = {
    AND?: ledger_entriesScalarWhereWithAggregatesInput | ledger_entriesScalarWhereWithAggregatesInput[]
    OR?: ledger_entriesScalarWhereWithAggregatesInput[]
    NOT?: ledger_entriesScalarWhereWithAggregatesInput | ledger_entriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ledger_entries"> | number
    account_id?: IntWithAggregatesFilter<"ledger_entries"> | number
    entry_date?: DateTimeWithAggregatesFilter<"ledger_entries"> | Date | string
    debit_amount?: DecimalNullableWithAggregatesFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    credit_amount?: DecimalNullableWithAggregatesFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"ledger_entries"> | string | null
    description?: StringNullableWithAggregatesFilter<"ledger_entries"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ledger_entries"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ledger_entries"> | Date | string | null
    deal_number?: StringNullableWithAggregatesFilter<"ledger_entries"> | string | null
  }

  export type money_market_dealsWhereInput = {
    AND?: money_market_dealsWhereInput | money_market_dealsWhereInput[]
    OR?: money_market_dealsWhereInput[]
    NOT?: money_market_dealsWhereInput | money_market_dealsWhereInput[]
    id?: IntFilter<"money_market_deals"> | number
    deal_number?: StringFilter<"money_market_deals"> | string
    trade_date?: DateTimeFilter<"money_market_deals"> | Date | string
    value_date?: DateTimeFilter<"money_market_deals"> | Date | string
    maturity_date?: DateTimeFilter<"money_market_deals"> | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeFilter<"money_market_deals"> | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntFilter<"money_market_deals"> | number
    product_type?: StringFilter<"money_market_deals"> | string
    currency?: StringFilter<"money_market_deals"> | string
    principal_amount?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    tenor?: IntFilter<"money_market_deals"> | number
    interest_amount?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    settlement_mode?: StringNullableFilter<"money_market_deals"> | string | null
    remarks?: StringNullableFilter<"money_market_deals"> | string | null
    created_at?: DateTimeNullableFilter<"money_market_deals"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"money_market_deals"> | Date | string | null
  }

  export type money_market_dealsOrderByWithRelationInput = {
    id?: SortOrder
    deal_number?: SortOrder
    trade_date?: SortOrder
    value_date?: SortOrder
    maturity_date?: SortOrder
    counterparty_type?: SortOrder
    counterparty_id?: SortOrder
    product_type?: SortOrder
    currency?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
    settlement_mode?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: money_market_dealsOrderByRelevanceInput
  }

  export type money_market_dealsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    deal_number?: string
    AND?: money_market_dealsWhereInput | money_market_dealsWhereInput[]
    OR?: money_market_dealsWhereInput[]
    NOT?: money_market_dealsWhereInput | money_market_dealsWhereInput[]
    trade_date?: DateTimeFilter<"money_market_deals"> | Date | string
    value_date?: DateTimeFilter<"money_market_deals"> | Date | string
    maturity_date?: DateTimeFilter<"money_market_deals"> | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeFilter<"money_market_deals"> | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntFilter<"money_market_deals"> | number
    product_type?: StringFilter<"money_market_deals"> | string
    currency?: StringFilter<"money_market_deals"> | string
    principal_amount?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    tenor?: IntFilter<"money_market_deals"> | number
    interest_amount?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    settlement_mode?: StringNullableFilter<"money_market_deals"> | string | null
    remarks?: StringNullableFilter<"money_market_deals"> | string | null
    created_at?: DateTimeNullableFilter<"money_market_deals"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"money_market_deals"> | Date | string | null
  }, "id" | "deal_number">

  export type money_market_dealsOrderByWithAggregationInput = {
    id?: SortOrder
    deal_number?: SortOrder
    trade_date?: SortOrder
    value_date?: SortOrder
    maturity_date?: SortOrder
    counterparty_type?: SortOrder
    counterparty_id?: SortOrder
    product_type?: SortOrder
    currency?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
    settlement_mode?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: money_market_dealsCountOrderByAggregateInput
    _avg?: money_market_dealsAvgOrderByAggregateInput
    _max?: money_market_dealsMaxOrderByAggregateInput
    _min?: money_market_dealsMinOrderByAggregateInput
    _sum?: money_market_dealsSumOrderByAggregateInput
  }

  export type money_market_dealsScalarWhereWithAggregatesInput = {
    AND?: money_market_dealsScalarWhereWithAggregatesInput | money_market_dealsScalarWhereWithAggregatesInput[]
    OR?: money_market_dealsScalarWhereWithAggregatesInput[]
    NOT?: money_market_dealsScalarWhereWithAggregatesInput | money_market_dealsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"money_market_deals"> | number
    deal_number?: StringWithAggregatesFilter<"money_market_deals"> | string
    trade_date?: DateTimeWithAggregatesFilter<"money_market_deals"> | Date | string
    value_date?: DateTimeWithAggregatesFilter<"money_market_deals"> | Date | string
    maturity_date?: DateTimeWithAggregatesFilter<"money_market_deals"> | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeWithAggregatesFilter<"money_market_deals"> | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntWithAggregatesFilter<"money_market_deals"> | number
    product_type?: StringWithAggregatesFilter<"money_market_deals"> | string
    currency?: StringWithAggregatesFilter<"money_market_deals"> | string
    principal_amount?: DecimalWithAggregatesFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalWithAggregatesFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    tenor?: IntWithAggregatesFilter<"money_market_deals"> | number
    interest_amount?: DecimalWithAggregatesFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalWithAggregatesFilter<"money_market_deals"> | Decimal | DecimalJsLike | number | string
    settlement_mode?: StringNullableWithAggregatesFilter<"money_market_deals"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"money_market_deals"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"money_market_deals"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"money_market_deals"> | Date | string | null
  }

  export type portfolio_masterWhereInput = {
    AND?: portfolio_masterWhereInput | portfolio_masterWhereInput[]
    OR?: portfolio_masterWhereInput[]
    NOT?: portfolio_masterWhereInput | portfolio_masterWhereInput[]
    portfolio_id?: StringFilter<"portfolio_master"> | string
    portfolio_name?: StringFilter<"portfolio_master"> | string
    portfolio_type?: StringNullableFilter<"portfolio_master"> | string | null
    entity_business_unit?: StringNullableFilter<"portfolio_master"> | string | null
    fund_manager_user_id?: StringNullableFilter<"portfolio_master"> | string | null
    base_currency?: StringNullableFilter<"portfolio_master"> | string | null
    benchmark?: StringNullableFilter<"portfolio_master"> | string | null
    start_date?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    end_date?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    status?: Enumportfolio_master_statusNullableFilter<"portfolio_master"> | $Enums.portfolio_master_status | null
    risk_profile?: Enumportfolio_master_risk_profileNullableFilter<"portfolio_master"> | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: Enumportfolio_master_investment_horizonNullableFilter<"portfolio_master"> | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: DecimalNullableFilter<"portfolio_master"> | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: StringNullableFilter<"portfolio_master"> | string | null
    notes_description?: StringNullableFilter<"portfolio_master"> | string | null
    parent_portfolio_id?: StringNullableFilter<"portfolio_master"> | string | null
    valuation_method?: StringNullableFilter<"portfolio_master"> | string | null
    accounting_treatment?: StringNullableFilter<"portfolio_master"> | string | null
    rebalancing_frequency?: StringNullableFilter<"portfolio_master"> | string | null
    external_reference_code?: StringNullableFilter<"portfolio_master"> | string | null
    tags_categories?: StringNullableFilter<"portfolio_master"> | string | null
    created_at?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    portfolio_master?: XOR<Portfolio_masterNullableScalarRelationFilter, portfolio_masterWhereInput> | null
    other_portfolio_master?: Portfolio_masterListRelationFilter
  }

  export type portfolio_masterOrderByWithRelationInput = {
    portfolio_id?: SortOrder
    portfolio_name?: SortOrder
    portfolio_type?: SortOrderInput | SortOrder
    entity_business_unit?: SortOrderInput | SortOrder
    fund_manager_user_id?: SortOrderInput | SortOrder
    base_currency?: SortOrderInput | SortOrder
    benchmark?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    risk_profile?: SortOrderInput | SortOrder
    investment_horizon?: SortOrderInput | SortOrder
    target_yield_return?: SortOrderInput | SortOrder
    compliance_rules_id?: SortOrderInput | SortOrder
    notes_description?: SortOrderInput | SortOrder
    parent_portfolio_id?: SortOrderInput | SortOrder
    valuation_method?: SortOrderInput | SortOrder
    accounting_treatment?: SortOrderInput | SortOrder
    rebalancing_frequency?: SortOrderInput | SortOrder
    external_reference_code?: SortOrderInput | SortOrder
    tags_categories?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    portfolio_master?: portfolio_masterOrderByWithRelationInput
    other_portfolio_master?: portfolio_masterOrderByRelationAggregateInput
    _relevance?: portfolio_masterOrderByRelevanceInput
  }

  export type portfolio_masterWhereUniqueInput = Prisma.AtLeast<{
    portfolio_id?: string
    AND?: portfolio_masterWhereInput | portfolio_masterWhereInput[]
    OR?: portfolio_masterWhereInput[]
    NOT?: portfolio_masterWhereInput | portfolio_masterWhereInput[]
    portfolio_name?: StringFilter<"portfolio_master"> | string
    portfolio_type?: StringNullableFilter<"portfolio_master"> | string | null
    entity_business_unit?: StringNullableFilter<"portfolio_master"> | string | null
    fund_manager_user_id?: StringNullableFilter<"portfolio_master"> | string | null
    base_currency?: StringNullableFilter<"portfolio_master"> | string | null
    benchmark?: StringNullableFilter<"portfolio_master"> | string | null
    start_date?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    end_date?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    status?: Enumportfolio_master_statusNullableFilter<"portfolio_master"> | $Enums.portfolio_master_status | null
    risk_profile?: Enumportfolio_master_risk_profileNullableFilter<"portfolio_master"> | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: Enumportfolio_master_investment_horizonNullableFilter<"portfolio_master"> | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: DecimalNullableFilter<"portfolio_master"> | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: StringNullableFilter<"portfolio_master"> | string | null
    notes_description?: StringNullableFilter<"portfolio_master"> | string | null
    parent_portfolio_id?: StringNullableFilter<"portfolio_master"> | string | null
    valuation_method?: StringNullableFilter<"portfolio_master"> | string | null
    accounting_treatment?: StringNullableFilter<"portfolio_master"> | string | null
    rebalancing_frequency?: StringNullableFilter<"portfolio_master"> | string | null
    external_reference_code?: StringNullableFilter<"portfolio_master"> | string | null
    tags_categories?: StringNullableFilter<"portfolio_master"> | string | null
    created_at?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    portfolio_master?: XOR<Portfolio_masterNullableScalarRelationFilter, portfolio_masterWhereInput> | null
    other_portfolio_master?: Portfolio_masterListRelationFilter
  }, "portfolio_id">

  export type portfolio_masterOrderByWithAggregationInput = {
    portfolio_id?: SortOrder
    portfolio_name?: SortOrder
    portfolio_type?: SortOrderInput | SortOrder
    entity_business_unit?: SortOrderInput | SortOrder
    fund_manager_user_id?: SortOrderInput | SortOrder
    base_currency?: SortOrderInput | SortOrder
    benchmark?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    risk_profile?: SortOrderInput | SortOrder
    investment_horizon?: SortOrderInput | SortOrder
    target_yield_return?: SortOrderInput | SortOrder
    compliance_rules_id?: SortOrderInput | SortOrder
    notes_description?: SortOrderInput | SortOrder
    parent_portfolio_id?: SortOrderInput | SortOrder
    valuation_method?: SortOrderInput | SortOrder
    accounting_treatment?: SortOrderInput | SortOrder
    rebalancing_frequency?: SortOrderInput | SortOrder
    external_reference_code?: SortOrderInput | SortOrder
    tags_categories?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: portfolio_masterCountOrderByAggregateInput
    _avg?: portfolio_masterAvgOrderByAggregateInput
    _max?: portfolio_masterMaxOrderByAggregateInput
    _min?: portfolio_masterMinOrderByAggregateInput
    _sum?: portfolio_masterSumOrderByAggregateInput
  }

  export type portfolio_masterScalarWhereWithAggregatesInput = {
    AND?: portfolio_masterScalarWhereWithAggregatesInput | portfolio_masterScalarWhereWithAggregatesInput[]
    OR?: portfolio_masterScalarWhereWithAggregatesInput[]
    NOT?: portfolio_masterScalarWhereWithAggregatesInput | portfolio_masterScalarWhereWithAggregatesInput[]
    portfolio_id?: StringWithAggregatesFilter<"portfolio_master"> | string
    portfolio_name?: StringWithAggregatesFilter<"portfolio_master"> | string
    portfolio_type?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    entity_business_unit?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    fund_manager_user_id?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    base_currency?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    benchmark?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"portfolio_master"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"portfolio_master"> | Date | string | null
    status?: Enumportfolio_master_statusNullableWithAggregatesFilter<"portfolio_master"> | $Enums.portfolio_master_status | null
    risk_profile?: Enumportfolio_master_risk_profileNullableWithAggregatesFilter<"portfolio_master"> | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: Enumportfolio_master_investment_horizonNullableWithAggregatesFilter<"portfolio_master"> | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: DecimalNullableWithAggregatesFilter<"portfolio_master"> | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    notes_description?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    parent_portfolio_id?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    valuation_method?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    accounting_treatment?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    rebalancing_frequency?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    external_reference_code?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    tags_categories?: StringNullableWithAggregatesFilter<"portfolio_master"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"portfolio_master"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"portfolio_master"> | Date | string | null
  }

  export type securitiesWhereInput = {
    AND?: securitiesWhereInput | securitiesWhereInput[]
    OR?: securitiesWhereInput[]
    NOT?: securitiesWhereInput | securitiesWhereInput[]
    id?: IntFilter<"securities"> | number
    name?: StringFilter<"securities"> | string
  }

  export type securitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: securitiesOrderByRelevanceInput
  }

  export type securitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: securitiesWhereInput | securitiesWhereInput[]
    OR?: securitiesWhereInput[]
    NOT?: securitiesWhereInput | securitiesWhereInput[]
    name?: StringFilter<"securities"> | string
  }, "id">

  export type securitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: securitiesCountOrderByAggregateInput
    _avg?: securitiesAvgOrderByAggregateInput
    _max?: securitiesMaxOrderByAggregateInput
    _min?: securitiesMinOrderByAggregateInput
    _sum?: securitiesSumOrderByAggregateInput
  }

  export type securitiesScalarWhereWithAggregatesInput = {
    AND?: securitiesScalarWhereWithAggregatesInput | securitiesScalarWhereWithAggregatesInput[]
    OR?: securitiesScalarWhereWithAggregatesInput[]
    NOT?: securitiesScalarWhereWithAggregatesInput | securitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"securities"> | number
    name?: StringWithAggregatesFilter<"securities"> | string
  }

  export type settlement_accountsWhereInput = {
    AND?: settlement_accountsWhereInput | settlement_accountsWhereInput[]
    OR?: settlement_accountsWhereInput[]
    NOT?: settlement_accountsWhereInput | settlement_accountsWhereInput[]
    id?: BigIntFilter<"settlement_accounts"> | bigint | number
    bank_name?: StringFilter<"settlement_accounts"> | string
    bank_payment_code?: StringNullableFilter<"settlement_accounts"> | string | null
    bank_code?: StringNullableFilter<"settlement_accounts"> | string | null
    address_building_number?: StringNullableFilter<"settlement_accounts"> | string | null
    address_street_name?: StringNullableFilter<"settlement_accounts"> | string | null
    address_street_name2?: StringNullableFilter<"settlement_accounts"> | string | null
    address_city?: StringNullableFilter<"settlement_accounts"> | string | null
    address_province?: StringNullableFilter<"settlement_accounts"> | string | null
    address_zip_code?: StringNullableFilter<"settlement_accounts"> | string | null
    address_country?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_name?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_phone?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_mobile?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_fax?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_email?: StringNullableFilter<"settlement_accounts"> | string | null
    account_type?: StringNullableFilter<"settlement_accounts"> | string | null
    bank_account_number?: StringNullableFilter<"settlement_accounts"> | string | null
    bank_branch?: StringNullableFilter<"settlement_accounts"> | string | null
    created_at?: DateTimeNullableFilter<"settlement_accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"settlement_accounts"> | Date | string | null
  }

  export type settlement_accountsOrderByWithRelationInput = {
    id?: SortOrder
    bank_name?: SortOrder
    bank_payment_code?: SortOrderInput | SortOrder
    bank_code?: SortOrderInput | SortOrder
    address_building_number?: SortOrderInput | SortOrder
    address_street_name?: SortOrderInput | SortOrder
    address_street_name2?: SortOrderInput | SortOrder
    address_city?: SortOrderInput | SortOrder
    address_province?: SortOrderInput | SortOrder
    address_zip_code?: SortOrderInput | SortOrder
    address_country?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    contact_mobile?: SortOrderInput | SortOrder
    contact_fax?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    bank_account_number?: SortOrderInput | SortOrder
    bank_branch?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: settlement_accountsOrderByRelevanceInput
  }

  export type settlement_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: settlement_accountsWhereInput | settlement_accountsWhereInput[]
    OR?: settlement_accountsWhereInput[]
    NOT?: settlement_accountsWhereInput | settlement_accountsWhereInput[]
    bank_name?: StringFilter<"settlement_accounts"> | string
    bank_payment_code?: StringNullableFilter<"settlement_accounts"> | string | null
    bank_code?: StringNullableFilter<"settlement_accounts"> | string | null
    address_building_number?: StringNullableFilter<"settlement_accounts"> | string | null
    address_street_name?: StringNullableFilter<"settlement_accounts"> | string | null
    address_street_name2?: StringNullableFilter<"settlement_accounts"> | string | null
    address_city?: StringNullableFilter<"settlement_accounts"> | string | null
    address_province?: StringNullableFilter<"settlement_accounts"> | string | null
    address_zip_code?: StringNullableFilter<"settlement_accounts"> | string | null
    address_country?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_name?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_phone?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_mobile?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_fax?: StringNullableFilter<"settlement_accounts"> | string | null
    contact_email?: StringNullableFilter<"settlement_accounts"> | string | null
    account_type?: StringNullableFilter<"settlement_accounts"> | string | null
    bank_account_number?: StringNullableFilter<"settlement_accounts"> | string | null
    bank_branch?: StringNullableFilter<"settlement_accounts"> | string | null
    created_at?: DateTimeNullableFilter<"settlement_accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"settlement_accounts"> | Date | string | null
  }, "id" | "id">

  export type settlement_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    bank_name?: SortOrder
    bank_payment_code?: SortOrderInput | SortOrder
    bank_code?: SortOrderInput | SortOrder
    address_building_number?: SortOrderInput | SortOrder
    address_street_name?: SortOrderInput | SortOrder
    address_street_name2?: SortOrderInput | SortOrder
    address_city?: SortOrderInput | SortOrder
    address_province?: SortOrderInput | SortOrder
    address_zip_code?: SortOrderInput | SortOrder
    address_country?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_phone?: SortOrderInput | SortOrder
    contact_mobile?: SortOrderInput | SortOrder
    contact_fax?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    bank_account_number?: SortOrderInput | SortOrder
    bank_branch?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: settlement_accountsCountOrderByAggregateInput
    _avg?: settlement_accountsAvgOrderByAggregateInput
    _max?: settlement_accountsMaxOrderByAggregateInput
    _min?: settlement_accountsMinOrderByAggregateInput
    _sum?: settlement_accountsSumOrderByAggregateInput
  }

  export type settlement_accountsScalarWhereWithAggregatesInput = {
    AND?: settlement_accountsScalarWhereWithAggregatesInput | settlement_accountsScalarWhereWithAggregatesInput[]
    OR?: settlement_accountsScalarWhereWithAggregatesInput[]
    NOT?: settlement_accountsScalarWhereWithAggregatesInput | settlement_accountsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"settlement_accounts"> | bigint | number
    bank_name?: StringWithAggregatesFilter<"settlement_accounts"> | string
    bank_payment_code?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    bank_code?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_building_number?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_street_name?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_street_name2?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_city?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_province?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_zip_code?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    address_country?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    contact_name?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    contact_phone?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    contact_mobile?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    contact_fax?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    account_type?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    bank_account_number?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    bank_branch?: StringNullableWithAggregatesFilter<"settlement_accounts"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"settlement_accounts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"settlement_accounts"> | Date | string | null
  }

  export type strategy_masterWhereInput = {
    AND?: strategy_masterWhereInput | strategy_masterWhereInput[]
    OR?: strategy_masterWhereInput[]
    NOT?: strategy_masterWhereInput | strategy_masterWhereInput[]
    strategy_id?: StringFilter<"strategy_master"> | string
    portfolio_name?: StringFilter<"strategy_master"> | string
    strategy_type?: StringNullableFilter<"strategy_master"> | string | null
    entity_business_unit?: StringNullableFilter<"strategy_master"> | string | null
  }

  export type strategy_masterOrderByWithRelationInput = {
    strategy_id?: SortOrder
    portfolio_name?: SortOrder
    strategy_type?: SortOrderInput | SortOrder
    entity_business_unit?: SortOrderInput | SortOrder
    _relevance?: strategy_masterOrderByRelevanceInput
  }

  export type strategy_masterWhereUniqueInput = Prisma.AtLeast<{
    strategy_id?: string
    AND?: strategy_masterWhereInput | strategy_masterWhereInput[]
    OR?: strategy_masterWhereInput[]
    NOT?: strategy_masterWhereInput | strategy_masterWhereInput[]
    portfolio_name?: StringFilter<"strategy_master"> | string
    strategy_type?: StringNullableFilter<"strategy_master"> | string | null
    entity_business_unit?: StringNullableFilter<"strategy_master"> | string | null
  }, "strategy_id">

  export type strategy_masterOrderByWithAggregationInput = {
    strategy_id?: SortOrder
    portfolio_name?: SortOrder
    strategy_type?: SortOrderInput | SortOrder
    entity_business_unit?: SortOrderInput | SortOrder
    _count?: strategy_masterCountOrderByAggregateInput
    _max?: strategy_masterMaxOrderByAggregateInput
    _min?: strategy_masterMinOrderByAggregateInput
  }

  export type strategy_masterScalarWhereWithAggregatesInput = {
    AND?: strategy_masterScalarWhereWithAggregatesInput | strategy_masterScalarWhereWithAggregatesInput[]
    OR?: strategy_masterScalarWhereWithAggregatesInput[]
    NOT?: strategy_masterScalarWhereWithAggregatesInput | strategy_masterScalarWhereWithAggregatesInput[]
    strategy_id?: StringWithAggregatesFilter<"strategy_master"> | string
    portfolio_name?: StringWithAggregatesFilter<"strategy_master"> | string
    strategy_type?: StringNullableWithAggregatesFilter<"strategy_master"> | string | null
    entity_business_unit?: StringNullableWithAggregatesFilter<"strategy_master"> | string | null
  }

  export type transaction_typesWhereInput = {
    AND?: transaction_typesWhereInput | transaction_typesWhereInput[]
    OR?: transaction_typesWhereInput[]
    NOT?: transaction_typesWhereInput | transaction_typesWhereInput[]
    id?: IntFilter<"transaction_types"> | number
    name?: StringFilter<"transaction_types"> | string
    category?: StringFilter<"transaction_types"> | string
    created_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
  }

  export type transaction_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: transaction_typesOrderByRelevanceInput
  }

  export type transaction_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transaction_typesWhereInput | transaction_typesWhereInput[]
    OR?: transaction_typesWhereInput[]
    NOT?: transaction_typesWhereInput | transaction_typesWhereInput[]
    name?: StringFilter<"transaction_types"> | string
    category?: StringFilter<"transaction_types"> | string
    created_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
  }, "id">

  export type transaction_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: transaction_typesCountOrderByAggregateInput
    _avg?: transaction_typesAvgOrderByAggregateInput
    _max?: transaction_typesMaxOrderByAggregateInput
    _min?: transaction_typesMinOrderByAggregateInput
    _sum?: transaction_typesSumOrderByAggregateInput
  }

  export type transaction_typesScalarWhereWithAggregatesInput = {
    AND?: transaction_typesScalarWhereWithAggregatesInput | transaction_typesScalarWhereWithAggregatesInput[]
    OR?: transaction_typesScalarWhereWithAggregatesInput[]
    NOT?: transaction_typesScalarWhereWithAggregatesInput | transaction_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaction_types"> | number
    name?: StringWithAggregatesFilter<"transaction_types"> | string
    category?: StringWithAggregatesFilter<"transaction_types"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"transaction_types"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"transaction_types"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    allowed_tabs?: StringNullableFilter<"users"> | string | null
    limit_id?: IntNullableFilter<"users"> | number | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrderInput | SortOrder
    allowed_tabs?: SortOrderInput | SortOrder
    limit_id?: SortOrderInput | SortOrder
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    allowed_tabs?: StringNullableFilter<"users"> | string | null
    limit_id?: IntNullableFilter<"users"> | number | null
  }, "id" | "username">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrderInput | SortOrder
    allowed_tabs?: SortOrderInput | SortOrder
    limit_id?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    username?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    role?: Enumusers_roleWithAggregatesFilter<"users"> | $Enums.users_role
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    allowed_tabs?: StringNullableWithAggregatesFilter<"users"> | string | null
    limit_id?: IntNullableWithAggregatesFilter<"users"> | number | null
  }

  export type account_typesCreateInput = {
    name: string
    category: $Enums.account_types_category
    description?: string | null
    created_at?: Date | string | null
    chart_of_accounts?: chart_of_accountsCreateNestedManyWithoutAccount_typesInput
  }

  export type account_typesUncheckedCreateInput = {
    id?: number
    name: string
    category: $Enums.account_types_category
    description?: string | null
    created_at?: Date | string | null
    chart_of_accounts?: chart_of_accountsUncheckedCreateNestedManyWithoutAccount_typesInput
  }

  export type account_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: Enumaccount_types_categoryFieldUpdateOperationsInput | $Enums.account_types_category
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chart_of_accounts?: chart_of_accountsUpdateManyWithoutAccount_typesNestedInput
  }

  export type account_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: Enumaccount_types_categoryFieldUpdateOperationsInput | $Enums.account_types_category
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chart_of_accounts?: chart_of_accountsUncheckedUpdateManyWithoutAccount_typesNestedInput
  }

  export type account_typesCreateManyInput = {
    id?: number
    name: string
    category: $Enums.account_types_category
    description?: string | null
    created_at?: Date | string | null
  }

  export type account_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: Enumaccount_types_categoryFieldUpdateOperationsInput | $Enums.account_types_category
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type account_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: Enumaccount_types_categoryFieldUpdateOperationsInput | $Enums.account_types_category
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsCreateInput = {
    name: string
    type: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type accountsUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type accountsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsCreateManyInput = {
    id?: number
    name: string
    type: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type accountsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type brokersCreateInput = {
    broker_code: string
    broker_name: string
    building_number?: string | null
    street_name?: string | null
    street_name2?: string | null
    city?: string | null
    province?: string | null
    zip_code?: string | null
    country?: string | null
    contact_name?: string | null
    contact_phone?: string | null
    contact_mobile?: string | null
    contact_fax?: string | null
    contact_email?: string | null
    broker_type?: string | null
    brokerage_method?: string | null
    brokerage_cal_method_id?: number | null
    brokerage_input_percentage?: Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: number | null
    settlement_account_number?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type brokersUncheckedCreateInput = {
    id?: number
    broker_code: string
    broker_name: string
    building_number?: string | null
    street_name?: string | null
    street_name2?: string | null
    city?: string | null
    province?: string | null
    zip_code?: string | null
    country?: string | null
    contact_name?: string | null
    contact_phone?: string | null
    contact_mobile?: string | null
    contact_fax?: string | null
    contact_email?: string | null
    broker_type?: string | null
    brokerage_method?: string | null
    brokerage_cal_method_id?: number | null
    brokerage_input_percentage?: Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: number | null
    settlement_account_number?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type brokersUpdateInput = {
    broker_code?: StringFieldUpdateOperationsInput | string
    broker_name?: StringFieldUpdateOperationsInput | string
    building_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    broker_type?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_method?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_cal_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    brokerage_input_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type brokersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker_code?: StringFieldUpdateOperationsInput | string
    broker_name?: StringFieldUpdateOperationsInput | string
    building_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    broker_type?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_method?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_cal_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    brokerage_input_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type brokersCreateManyInput = {
    id?: number
    broker_code: string
    broker_name: string
    building_number?: string | null
    street_name?: string | null
    street_name2?: string | null
    city?: string | null
    province?: string | null
    zip_code?: string | null
    country?: string | null
    contact_name?: string | null
    contact_phone?: string | null
    contact_mobile?: string | null
    contact_fax?: string | null
    contact_email?: string | null
    broker_type?: string | null
    brokerage_method?: string | null
    brokerage_cal_method_id?: number | null
    brokerage_input_percentage?: Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: number | null
    settlement_account_number?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type brokersUpdateManyMutationInput = {
    broker_code?: StringFieldUpdateOperationsInput | string
    broker_name?: StringFieldUpdateOperationsInput | string
    building_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    broker_type?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_method?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_cal_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    brokerage_input_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type brokersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    broker_code?: StringFieldUpdateOperationsInput | string
    broker_name?: StringFieldUpdateOperationsInput | string
    building_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    broker_type?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_method?: NullableStringFieldUpdateOperationsInput | string | null
    brokerage_cal_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    brokerage_input_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    brokerage_settlement_method_id?: NullableIntFieldUpdateOperationsInput | number | null
    settlement_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chart_of_accountsCreateInput = {
    account_code: string
    name: string
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    account_types: account_typesCreateNestedOneWithoutChart_of_accountsInput
    chart_of_accounts?: chart_of_accountsCreateNestedOneWithoutOther_chart_of_accountsInput
    other_chart_of_accounts?: chart_of_accountsCreateNestedManyWithoutChart_of_accountsInput
    ledger_entries?: ledger_entriesCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsUncheckedCreateInput = {
    id?: number
    account_code: string
    name: string
    account_type_id: number
    parent_account_id?: number | null
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedCreateNestedManyWithoutChart_of_accountsInput
    ledger_entries?: ledger_entriesUncheckedCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsUpdateInput = {
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_types?: account_typesUpdateOneRequiredWithoutChart_of_accountsNestedInput
    chart_of_accounts?: chart_of_accountsUpdateOneWithoutOther_chart_of_accountsNestedInput
    other_chart_of_accounts?: chart_of_accountsUpdateManyWithoutChart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_type_id?: IntFieldUpdateOperationsInput | number
    parent_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsCreateManyInput = {
    id?: number
    account_code: string
    name: string
    account_type_id: number
    parent_account_id?: number | null
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chart_of_accountsUpdateManyMutationInput = {
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chart_of_accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_type_id?: IntFieldUpdateOperationsInput | number
    parent_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_limitsCreateInput = {
    counterparty_id: number
    counterparty_type: $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: Decimal | DecimalJsLike | number | string | null
    currency_limit?: string | null
    product_money_market_limit?: Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: Decimal | DecimalJsLike | number | string | null
    tenor_limit?: Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: Decimal | DecimalJsLike | number | string | null
    country_limit?: Decimal | DecimalJsLike | number | string | null
    group_limit?: Decimal | DecimalJsLike | number | string | null
    intraday_limit?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    product_transaction_limit?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
  }

  export type counterparty_limitsUncheckedCreateInput = {
    id?: number
    counterparty_id: number
    counterparty_type: $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: Decimal | DecimalJsLike | number | string | null
    currency_limit?: string | null
    product_money_market_limit?: Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: Decimal | DecimalJsLike | number | string | null
    tenor_limit?: Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: Decimal | DecimalJsLike | number | string | null
    country_limit?: Decimal | DecimalJsLike | number | string | null
    group_limit?: Decimal | DecimalJsLike | number | string | null
    intraday_limit?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    product_transaction_limit?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
  }

  export type counterparty_limitsUpdateInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeFieldUpdateOperationsInput | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency_limit?: NullableStringFieldUpdateOperationsInput | string | null
    product_money_market_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    country_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    group_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_transaction_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type counterparty_limitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeFieldUpdateOperationsInput | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency_limit?: NullableStringFieldUpdateOperationsInput | string | null
    product_money_market_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    country_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    group_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_transaction_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type counterparty_limitsCreateManyInput = {
    id?: number
    counterparty_id: number
    counterparty_type: $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: Decimal | DecimalJsLike | number | string | null
    currency_limit?: string | null
    product_money_market_limit?: Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: Decimal | DecimalJsLike | number | string | null
    tenor_limit?: Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: Decimal | DecimalJsLike | number | string | null
    country_limit?: Decimal | DecimalJsLike | number | string | null
    group_limit?: Decimal | DecimalJsLike | number | string | null
    intraday_limit?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    product_transaction_limit?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
  }

  export type counterparty_limitsUpdateManyMutationInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeFieldUpdateOperationsInput | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency_limit?: NullableStringFieldUpdateOperationsInput | string | null
    product_money_market_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    country_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    group_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_transaction_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type counterparty_limitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    counterparty_type?: Enumcounterparty_limits_counterparty_typeFieldUpdateOperationsInput | $Enums.counterparty_limits_counterparty_type
    overall_exposure_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency_limit?: NullableStringFieldUpdateOperationsInput | string | null
    product_money_market_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_fx_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_derivative_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_reverse_repo_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_gsec_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_sell_and_buy_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_buy_and_sell_back_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tenor_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_risk_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    country_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    group_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_transaction_limit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type counterparty_master_individualCreateInput = {
    title?: string | null
    short_name?: string | null
    long_name?: string | null
    id_type?: string | null
    house_number?: string | null
    street_name?: string | null
    province?: string | null
    postal_code?: string | null
    city?: string | null
    country?: string | null
    telephone?: string | null
    email?: string | null
    mobile?: string | null
    created_at?: Date | string | null
  }

  export type counterparty_master_individualUncheckedCreateInput = {
    id?: number
    title?: string | null
    short_name?: string | null
    long_name?: string | null
    id_type?: string | null
    house_number?: string | null
    street_name?: string | null
    province?: string | null
    postal_code?: string | null
    city?: string | null
    country?: string | null
    telephone?: string | null
    email?: string | null
    mobile?: string | null
    created_at?: Date | string | null
  }

  export type counterparty_master_individualUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: NullableStringFieldUpdateOperationsInput | string | null
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_individualUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: NullableStringFieldUpdateOperationsInput | string | null
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_individualCreateManyInput = {
    id?: number
    title?: string | null
    short_name?: string | null
    long_name?: string | null
    id_type?: string | null
    house_number?: string | null
    street_name?: string | null
    province?: string | null
    postal_code?: string | null
    city?: string | null
    country?: string | null
    telephone?: string | null
    email?: string | null
    mobile?: string | null
    created_at?: Date | string | null
  }

  export type counterparty_master_individualUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: NullableStringFieldUpdateOperationsInput | string | null
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_individualUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: NullableStringFieldUpdateOperationsInput | string | null
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_jointCreateInput = {
    title: string
    short_name?: string | null
    long_name?: string | null
    id_type: string
    house_number?: string | null
    street_name?: string | null
    province?: string | null
    postal_code?: string | null
    city?: string | null
    country?: string | null
    telephone?: string | null
    email?: string | null
    mobile?: string | null
    created_at?: Date | string | null
  }

  export type counterparty_master_jointUncheckedCreateInput = {
    id?: number
    title: string
    short_name?: string | null
    long_name?: string | null
    id_type: string
    house_number?: string | null
    street_name?: string | null
    province?: string | null
    postal_code?: string | null
    city?: string | null
    country?: string | null
    telephone?: string | null
    email?: string | null
    mobile?: string | null
    created_at?: Date | string | null
  }

  export type counterparty_master_jointUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_jointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_jointCreateManyInput = {
    id?: number
    title: string
    short_name?: string | null
    long_name?: string | null
    id_type: string
    house_number?: string | null
    street_name?: string | null
    province?: string | null
    postal_code?: string | null
    city?: string | null
    country?: string | null
    telephone?: string | null
    email?: string | null
    mobile?: string | null
    created_at?: Date | string | null
  }

  export type counterparty_master_jointUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterparty_master_jointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_name?: NullableStringFieldUpdateOperationsInput | string | null
    long_name?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    house_number?: NullableStringFieldUpdateOperationsInput | string | null
    street_name?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gsecCreateInput = {
    trade_type?: string | null
    transaction_type?: string | null
    counterparty?: string | null
    deal_number?: string | null
    isin?: string | null
    face_value?: Decimal | DecimalJsLike | number | string | null
    value_date?: Date | string | null
    next_coupon_date?: Date | string | null
    last_coupon_date?: Date | string | null
    number_of_days_interest_accrued?: number | null
    number_of_days_for_coupon_period?: number | null
    accrued_interest?: Decimal | DecimalJsLike | number | string | null
    coupon_interest?: Decimal | DecimalJsLike | number | string | null
    clean_price?: Decimal | DecimalJsLike | number | string | null
    dirty_price?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: Decimal | DecimalJsLike | number | string | null
    settlement_amount?: Decimal | DecimalJsLike | number | string | null
    settlement_mode?: string | null
    issue_date?: Date | string | null
    maturity_date?: Date | string | null
    coupon_dates?: string | null
    yield?: Decimal | DecimalJsLike | number | string | null
    portfolio?: string | null
    clean_price_adjustment?: string | null
    accrued_interest_adjustment?: string | null
    broker?: string | null
    strategy?: string | null
    status?: string | null
    comment?: string | null
    created_by?: number | null
    stratergy?: string | null
    created_at?: Date | string | null
    updated_by?: number | null
    updated_at?: Date | string | null
    authorized_by?: number | null
    authorized_at?: Date | string | null
    brokerage?: Decimal | DecimalJsLike | number | string | null
    currency?: string
  }

  export type gsecUncheckedCreateInput = {
    id?: number
    trade_type?: string | null
    transaction_type?: string | null
    counterparty?: string | null
    deal_number?: string | null
    isin?: string | null
    face_value?: Decimal | DecimalJsLike | number | string | null
    value_date?: Date | string | null
    next_coupon_date?: Date | string | null
    last_coupon_date?: Date | string | null
    number_of_days_interest_accrued?: number | null
    number_of_days_for_coupon_period?: number | null
    accrued_interest?: Decimal | DecimalJsLike | number | string | null
    coupon_interest?: Decimal | DecimalJsLike | number | string | null
    clean_price?: Decimal | DecimalJsLike | number | string | null
    dirty_price?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: Decimal | DecimalJsLike | number | string | null
    settlement_amount?: Decimal | DecimalJsLike | number | string | null
    settlement_mode?: string | null
    issue_date?: Date | string | null
    maturity_date?: Date | string | null
    coupon_dates?: string | null
    yield?: Decimal | DecimalJsLike | number | string | null
    portfolio?: string | null
    clean_price_adjustment?: string | null
    accrued_interest_adjustment?: string | null
    broker?: string | null
    strategy?: string | null
    status?: string | null
    comment?: string | null
    created_by?: number | null
    stratergy?: string | null
    created_at?: Date | string | null
    updated_by?: number | null
    updated_at?: Date | string | null
    authorized_by?: number | null
    authorized_at?: Date | string | null
    brokerage?: Decimal | DecimalJsLike | number | string | null
    currency?: string
  }

  export type gsecUpdateInput = {
    trade_type?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    face_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number_of_days_interest_accrued?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days_for_coupon_period?: NullableIntFieldUpdateOperationsInput | number | null
    accrued_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clean_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dirty_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_dates?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    clean_price_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    accrued_interest_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    stratergy?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorized_by?: NullableIntFieldUpdateOperationsInput | number | null
    authorized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brokerage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type gsecUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    trade_type?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    face_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number_of_days_interest_accrued?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days_for_coupon_period?: NullableIntFieldUpdateOperationsInput | number | null
    accrued_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clean_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dirty_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_dates?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    clean_price_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    accrued_interest_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    stratergy?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorized_by?: NullableIntFieldUpdateOperationsInput | number | null
    authorized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brokerage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type gsecCreateManyInput = {
    id?: number
    trade_type?: string | null
    transaction_type?: string | null
    counterparty?: string | null
    deal_number?: string | null
    isin?: string | null
    face_value?: Decimal | DecimalJsLike | number | string | null
    value_date?: Date | string | null
    next_coupon_date?: Date | string | null
    last_coupon_date?: Date | string | null
    number_of_days_interest_accrued?: number | null
    number_of_days_for_coupon_period?: number | null
    accrued_interest?: Decimal | DecimalJsLike | number | string | null
    coupon_interest?: Decimal | DecimalJsLike | number | string | null
    clean_price?: Decimal | DecimalJsLike | number | string | null
    dirty_price?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: Decimal | DecimalJsLike | number | string | null
    settlement_amount?: Decimal | DecimalJsLike | number | string | null
    settlement_mode?: string | null
    issue_date?: Date | string | null
    maturity_date?: Date | string | null
    coupon_dates?: string | null
    yield?: Decimal | DecimalJsLike | number | string | null
    portfolio?: string | null
    clean_price_adjustment?: string | null
    accrued_interest_adjustment?: string | null
    broker?: string | null
    strategy?: string | null
    status?: string | null
    comment?: string | null
    created_by?: number | null
    stratergy?: string | null
    created_at?: Date | string | null
    updated_by?: number | null
    updated_at?: Date | string | null
    authorized_by?: number | null
    authorized_at?: Date | string | null
    brokerage?: Decimal | DecimalJsLike | number | string | null
    currency?: string
  }

  export type gsecUpdateManyMutationInput = {
    trade_type?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    face_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number_of_days_interest_accrued?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days_for_coupon_period?: NullableIntFieldUpdateOperationsInput | number | null
    accrued_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clean_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dirty_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_dates?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    clean_price_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    accrued_interest_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    stratergy?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorized_by?: NullableIntFieldUpdateOperationsInput | number | null
    authorized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brokerage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type gsecUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trade_type?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type?: NullableStringFieldUpdateOperationsInput | string | null
    counterparty?: NullableStringFieldUpdateOperationsInput | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    face_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    value_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_coupon_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number_of_days_interest_accrued?: NullableIntFieldUpdateOperationsInput | number | null
    number_of_days_for_coupon_period?: NullableIntFieldUpdateOperationsInput | number | null
    accrued_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coupon_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clean_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dirty_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_calculation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_six_decimals?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accrued_interest_for_100?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coupon_dates?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    clean_price_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    accrued_interest_adjustment?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    stratergy?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorized_by?: NullableIntFieldUpdateOperationsInput | number | null
    authorized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brokerage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type isin_coupon_scheduleCreateInput = {
    coupon_number: number
    coupon_date: Date | string
    coupon_amount: Decimal | DecimalJsLike | number | string
    principal?: Decimal | DecimalJsLike | number | string | null
    isin_master: isin_masterCreateNestedOneWithoutIsin_coupon_scheduleInput
  }

  export type isin_coupon_scheduleUncheckedCreateInput = {
    id?: number
    isin: string
    coupon_number: number
    coupon_date: Date | string
    coupon_amount: Decimal | DecimalJsLike | number | string
    principal?: Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUpdateInput = {
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isin_master?: isin_masterUpdateOneRequiredWithoutIsin_coupon_scheduleNestedInput
  }

  export type isin_coupon_scheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isin?: StringFieldUpdateOperationsInput | string
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleCreateManyInput = {
    id?: number
    isin: string
    coupon_number: number
    coupon_date: Date | string
    coupon_amount: Decimal | DecimalJsLike | number | string
    principal?: Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUpdateManyMutationInput = {
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isin?: StringFieldUpdateOperationsInput | string
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type isin_masterCreateInput = {
    isin_issuer: string
    isin_number: string
    issue_date: Date | string
    maturity_date: Date | string
    coupon_rate: Decimal | DecimalJsLike | number | string
    series?: string | null
    coupon_date_1: Date | string
    coupon_date_2: Date | string
    day_basis: number
    currency: string
    created_at?: Date | string
    updated_at?: Date | string
    isin_coupon_schedule?: isin_coupon_scheduleCreateNestedManyWithoutIsin_masterInput
  }

  export type isin_masterUncheckedCreateInput = {
    id?: number
    isin_issuer: string
    isin_number: string
    issue_date: Date | string
    maturity_date: Date | string
    coupon_rate: Decimal | DecimalJsLike | number | string
    series?: string | null
    coupon_date_1: Date | string
    coupon_date_2: Date | string
    day_basis: number
    currency: string
    created_at?: Date | string
    updated_at?: Date | string
    isin_coupon_schedule?: isin_coupon_scheduleUncheckedCreateNestedManyWithoutIsin_masterInput
  }

  export type isin_masterUpdateInput = {
    isin_issuer?: StringFieldUpdateOperationsInput | string
    isin_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    series?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_date_1?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_date_2?: DateTimeFieldUpdateOperationsInput | Date | string
    day_basis?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isin_coupon_schedule?: isin_coupon_scheduleUpdateManyWithoutIsin_masterNestedInput
  }

  export type isin_masterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isin_issuer?: StringFieldUpdateOperationsInput | string
    isin_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    series?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_date_1?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_date_2?: DateTimeFieldUpdateOperationsInput | Date | string
    day_basis?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isin_coupon_schedule?: isin_coupon_scheduleUncheckedUpdateManyWithoutIsin_masterNestedInput
  }

  export type isin_masterCreateManyInput = {
    id?: number
    isin_issuer: string
    isin_number: string
    issue_date: Date | string
    maturity_date: Date | string
    coupon_rate: Decimal | DecimalJsLike | number | string
    series?: string | null
    coupon_date_1: Date | string
    coupon_date_2: Date | string
    day_basis: number
    currency: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type isin_masterUpdateManyMutationInput = {
    isin_issuer?: StringFieldUpdateOperationsInput | string
    isin_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    series?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_date_1?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_date_2?: DateTimeFieldUpdateOperationsInput | Date | string
    day_basis?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type isin_masterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isin_issuer?: StringFieldUpdateOperationsInput | string
    isin_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    series?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_date_1?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_date_2?: DateTimeFieldUpdateOperationsInput | Date | string
    day_basis?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ledger_entriesCreateInput = {
    entry_date: Date | string
    debit_amount?: Decimal | DecimalJsLike | number | string | null
    credit_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deal_number?: string | null
    chart_of_accounts: chart_of_accountsCreateNestedOneWithoutLedger_entriesInput
  }

  export type ledger_entriesUncheckedCreateInput = {
    id?: number
    account_id: number
    entry_date: Date | string
    debit_amount?: Decimal | DecimalJsLike | number | string | null
    credit_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deal_number?: string | null
  }

  export type ledger_entriesUpdateInput = {
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
    chart_of_accounts?: chart_of_accountsUpdateOneRequiredWithoutLedger_entriesNestedInput
  }

  export type ledger_entriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ledger_entriesCreateManyInput = {
    id?: number
    account_id: number
    entry_date: Date | string
    debit_amount?: Decimal | DecimalJsLike | number | string | null
    credit_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deal_number?: string | null
  }

  export type ledger_entriesUpdateManyMutationInput = {
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ledger_entriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type money_market_dealsCreateInput = {
    deal_number: string
    trade_date: Date | string
    value_date: Date | string
    maturity_date: Date | string
    counterparty_type: $Enums.money_market_deals_counterparty_type
    counterparty_id: number
    product_type: string
    currency: string
    principal_amount: Decimal | DecimalJsLike | number | string
    interest_rate: Decimal | DecimalJsLike | number | string
    tenor: number
    interest_amount: Decimal | DecimalJsLike | number | string
    maturity_value: Decimal | DecimalJsLike | number | string
    settlement_mode?: string | null
    remarks?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type money_market_dealsUncheckedCreateInput = {
    id?: number
    deal_number: string
    trade_date: Date | string
    value_date: Date | string
    maturity_date: Date | string
    counterparty_type: $Enums.money_market_deals_counterparty_type
    counterparty_id: number
    product_type: string
    currency: string
    principal_amount: Decimal | DecimalJsLike | number | string
    interest_rate: Decimal | DecimalJsLike | number | string
    tenor: number
    interest_amount: Decimal | DecimalJsLike | number | string
    maturity_value: Decimal | DecimalJsLike | number | string
    settlement_mode?: string | null
    remarks?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type money_market_dealsUpdateInput = {
    deal_number?: StringFieldUpdateOperationsInput | string
    trade_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeFieldUpdateOperationsInput | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntFieldUpdateOperationsInput | number
    product_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    principal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenor?: IntFieldUpdateOperationsInput | number
    interest_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type money_market_dealsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deal_number?: StringFieldUpdateOperationsInput | string
    trade_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeFieldUpdateOperationsInput | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntFieldUpdateOperationsInput | number
    product_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    principal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenor?: IntFieldUpdateOperationsInput | number
    interest_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type money_market_dealsCreateManyInput = {
    id?: number
    deal_number: string
    trade_date: Date | string
    value_date: Date | string
    maturity_date: Date | string
    counterparty_type: $Enums.money_market_deals_counterparty_type
    counterparty_id: number
    product_type: string
    currency: string
    principal_amount: Decimal | DecimalJsLike | number | string
    interest_rate: Decimal | DecimalJsLike | number | string
    tenor: number
    interest_amount: Decimal | DecimalJsLike | number | string
    maturity_value: Decimal | DecimalJsLike | number | string
    settlement_mode?: string | null
    remarks?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type money_market_dealsUpdateManyMutationInput = {
    deal_number?: StringFieldUpdateOperationsInput | string
    trade_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeFieldUpdateOperationsInput | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntFieldUpdateOperationsInput | number
    product_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    principal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenor?: IntFieldUpdateOperationsInput | number
    interest_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type money_market_dealsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deal_number?: StringFieldUpdateOperationsInput | string
    trade_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty_type?: Enummoney_market_deals_counterparty_typeFieldUpdateOperationsInput | $Enums.money_market_deals_counterparty_type
    counterparty_id?: IntFieldUpdateOperationsInput | number
    product_type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    principal_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interest_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenor?: IntFieldUpdateOperationsInput | number
    interest_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maturity_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    settlement_mode?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type portfolio_masterCreateInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    portfolio_master?: portfolio_masterCreateNestedOneWithoutOther_portfolio_masterInput
    other_portfolio_master?: portfolio_masterCreateNestedManyWithoutPortfolio_masterInput
  }

  export type portfolio_masterUncheckedCreateInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    parent_portfolio_id?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_portfolio_master?: portfolio_masterUncheckedCreateNestedManyWithoutPortfolio_masterInput
  }

  export type portfolio_masterUpdateInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portfolio_master?: portfolio_masterUpdateOneWithoutOther_portfolio_masterNestedInput
    other_portfolio_master?: portfolio_masterUpdateManyWithoutPortfolio_masterNestedInput
  }

  export type portfolio_masterUncheckedUpdateInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_portfolio_id?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_portfolio_master?: portfolio_masterUncheckedUpdateManyWithoutPortfolio_masterNestedInput
  }

  export type portfolio_masterCreateManyInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    parent_portfolio_id?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type portfolio_masterUpdateManyMutationInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type portfolio_masterUncheckedUpdateManyInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_portfolio_id?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type securitiesCreateInput = {
    name: string
  }

  export type securitiesUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type securitiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type securitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type securitiesCreateManyInput = {
    id?: number
    name: string
  }

  export type securitiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type securitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type settlement_accountsCreateInput = {
    id?: bigint | number
    bank_name: string
    bank_payment_code?: string | null
    bank_code?: string | null
    address_building_number?: string | null
    address_street_name?: string | null
    address_street_name2?: string | null
    address_city?: string | null
    address_province?: string | null
    address_zip_code?: string | null
    address_country?: string | null
    contact_name?: string | null
    contact_phone?: string | null
    contact_mobile?: string | null
    contact_fax?: string | null
    contact_email?: string | null
    account_type?: string | null
    bank_account_number?: string | null
    bank_branch?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type settlement_accountsUncheckedCreateInput = {
    id?: bigint | number
    bank_name: string
    bank_payment_code?: string | null
    bank_code?: string | null
    address_building_number?: string | null
    address_street_name?: string | null
    address_street_name2?: string | null
    address_city?: string | null
    address_province?: string | null
    address_zip_code?: string | null
    address_country?: string | null
    contact_name?: string | null
    contact_phone?: string | null
    contact_mobile?: string | null
    contact_fax?: string | null
    contact_email?: string | null
    account_type?: string | null
    bank_account_number?: string | null
    bank_branch?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type settlement_accountsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bank_name?: StringFieldUpdateOperationsInput | string
    bank_payment_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_building_number?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_province?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_branch?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settlement_accountsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bank_name?: StringFieldUpdateOperationsInput | string
    bank_payment_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_building_number?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_province?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_branch?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settlement_accountsCreateManyInput = {
    id?: bigint | number
    bank_name: string
    bank_payment_code?: string | null
    bank_code?: string | null
    address_building_number?: string | null
    address_street_name?: string | null
    address_street_name2?: string | null
    address_city?: string | null
    address_province?: string | null
    address_zip_code?: string | null
    address_country?: string | null
    contact_name?: string | null
    contact_phone?: string | null
    contact_mobile?: string | null
    contact_fax?: string | null
    contact_email?: string | null
    account_type?: string | null
    bank_account_number?: string | null
    bank_branch?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type settlement_accountsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bank_name?: StringFieldUpdateOperationsInput | string
    bank_payment_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_building_number?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_province?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_branch?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settlement_accountsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bank_name?: StringFieldUpdateOperationsInput | string
    bank_payment_code?: NullableStringFieldUpdateOperationsInput | string | null
    bank_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_building_number?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name?: NullableStringFieldUpdateOperationsInput | string | null
    address_street_name2?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_province?: NullableStringFieldUpdateOperationsInput | string | null
    address_zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    contact_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    contact_fax?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    bank_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_branch?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type strategy_masterCreateInput = {
    strategy_id: string
    portfolio_name: string
    strategy_type?: string | null
    entity_business_unit?: string | null
  }

  export type strategy_masterUncheckedCreateInput = {
    strategy_id: string
    portfolio_name: string
    strategy_type?: string | null
    entity_business_unit?: string | null
  }

  export type strategy_masterUpdateInput = {
    strategy_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    strategy_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type strategy_masterUncheckedUpdateInput = {
    strategy_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    strategy_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type strategy_masterCreateManyInput = {
    strategy_id: string
    portfolio_name: string
    strategy_type?: string | null
    entity_business_unit?: string | null
  }

  export type strategy_masterUpdateManyMutationInput = {
    strategy_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    strategy_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type strategy_masterUncheckedUpdateManyInput = {
    strategy_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    strategy_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transaction_typesCreateInput = {
    name: string
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type transaction_typesUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type transaction_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaction_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaction_typesCreateManyInput = {
    id?: number
    name: string
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type transaction_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaction_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    username: string
    password: string
    role?: $Enums.users_role
    created_at?: Date | string | null
    allowed_tabs?: string | null
    limit_id?: number | null
  }

  export type usersUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    role?: $Enums.users_role
    created_at?: Date | string | null
    allowed_tabs?: string | null
    limit_id?: number | null
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowed_tabs?: NullableStringFieldUpdateOperationsInput | string | null
    limit_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowed_tabs?: NullableStringFieldUpdateOperationsInput | string | null
    limit_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersCreateManyInput = {
    id?: number
    username: string
    password: string
    role?: $Enums.users_role
    created_at?: Date | string | null
    allowed_tabs?: string | null
    limit_id?: number | null
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowed_tabs?: NullableStringFieldUpdateOperationsInput | string | null
    limit_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowed_tabs?: NullableStringFieldUpdateOperationsInput | string | null
    limit_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Enumaccount_types_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.account_types_category | Enumaccount_types_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.account_types_category[]
    notIn?: $Enums.account_types_category[]
    not?: NestedEnumaccount_types_categoryFilter<$PrismaModel> | $Enums.account_types_category
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Chart_of_accountsListRelationFilter = {
    every?: chart_of_accountsWhereInput
    some?: chart_of_accountsWhereInput
    none?: chart_of_accountsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type chart_of_accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type account_typesOrderByRelevanceInput = {
    fields: account_typesOrderByRelevanceFieldEnum | account_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type account_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type account_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type account_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type account_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type account_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumaccount_types_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.account_types_category | Enumaccount_types_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.account_types_category[]
    notIn?: $Enums.account_types_category[]
    not?: NestedEnumaccount_types_categoryWithAggregatesFilter<$PrismaModel> | $Enums.account_types_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumaccount_types_categoryFilter<$PrismaModel>
    _max?: NestedEnumaccount_types_categoryFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type accountsOrderByRelevanceInput = {
    fields: accountsOrderByRelevanceFieldEnum | accountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type brokersOrderByRelevanceInput = {
    fields: brokersOrderByRelevanceFieldEnum | brokersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type brokersCountOrderByAggregateInput = {
    id?: SortOrder
    broker_code?: SortOrder
    broker_name?: SortOrder
    building_number?: SortOrder
    street_name?: SortOrder
    street_name2?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    contact_mobile?: SortOrder
    contact_fax?: SortOrder
    contact_email?: SortOrder
    broker_type?: SortOrder
    brokerage_method?: SortOrder
    brokerage_cal_method_id?: SortOrder
    brokerage_input_percentage?: SortOrder
    brokerage_settlement_method_id?: SortOrder
    settlement_account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type brokersAvgOrderByAggregateInput = {
    id?: SortOrder
    brokerage_cal_method_id?: SortOrder
    brokerage_input_percentage?: SortOrder
    brokerage_settlement_method_id?: SortOrder
  }

  export type brokersMaxOrderByAggregateInput = {
    id?: SortOrder
    broker_code?: SortOrder
    broker_name?: SortOrder
    building_number?: SortOrder
    street_name?: SortOrder
    street_name2?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    contact_mobile?: SortOrder
    contact_fax?: SortOrder
    contact_email?: SortOrder
    broker_type?: SortOrder
    brokerage_method?: SortOrder
    brokerage_cal_method_id?: SortOrder
    brokerage_input_percentage?: SortOrder
    brokerage_settlement_method_id?: SortOrder
    settlement_account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type brokersMinOrderByAggregateInput = {
    id?: SortOrder
    broker_code?: SortOrder
    broker_name?: SortOrder
    building_number?: SortOrder
    street_name?: SortOrder
    street_name2?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zip_code?: SortOrder
    country?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    contact_mobile?: SortOrder
    contact_fax?: SortOrder
    contact_email?: SortOrder
    broker_type?: SortOrder
    brokerage_method?: SortOrder
    brokerage_cal_method_id?: SortOrder
    brokerage_input_percentage?: SortOrder
    brokerage_settlement_method_id?: SortOrder
    settlement_account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type brokersSumOrderByAggregateInput = {
    id?: SortOrder
    brokerage_cal_method_id?: SortOrder
    brokerage_input_percentage?: SortOrder
    brokerage_settlement_method_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Account_typesScalarRelationFilter = {
    is?: account_typesWhereInput
    isNot?: account_typesWhereInput
  }

  export type Chart_of_accountsNullableScalarRelationFilter = {
    is?: chart_of_accountsWhereInput | null
    isNot?: chart_of_accountsWhereInput | null
  }

  export type Ledger_entriesListRelationFilter = {
    every?: ledger_entriesWhereInput
    some?: ledger_entriesWhereInput
    none?: ledger_entriesWhereInput
  }

  export type ledger_entriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chart_of_accountsOrderByRelevanceInput = {
    fields: chart_of_accountsOrderByRelevanceFieldEnum | chart_of_accountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type chart_of_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    account_code?: SortOrder
    name?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chart_of_accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrder
  }

  export type chart_of_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    account_code?: SortOrder
    name?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chart_of_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    account_code?: SortOrder
    name?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chart_of_accountsSumOrderByAggregateInput = {
    id?: SortOrder
    account_type_id?: SortOrder
    parent_account_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumcounterparty_limits_counterparty_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.counterparty_limits_counterparty_type | Enumcounterparty_limits_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.counterparty_limits_counterparty_type[]
    notIn?: $Enums.counterparty_limits_counterparty_type[]
    not?: NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel> | $Enums.counterparty_limits_counterparty_type
  }

  export type counterparty_limitsOrderByRelevanceInput = {
    fields: counterparty_limitsOrderByRelevanceFieldEnum | counterparty_limitsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type counterparty_limitsCountOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    counterparty_type?: SortOrder
    overall_exposure_limit?: SortOrder
    currency_limit?: SortOrder
    product_money_market_limit?: SortOrder
    product_fx_limit?: SortOrder
    product_derivative_limit?: SortOrder
    product_repo_limit?: SortOrder
    product_reverse_repo_limit?: SortOrder
    product_gsec_limit?: SortOrder
    product_sell_and_buy_back_limit?: SortOrder
    product_buy_and_sell_back_limit?: SortOrder
    tenor_limit?: SortOrder
    settlement_risk_limit?: SortOrder
    country_limit?: SortOrder
    group_limit?: SortOrder
    intraday_limit?: SortOrder
    created_at?: SortOrder
    product_transaction_limit?: SortOrder
    currency?: SortOrder
  }

  export type counterparty_limitsAvgOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    overall_exposure_limit?: SortOrder
    product_money_market_limit?: SortOrder
    product_fx_limit?: SortOrder
    product_derivative_limit?: SortOrder
    product_repo_limit?: SortOrder
    product_reverse_repo_limit?: SortOrder
    product_gsec_limit?: SortOrder
    product_sell_and_buy_back_limit?: SortOrder
    product_buy_and_sell_back_limit?: SortOrder
    tenor_limit?: SortOrder
    settlement_risk_limit?: SortOrder
    country_limit?: SortOrder
    group_limit?: SortOrder
    intraday_limit?: SortOrder
    product_transaction_limit?: SortOrder
  }

  export type counterparty_limitsMaxOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    counterparty_type?: SortOrder
    overall_exposure_limit?: SortOrder
    currency_limit?: SortOrder
    product_money_market_limit?: SortOrder
    product_fx_limit?: SortOrder
    product_derivative_limit?: SortOrder
    product_repo_limit?: SortOrder
    product_reverse_repo_limit?: SortOrder
    product_gsec_limit?: SortOrder
    product_sell_and_buy_back_limit?: SortOrder
    product_buy_and_sell_back_limit?: SortOrder
    tenor_limit?: SortOrder
    settlement_risk_limit?: SortOrder
    country_limit?: SortOrder
    group_limit?: SortOrder
    intraday_limit?: SortOrder
    created_at?: SortOrder
    product_transaction_limit?: SortOrder
    currency?: SortOrder
  }

  export type counterparty_limitsMinOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    counterparty_type?: SortOrder
    overall_exposure_limit?: SortOrder
    currency_limit?: SortOrder
    product_money_market_limit?: SortOrder
    product_fx_limit?: SortOrder
    product_derivative_limit?: SortOrder
    product_repo_limit?: SortOrder
    product_reverse_repo_limit?: SortOrder
    product_gsec_limit?: SortOrder
    product_sell_and_buy_back_limit?: SortOrder
    product_buy_and_sell_back_limit?: SortOrder
    tenor_limit?: SortOrder
    settlement_risk_limit?: SortOrder
    country_limit?: SortOrder
    group_limit?: SortOrder
    intraday_limit?: SortOrder
    created_at?: SortOrder
    product_transaction_limit?: SortOrder
    currency?: SortOrder
  }

  export type counterparty_limitsSumOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    overall_exposure_limit?: SortOrder
    product_money_market_limit?: SortOrder
    product_fx_limit?: SortOrder
    product_derivative_limit?: SortOrder
    product_repo_limit?: SortOrder
    product_reverse_repo_limit?: SortOrder
    product_gsec_limit?: SortOrder
    product_sell_and_buy_back_limit?: SortOrder
    product_buy_and_sell_back_limit?: SortOrder
    tenor_limit?: SortOrder
    settlement_risk_limit?: SortOrder
    country_limit?: SortOrder
    group_limit?: SortOrder
    intraday_limit?: SortOrder
    product_transaction_limit?: SortOrder
  }

  export type Enumcounterparty_limits_counterparty_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.counterparty_limits_counterparty_type | Enumcounterparty_limits_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.counterparty_limits_counterparty_type[]
    notIn?: $Enums.counterparty_limits_counterparty_type[]
    not?: NestedEnumcounterparty_limits_counterparty_typeWithAggregatesFilter<$PrismaModel> | $Enums.counterparty_limits_counterparty_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel>
    _max?: NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel>
  }

  export type counterparty_master_individualOrderByRelevanceInput = {
    fields: counterparty_master_individualOrderByRelevanceFieldEnum | counterparty_master_individualOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type counterparty_master_individualCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrder
    long_name?: SortOrder
    id_type?: SortOrder
    house_number?: SortOrder
    street_name?: SortOrder
    province?: SortOrder
    postal_code?: SortOrder
    city?: SortOrder
    country?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
  }

  export type counterparty_master_individualAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type counterparty_master_individualMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrder
    long_name?: SortOrder
    id_type?: SortOrder
    house_number?: SortOrder
    street_name?: SortOrder
    province?: SortOrder
    postal_code?: SortOrder
    city?: SortOrder
    country?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
  }

  export type counterparty_master_individualMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrder
    long_name?: SortOrder
    id_type?: SortOrder
    house_number?: SortOrder
    street_name?: SortOrder
    province?: SortOrder
    postal_code?: SortOrder
    city?: SortOrder
    country?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
  }

  export type counterparty_master_individualSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type counterparty_master_jointOrderByRelevanceInput = {
    fields: counterparty_master_jointOrderByRelevanceFieldEnum | counterparty_master_jointOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type counterparty_master_jointCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrder
    long_name?: SortOrder
    id_type?: SortOrder
    house_number?: SortOrder
    street_name?: SortOrder
    province?: SortOrder
    postal_code?: SortOrder
    city?: SortOrder
    country?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
  }

  export type counterparty_master_jointAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type counterparty_master_jointMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrder
    long_name?: SortOrder
    id_type?: SortOrder
    house_number?: SortOrder
    street_name?: SortOrder
    province?: SortOrder
    postal_code?: SortOrder
    city?: SortOrder
    country?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
  }

  export type counterparty_master_jointMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_name?: SortOrder
    long_name?: SortOrder
    id_type?: SortOrder
    house_number?: SortOrder
    street_name?: SortOrder
    province?: SortOrder
    postal_code?: SortOrder
    city?: SortOrder
    country?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
  }

  export type counterparty_master_jointSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type gsecOrderByRelevanceInput = {
    fields: gsecOrderByRelevanceFieldEnum | gsecOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type gsecCountOrderByAggregateInput = {
    id?: SortOrder
    trade_type?: SortOrder
    transaction_type?: SortOrder
    counterparty?: SortOrder
    deal_number?: SortOrder
    isin?: SortOrder
    face_value?: SortOrder
    value_date?: SortOrder
    next_coupon_date?: SortOrder
    last_coupon_date?: SortOrder
    number_of_days_interest_accrued?: SortOrder
    number_of_days_for_coupon_period?: SortOrder
    accrued_interest?: SortOrder
    coupon_interest?: SortOrder
    clean_price?: SortOrder
    dirty_price?: SortOrder
    accrued_interest_calculation?: SortOrder
    accrued_interest_six_decimals?: SortOrder
    accrued_interest_for_100?: SortOrder
    settlement_amount?: SortOrder
    settlement_mode?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_dates?: SortOrder
    yield?: SortOrder
    portfolio?: SortOrder
    clean_price_adjustment?: SortOrder
    accrued_interest_adjustment?: SortOrder
    broker?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    created_by?: SortOrder
    stratergy?: SortOrder
    created_at?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    authorized_by?: SortOrder
    authorized_at?: SortOrder
    brokerage?: SortOrder
    currency?: SortOrder
  }

  export type gsecAvgOrderByAggregateInput = {
    id?: SortOrder
    face_value?: SortOrder
    number_of_days_interest_accrued?: SortOrder
    number_of_days_for_coupon_period?: SortOrder
    accrued_interest?: SortOrder
    coupon_interest?: SortOrder
    clean_price?: SortOrder
    dirty_price?: SortOrder
    accrued_interest_calculation?: SortOrder
    accrued_interest_six_decimals?: SortOrder
    accrued_interest_for_100?: SortOrder
    settlement_amount?: SortOrder
    yield?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    authorized_by?: SortOrder
    brokerage?: SortOrder
  }

  export type gsecMaxOrderByAggregateInput = {
    id?: SortOrder
    trade_type?: SortOrder
    transaction_type?: SortOrder
    counterparty?: SortOrder
    deal_number?: SortOrder
    isin?: SortOrder
    face_value?: SortOrder
    value_date?: SortOrder
    next_coupon_date?: SortOrder
    last_coupon_date?: SortOrder
    number_of_days_interest_accrued?: SortOrder
    number_of_days_for_coupon_period?: SortOrder
    accrued_interest?: SortOrder
    coupon_interest?: SortOrder
    clean_price?: SortOrder
    dirty_price?: SortOrder
    accrued_interest_calculation?: SortOrder
    accrued_interest_six_decimals?: SortOrder
    accrued_interest_for_100?: SortOrder
    settlement_amount?: SortOrder
    settlement_mode?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_dates?: SortOrder
    yield?: SortOrder
    portfolio?: SortOrder
    clean_price_adjustment?: SortOrder
    accrued_interest_adjustment?: SortOrder
    broker?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    created_by?: SortOrder
    stratergy?: SortOrder
    created_at?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    authorized_by?: SortOrder
    authorized_at?: SortOrder
    brokerage?: SortOrder
    currency?: SortOrder
  }

  export type gsecMinOrderByAggregateInput = {
    id?: SortOrder
    trade_type?: SortOrder
    transaction_type?: SortOrder
    counterparty?: SortOrder
    deal_number?: SortOrder
    isin?: SortOrder
    face_value?: SortOrder
    value_date?: SortOrder
    next_coupon_date?: SortOrder
    last_coupon_date?: SortOrder
    number_of_days_interest_accrued?: SortOrder
    number_of_days_for_coupon_period?: SortOrder
    accrued_interest?: SortOrder
    coupon_interest?: SortOrder
    clean_price?: SortOrder
    dirty_price?: SortOrder
    accrued_interest_calculation?: SortOrder
    accrued_interest_six_decimals?: SortOrder
    accrued_interest_for_100?: SortOrder
    settlement_amount?: SortOrder
    settlement_mode?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_dates?: SortOrder
    yield?: SortOrder
    portfolio?: SortOrder
    clean_price_adjustment?: SortOrder
    accrued_interest_adjustment?: SortOrder
    broker?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    created_by?: SortOrder
    stratergy?: SortOrder
    created_at?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    authorized_by?: SortOrder
    authorized_at?: SortOrder
    brokerage?: SortOrder
    currency?: SortOrder
  }

  export type gsecSumOrderByAggregateInput = {
    id?: SortOrder
    face_value?: SortOrder
    number_of_days_interest_accrued?: SortOrder
    number_of_days_for_coupon_period?: SortOrder
    accrued_interest?: SortOrder
    coupon_interest?: SortOrder
    clean_price?: SortOrder
    dirty_price?: SortOrder
    accrued_interest_calculation?: SortOrder
    accrued_interest_six_decimals?: SortOrder
    accrued_interest_for_100?: SortOrder
    settlement_amount?: SortOrder
    yield?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    authorized_by?: SortOrder
    brokerage?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Isin_masterScalarRelationFilter = {
    is?: isin_masterWhereInput
    isNot?: isin_masterWhereInput
  }

  export type isin_coupon_scheduleOrderByRelevanceInput = {
    fields: isin_coupon_scheduleOrderByRelevanceFieldEnum | isin_coupon_scheduleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type isin_coupon_scheduleCountOrderByAggregateInput = {
    id?: SortOrder
    isin?: SortOrder
    coupon_number?: SortOrder
    coupon_date?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrder
  }

  export type isin_coupon_scheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    coupon_number?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrder
  }

  export type isin_coupon_scheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    isin?: SortOrder
    coupon_number?: SortOrder
    coupon_date?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrder
  }

  export type isin_coupon_scheduleMinOrderByAggregateInput = {
    id?: SortOrder
    isin?: SortOrder
    coupon_number?: SortOrder
    coupon_date?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrder
  }

  export type isin_coupon_scheduleSumOrderByAggregateInput = {
    id?: SortOrder
    coupon_number?: SortOrder
    coupon_amount?: SortOrder
    principal?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Isin_coupon_scheduleListRelationFilter = {
    every?: isin_coupon_scheduleWhereInput
    some?: isin_coupon_scheduleWhereInput
    none?: isin_coupon_scheduleWhereInput
  }

  export type isin_coupon_scheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type isin_masterOrderByRelevanceInput = {
    fields: isin_masterOrderByRelevanceFieldEnum | isin_masterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type isin_masterCountOrderByAggregateInput = {
    id?: SortOrder
    isin_issuer?: SortOrder
    isin_number?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_rate?: SortOrder
    series?: SortOrder
    coupon_date_1?: SortOrder
    coupon_date_2?: SortOrder
    day_basis?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type isin_masterAvgOrderByAggregateInput = {
    id?: SortOrder
    coupon_rate?: SortOrder
    day_basis?: SortOrder
  }

  export type isin_masterMaxOrderByAggregateInput = {
    id?: SortOrder
    isin_issuer?: SortOrder
    isin_number?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_rate?: SortOrder
    series?: SortOrder
    coupon_date_1?: SortOrder
    coupon_date_2?: SortOrder
    day_basis?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type isin_masterMinOrderByAggregateInput = {
    id?: SortOrder
    isin_issuer?: SortOrder
    isin_number?: SortOrder
    issue_date?: SortOrder
    maturity_date?: SortOrder
    coupon_rate?: SortOrder
    series?: SortOrder
    coupon_date_1?: SortOrder
    coupon_date_2?: SortOrder
    day_basis?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type isin_masterSumOrderByAggregateInput = {
    id?: SortOrder
    coupon_rate?: SortOrder
    day_basis?: SortOrder
  }

  export type Chart_of_accountsScalarRelationFilter = {
    is?: chart_of_accountsWhereInput
    isNot?: chart_of_accountsWhereInput
  }

  export type ledger_entriesOrderByRelevanceInput = {
    fields: ledger_entriesOrderByRelevanceFieldEnum | ledger_entriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ledger_entriesCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    entry_date?: SortOrder
    debit_amount?: SortOrder
    credit_amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deal_number?: SortOrder
  }

  export type ledger_entriesAvgOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    debit_amount?: SortOrder
    credit_amount?: SortOrder
  }

  export type ledger_entriesMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    entry_date?: SortOrder
    debit_amount?: SortOrder
    credit_amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deal_number?: SortOrder
  }

  export type ledger_entriesMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    entry_date?: SortOrder
    debit_amount?: SortOrder
    credit_amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deal_number?: SortOrder
  }

  export type ledger_entriesSumOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    debit_amount?: SortOrder
    credit_amount?: SortOrder
  }

  export type Enummoney_market_deals_counterparty_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.money_market_deals_counterparty_type | Enummoney_market_deals_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.money_market_deals_counterparty_type[]
    notIn?: $Enums.money_market_deals_counterparty_type[]
    not?: NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel> | $Enums.money_market_deals_counterparty_type
  }

  export type money_market_dealsOrderByRelevanceInput = {
    fields: money_market_dealsOrderByRelevanceFieldEnum | money_market_dealsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type money_market_dealsCountOrderByAggregateInput = {
    id?: SortOrder
    deal_number?: SortOrder
    trade_date?: SortOrder
    value_date?: SortOrder
    maturity_date?: SortOrder
    counterparty_type?: SortOrder
    counterparty_id?: SortOrder
    product_type?: SortOrder
    currency?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
    settlement_mode?: SortOrder
    remarks?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type money_market_dealsAvgOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
  }

  export type money_market_dealsMaxOrderByAggregateInput = {
    id?: SortOrder
    deal_number?: SortOrder
    trade_date?: SortOrder
    value_date?: SortOrder
    maturity_date?: SortOrder
    counterparty_type?: SortOrder
    counterparty_id?: SortOrder
    product_type?: SortOrder
    currency?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
    settlement_mode?: SortOrder
    remarks?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type money_market_dealsMinOrderByAggregateInput = {
    id?: SortOrder
    deal_number?: SortOrder
    trade_date?: SortOrder
    value_date?: SortOrder
    maturity_date?: SortOrder
    counterparty_type?: SortOrder
    counterparty_id?: SortOrder
    product_type?: SortOrder
    currency?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
    settlement_mode?: SortOrder
    remarks?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type money_market_dealsSumOrderByAggregateInput = {
    id?: SortOrder
    counterparty_id?: SortOrder
    principal_amount?: SortOrder
    interest_rate?: SortOrder
    tenor?: SortOrder
    interest_amount?: SortOrder
    maturity_value?: SortOrder
  }

  export type Enummoney_market_deals_counterparty_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.money_market_deals_counterparty_type | Enummoney_market_deals_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.money_market_deals_counterparty_type[]
    notIn?: $Enums.money_market_deals_counterparty_type[]
    not?: NestedEnummoney_market_deals_counterparty_typeWithAggregatesFilter<$PrismaModel> | $Enums.money_market_deals_counterparty_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel>
    _max?: NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel>
  }

  export type Enumportfolio_master_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_status | Enumportfolio_master_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_status[] | null
    notIn?: $Enums.portfolio_master_status[] | null
    not?: NestedEnumportfolio_master_statusNullableFilter<$PrismaModel> | $Enums.portfolio_master_status | null
  }

  export type Enumportfolio_master_risk_profileNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_risk_profile | Enumportfolio_master_risk_profileFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_risk_profile[] | null
    notIn?: $Enums.portfolio_master_risk_profile[] | null
    not?: NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel> | $Enums.portfolio_master_risk_profile | null
  }

  export type Enumportfolio_master_investment_horizonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_investment_horizon | Enumportfolio_master_investment_horizonFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_investment_horizon[] | null
    notIn?: $Enums.portfolio_master_investment_horizon[] | null
    not?: NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel> | $Enums.portfolio_master_investment_horizon | null
  }

  export type Portfolio_masterNullableScalarRelationFilter = {
    is?: portfolio_masterWhereInput | null
    isNot?: portfolio_masterWhereInput | null
  }

  export type Portfolio_masterListRelationFilter = {
    every?: portfolio_masterWhereInput
    some?: portfolio_masterWhereInput
    none?: portfolio_masterWhereInput
  }

  export type portfolio_masterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type portfolio_masterOrderByRelevanceInput = {
    fields: portfolio_masterOrderByRelevanceFieldEnum | portfolio_masterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type portfolio_masterCountOrderByAggregateInput = {
    portfolio_id?: SortOrder
    portfolio_name?: SortOrder
    portfolio_type?: SortOrder
    entity_business_unit?: SortOrder
    fund_manager_user_id?: SortOrder
    base_currency?: SortOrder
    benchmark?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    risk_profile?: SortOrder
    investment_horizon?: SortOrder
    target_yield_return?: SortOrder
    compliance_rules_id?: SortOrder
    notes_description?: SortOrder
    parent_portfolio_id?: SortOrder
    valuation_method?: SortOrder
    accounting_treatment?: SortOrder
    rebalancing_frequency?: SortOrder
    external_reference_code?: SortOrder
    tags_categories?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type portfolio_masterAvgOrderByAggregateInput = {
    target_yield_return?: SortOrder
  }

  export type portfolio_masterMaxOrderByAggregateInput = {
    portfolio_id?: SortOrder
    portfolio_name?: SortOrder
    portfolio_type?: SortOrder
    entity_business_unit?: SortOrder
    fund_manager_user_id?: SortOrder
    base_currency?: SortOrder
    benchmark?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    risk_profile?: SortOrder
    investment_horizon?: SortOrder
    target_yield_return?: SortOrder
    compliance_rules_id?: SortOrder
    notes_description?: SortOrder
    parent_portfolio_id?: SortOrder
    valuation_method?: SortOrder
    accounting_treatment?: SortOrder
    rebalancing_frequency?: SortOrder
    external_reference_code?: SortOrder
    tags_categories?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type portfolio_masterMinOrderByAggregateInput = {
    portfolio_id?: SortOrder
    portfolio_name?: SortOrder
    portfolio_type?: SortOrder
    entity_business_unit?: SortOrder
    fund_manager_user_id?: SortOrder
    base_currency?: SortOrder
    benchmark?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    risk_profile?: SortOrder
    investment_horizon?: SortOrder
    target_yield_return?: SortOrder
    compliance_rules_id?: SortOrder
    notes_description?: SortOrder
    parent_portfolio_id?: SortOrder
    valuation_method?: SortOrder
    accounting_treatment?: SortOrder
    rebalancing_frequency?: SortOrder
    external_reference_code?: SortOrder
    tags_categories?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type portfolio_masterSumOrderByAggregateInput = {
    target_yield_return?: SortOrder
  }

  export type Enumportfolio_master_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_status | Enumportfolio_master_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_status[] | null
    notIn?: $Enums.portfolio_master_status[] | null
    not?: NestedEnumportfolio_master_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.portfolio_master_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumportfolio_master_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumportfolio_master_statusNullableFilter<$PrismaModel>
  }

  export type Enumportfolio_master_risk_profileNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_risk_profile | Enumportfolio_master_risk_profileFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_risk_profile[] | null
    notIn?: $Enums.portfolio_master_risk_profile[] | null
    not?: NestedEnumportfolio_master_risk_profileNullableWithAggregatesFilter<$PrismaModel> | $Enums.portfolio_master_risk_profile | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel>
    _max?: NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel>
  }

  export type Enumportfolio_master_investment_horizonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_investment_horizon | Enumportfolio_master_investment_horizonFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_investment_horizon[] | null
    notIn?: $Enums.portfolio_master_investment_horizon[] | null
    not?: NestedEnumportfolio_master_investment_horizonNullableWithAggregatesFilter<$PrismaModel> | $Enums.portfolio_master_investment_horizon | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel>
    _max?: NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel>
  }

  export type securitiesOrderByRelevanceInput = {
    fields: securitiesOrderByRelevanceFieldEnum | securitiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type securitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type securitiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type securitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type securitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type securitiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type settlement_accountsOrderByRelevanceInput = {
    fields: settlement_accountsOrderByRelevanceFieldEnum | settlement_accountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type settlement_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    bank_name?: SortOrder
    bank_payment_code?: SortOrder
    bank_code?: SortOrder
    address_building_number?: SortOrder
    address_street_name?: SortOrder
    address_street_name2?: SortOrder
    address_city?: SortOrder
    address_province?: SortOrder
    address_zip_code?: SortOrder
    address_country?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    contact_mobile?: SortOrder
    contact_fax?: SortOrder
    contact_email?: SortOrder
    account_type?: SortOrder
    bank_account_number?: SortOrder
    bank_branch?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settlement_accountsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type settlement_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    bank_name?: SortOrder
    bank_payment_code?: SortOrder
    bank_code?: SortOrder
    address_building_number?: SortOrder
    address_street_name?: SortOrder
    address_street_name2?: SortOrder
    address_city?: SortOrder
    address_province?: SortOrder
    address_zip_code?: SortOrder
    address_country?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    contact_mobile?: SortOrder
    contact_fax?: SortOrder
    contact_email?: SortOrder
    account_type?: SortOrder
    bank_account_number?: SortOrder
    bank_branch?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settlement_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    bank_name?: SortOrder
    bank_payment_code?: SortOrder
    bank_code?: SortOrder
    address_building_number?: SortOrder
    address_street_name?: SortOrder
    address_street_name2?: SortOrder
    address_city?: SortOrder
    address_province?: SortOrder
    address_zip_code?: SortOrder
    address_country?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    contact_mobile?: SortOrder
    contact_fax?: SortOrder
    contact_email?: SortOrder
    account_type?: SortOrder
    bank_account_number?: SortOrder
    bank_branch?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settlement_accountsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type strategy_masterOrderByRelevanceInput = {
    fields: strategy_masterOrderByRelevanceFieldEnum | strategy_masterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type strategy_masterCountOrderByAggregateInput = {
    strategy_id?: SortOrder
    portfolio_name?: SortOrder
    strategy_type?: SortOrder
    entity_business_unit?: SortOrder
  }

  export type strategy_masterMaxOrderByAggregateInput = {
    strategy_id?: SortOrder
    portfolio_name?: SortOrder
    strategy_type?: SortOrder
    entity_business_unit?: SortOrder
  }

  export type strategy_masterMinOrderByAggregateInput = {
    strategy_id?: SortOrder
    portfolio_name?: SortOrder
    strategy_type?: SortOrder
    entity_business_unit?: SortOrder
  }

  export type transaction_typesOrderByRelevanceInput = {
    fields: transaction_typesOrderByRelevanceFieldEnum | transaction_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type transaction_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transaction_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type transaction_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transaction_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transaction_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumusers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleFilter<$PrismaModel> | $Enums.users_role
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    allowed_tabs?: SortOrder
    limit_id?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    limit_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    allowed_tabs?: SortOrder
    limit_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    allowed_tabs?: SortOrder
    limit_id?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    limit_id?: SortOrder
  }

  export type Enumusers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleWithAggregatesFilter<$PrismaModel> | $Enums.users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_roleFilter<$PrismaModel>
    _max?: NestedEnumusers_roleFilter<$PrismaModel>
  }

  export type chart_of_accountsCreateNestedManyWithoutAccount_typesInput = {
    create?: XOR<chart_of_accountsCreateWithoutAccount_typesInput, chart_of_accountsUncheckedCreateWithoutAccount_typesInput> | chart_of_accountsCreateWithoutAccount_typesInput[] | chart_of_accountsUncheckedCreateWithoutAccount_typesInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutAccount_typesInput | chart_of_accountsCreateOrConnectWithoutAccount_typesInput[]
    createMany?: chart_of_accountsCreateManyAccount_typesInputEnvelope
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
  }

  export type chart_of_accountsUncheckedCreateNestedManyWithoutAccount_typesInput = {
    create?: XOR<chart_of_accountsCreateWithoutAccount_typesInput, chart_of_accountsUncheckedCreateWithoutAccount_typesInput> | chart_of_accountsCreateWithoutAccount_typesInput[] | chart_of_accountsUncheckedCreateWithoutAccount_typesInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutAccount_typesInput | chart_of_accountsCreateOrConnectWithoutAccount_typesInput[]
    createMany?: chart_of_accountsCreateManyAccount_typesInputEnvelope
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type Enumaccount_types_categoryFieldUpdateOperationsInput = {
    set?: $Enums.account_types_category
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type chart_of_accountsUpdateManyWithoutAccount_typesNestedInput = {
    create?: XOR<chart_of_accountsCreateWithoutAccount_typesInput, chart_of_accountsUncheckedCreateWithoutAccount_typesInput> | chart_of_accountsCreateWithoutAccount_typesInput[] | chart_of_accountsUncheckedCreateWithoutAccount_typesInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutAccount_typesInput | chart_of_accountsCreateOrConnectWithoutAccount_typesInput[]
    upsert?: chart_of_accountsUpsertWithWhereUniqueWithoutAccount_typesInput | chart_of_accountsUpsertWithWhereUniqueWithoutAccount_typesInput[]
    createMany?: chart_of_accountsCreateManyAccount_typesInputEnvelope
    set?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    disconnect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    delete?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    update?: chart_of_accountsUpdateWithWhereUniqueWithoutAccount_typesInput | chart_of_accountsUpdateWithWhereUniqueWithoutAccount_typesInput[]
    updateMany?: chart_of_accountsUpdateManyWithWhereWithoutAccount_typesInput | chart_of_accountsUpdateManyWithWhereWithoutAccount_typesInput[]
    deleteMany?: chart_of_accountsScalarWhereInput | chart_of_accountsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type chart_of_accountsUncheckedUpdateManyWithoutAccount_typesNestedInput = {
    create?: XOR<chart_of_accountsCreateWithoutAccount_typesInput, chart_of_accountsUncheckedCreateWithoutAccount_typesInput> | chart_of_accountsCreateWithoutAccount_typesInput[] | chart_of_accountsUncheckedCreateWithoutAccount_typesInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutAccount_typesInput | chart_of_accountsCreateOrConnectWithoutAccount_typesInput[]
    upsert?: chart_of_accountsUpsertWithWhereUniqueWithoutAccount_typesInput | chart_of_accountsUpsertWithWhereUniqueWithoutAccount_typesInput[]
    createMany?: chart_of_accountsCreateManyAccount_typesInputEnvelope
    set?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    disconnect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    delete?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    update?: chart_of_accountsUpdateWithWhereUniqueWithoutAccount_typesInput | chart_of_accountsUpdateWithWhereUniqueWithoutAccount_typesInput[]
    updateMany?: chart_of_accountsUpdateManyWithWhereWithoutAccount_typesInput | chart_of_accountsUpdateManyWithWhereWithoutAccount_typesInput[]
    deleteMany?: chart_of_accountsScalarWhereInput | chart_of_accountsScalarWhereInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type account_typesCreateNestedOneWithoutChart_of_accountsInput = {
    create?: XOR<account_typesCreateWithoutChart_of_accountsInput, account_typesUncheckedCreateWithoutChart_of_accountsInput>
    connectOrCreate?: account_typesCreateOrConnectWithoutChart_of_accountsInput
    connect?: account_typesWhereUniqueInput
  }

  export type chart_of_accountsCreateNestedOneWithoutOther_chart_of_accountsInput = {
    create?: XOR<chart_of_accountsCreateWithoutOther_chart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutOther_chart_of_accountsInput>
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutOther_chart_of_accountsInput
    connect?: chart_of_accountsWhereUniqueInput
  }

  export type chart_of_accountsCreateNestedManyWithoutChart_of_accountsInput = {
    create?: XOR<chart_of_accountsCreateWithoutChart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput> | chart_of_accountsCreateWithoutChart_of_accountsInput[] | chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput | chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput[]
    createMany?: chart_of_accountsCreateManyChart_of_accountsInputEnvelope
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
  }

  export type ledger_entriesCreateNestedManyWithoutChart_of_accountsInput = {
    create?: XOR<ledger_entriesCreateWithoutChart_of_accountsInput, ledger_entriesUncheckedCreateWithoutChart_of_accountsInput> | ledger_entriesCreateWithoutChart_of_accountsInput[] | ledger_entriesUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: ledger_entriesCreateOrConnectWithoutChart_of_accountsInput | ledger_entriesCreateOrConnectWithoutChart_of_accountsInput[]
    createMany?: ledger_entriesCreateManyChart_of_accountsInputEnvelope
    connect?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
  }

  export type chart_of_accountsUncheckedCreateNestedManyWithoutChart_of_accountsInput = {
    create?: XOR<chart_of_accountsCreateWithoutChart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput> | chart_of_accountsCreateWithoutChart_of_accountsInput[] | chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput | chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput[]
    createMany?: chart_of_accountsCreateManyChart_of_accountsInputEnvelope
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
  }

  export type ledger_entriesUncheckedCreateNestedManyWithoutChart_of_accountsInput = {
    create?: XOR<ledger_entriesCreateWithoutChart_of_accountsInput, ledger_entriesUncheckedCreateWithoutChart_of_accountsInput> | ledger_entriesCreateWithoutChart_of_accountsInput[] | ledger_entriesUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: ledger_entriesCreateOrConnectWithoutChart_of_accountsInput | ledger_entriesCreateOrConnectWithoutChart_of_accountsInput[]
    createMany?: ledger_entriesCreateManyChart_of_accountsInputEnvelope
    connect?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type account_typesUpdateOneRequiredWithoutChart_of_accountsNestedInput = {
    create?: XOR<account_typesCreateWithoutChart_of_accountsInput, account_typesUncheckedCreateWithoutChart_of_accountsInput>
    connectOrCreate?: account_typesCreateOrConnectWithoutChart_of_accountsInput
    upsert?: account_typesUpsertWithoutChart_of_accountsInput
    connect?: account_typesWhereUniqueInput
    update?: XOR<XOR<account_typesUpdateToOneWithWhereWithoutChart_of_accountsInput, account_typesUpdateWithoutChart_of_accountsInput>, account_typesUncheckedUpdateWithoutChart_of_accountsInput>
  }

  export type chart_of_accountsUpdateOneWithoutOther_chart_of_accountsNestedInput = {
    create?: XOR<chart_of_accountsCreateWithoutOther_chart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutOther_chart_of_accountsInput>
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutOther_chart_of_accountsInput
    upsert?: chart_of_accountsUpsertWithoutOther_chart_of_accountsInput
    disconnect?: chart_of_accountsWhereInput | boolean
    delete?: chart_of_accountsWhereInput | boolean
    connect?: chart_of_accountsWhereUniqueInput
    update?: XOR<XOR<chart_of_accountsUpdateToOneWithWhereWithoutOther_chart_of_accountsInput, chart_of_accountsUpdateWithoutOther_chart_of_accountsInput>, chart_of_accountsUncheckedUpdateWithoutOther_chart_of_accountsInput>
  }

  export type chart_of_accountsUpdateManyWithoutChart_of_accountsNestedInput = {
    create?: XOR<chart_of_accountsCreateWithoutChart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput> | chart_of_accountsCreateWithoutChart_of_accountsInput[] | chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput | chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput[]
    upsert?: chart_of_accountsUpsertWithWhereUniqueWithoutChart_of_accountsInput | chart_of_accountsUpsertWithWhereUniqueWithoutChart_of_accountsInput[]
    createMany?: chart_of_accountsCreateManyChart_of_accountsInputEnvelope
    set?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    disconnect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    delete?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    update?: chart_of_accountsUpdateWithWhereUniqueWithoutChart_of_accountsInput | chart_of_accountsUpdateWithWhereUniqueWithoutChart_of_accountsInput[]
    updateMany?: chart_of_accountsUpdateManyWithWhereWithoutChart_of_accountsInput | chart_of_accountsUpdateManyWithWhereWithoutChart_of_accountsInput[]
    deleteMany?: chart_of_accountsScalarWhereInput | chart_of_accountsScalarWhereInput[]
  }

  export type ledger_entriesUpdateManyWithoutChart_of_accountsNestedInput = {
    create?: XOR<ledger_entriesCreateWithoutChart_of_accountsInput, ledger_entriesUncheckedCreateWithoutChart_of_accountsInput> | ledger_entriesCreateWithoutChart_of_accountsInput[] | ledger_entriesUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: ledger_entriesCreateOrConnectWithoutChart_of_accountsInput | ledger_entriesCreateOrConnectWithoutChart_of_accountsInput[]
    upsert?: ledger_entriesUpsertWithWhereUniqueWithoutChart_of_accountsInput | ledger_entriesUpsertWithWhereUniqueWithoutChart_of_accountsInput[]
    createMany?: ledger_entriesCreateManyChart_of_accountsInputEnvelope
    set?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    disconnect?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    delete?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    connect?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    update?: ledger_entriesUpdateWithWhereUniqueWithoutChart_of_accountsInput | ledger_entriesUpdateWithWhereUniqueWithoutChart_of_accountsInput[]
    updateMany?: ledger_entriesUpdateManyWithWhereWithoutChart_of_accountsInput | ledger_entriesUpdateManyWithWhereWithoutChart_of_accountsInput[]
    deleteMany?: ledger_entriesScalarWhereInput | ledger_entriesScalarWhereInput[]
  }

  export type chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsNestedInput = {
    create?: XOR<chart_of_accountsCreateWithoutChart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput> | chart_of_accountsCreateWithoutChart_of_accountsInput[] | chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput | chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput[]
    upsert?: chart_of_accountsUpsertWithWhereUniqueWithoutChart_of_accountsInput | chart_of_accountsUpsertWithWhereUniqueWithoutChart_of_accountsInput[]
    createMany?: chart_of_accountsCreateManyChart_of_accountsInputEnvelope
    set?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    disconnect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    delete?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    connect?: chart_of_accountsWhereUniqueInput | chart_of_accountsWhereUniqueInput[]
    update?: chart_of_accountsUpdateWithWhereUniqueWithoutChart_of_accountsInput | chart_of_accountsUpdateWithWhereUniqueWithoutChart_of_accountsInput[]
    updateMany?: chart_of_accountsUpdateManyWithWhereWithoutChart_of_accountsInput | chart_of_accountsUpdateManyWithWhereWithoutChart_of_accountsInput[]
    deleteMany?: chart_of_accountsScalarWhereInput | chart_of_accountsScalarWhereInput[]
  }

  export type ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsNestedInput = {
    create?: XOR<ledger_entriesCreateWithoutChart_of_accountsInput, ledger_entriesUncheckedCreateWithoutChart_of_accountsInput> | ledger_entriesCreateWithoutChart_of_accountsInput[] | ledger_entriesUncheckedCreateWithoutChart_of_accountsInput[]
    connectOrCreate?: ledger_entriesCreateOrConnectWithoutChart_of_accountsInput | ledger_entriesCreateOrConnectWithoutChart_of_accountsInput[]
    upsert?: ledger_entriesUpsertWithWhereUniqueWithoutChart_of_accountsInput | ledger_entriesUpsertWithWhereUniqueWithoutChart_of_accountsInput[]
    createMany?: ledger_entriesCreateManyChart_of_accountsInputEnvelope
    set?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    disconnect?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    delete?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    connect?: ledger_entriesWhereUniqueInput | ledger_entriesWhereUniqueInput[]
    update?: ledger_entriesUpdateWithWhereUniqueWithoutChart_of_accountsInput | ledger_entriesUpdateWithWhereUniqueWithoutChart_of_accountsInput[]
    updateMany?: ledger_entriesUpdateManyWithWhereWithoutChart_of_accountsInput | ledger_entriesUpdateManyWithWhereWithoutChart_of_accountsInput[]
    deleteMany?: ledger_entriesScalarWhereInput | ledger_entriesScalarWhereInput[]
  }

  export type Enumcounterparty_limits_counterparty_typeFieldUpdateOperationsInput = {
    set?: $Enums.counterparty_limits_counterparty_type
  }

  export type isin_masterCreateNestedOneWithoutIsin_coupon_scheduleInput = {
    create?: XOR<isin_masterCreateWithoutIsin_coupon_scheduleInput, isin_masterUncheckedCreateWithoutIsin_coupon_scheduleInput>
    connectOrCreate?: isin_masterCreateOrConnectWithoutIsin_coupon_scheduleInput
    connect?: isin_masterWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type isin_masterUpdateOneRequiredWithoutIsin_coupon_scheduleNestedInput = {
    create?: XOR<isin_masterCreateWithoutIsin_coupon_scheduleInput, isin_masterUncheckedCreateWithoutIsin_coupon_scheduleInput>
    connectOrCreate?: isin_masterCreateOrConnectWithoutIsin_coupon_scheduleInput
    upsert?: isin_masterUpsertWithoutIsin_coupon_scheduleInput
    connect?: isin_masterWhereUniqueInput
    update?: XOR<XOR<isin_masterUpdateToOneWithWhereWithoutIsin_coupon_scheduleInput, isin_masterUpdateWithoutIsin_coupon_scheduleInput>, isin_masterUncheckedUpdateWithoutIsin_coupon_scheduleInput>
  }

  export type isin_coupon_scheduleCreateNestedManyWithoutIsin_masterInput = {
    create?: XOR<isin_coupon_scheduleCreateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput> | isin_coupon_scheduleCreateWithoutIsin_masterInput[] | isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput[]
    connectOrCreate?: isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput | isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput[]
    createMany?: isin_coupon_scheduleCreateManyIsin_masterInputEnvelope
    connect?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
  }

  export type isin_coupon_scheduleUncheckedCreateNestedManyWithoutIsin_masterInput = {
    create?: XOR<isin_coupon_scheduleCreateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput> | isin_coupon_scheduleCreateWithoutIsin_masterInput[] | isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput[]
    connectOrCreate?: isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput | isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput[]
    createMany?: isin_coupon_scheduleCreateManyIsin_masterInputEnvelope
    connect?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
  }

  export type isin_coupon_scheduleUpdateManyWithoutIsin_masterNestedInput = {
    create?: XOR<isin_coupon_scheduleCreateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput> | isin_coupon_scheduleCreateWithoutIsin_masterInput[] | isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput[]
    connectOrCreate?: isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput | isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput[]
    upsert?: isin_coupon_scheduleUpsertWithWhereUniqueWithoutIsin_masterInput | isin_coupon_scheduleUpsertWithWhereUniqueWithoutIsin_masterInput[]
    createMany?: isin_coupon_scheduleCreateManyIsin_masterInputEnvelope
    set?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    disconnect?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    delete?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    connect?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    update?: isin_coupon_scheduleUpdateWithWhereUniqueWithoutIsin_masterInput | isin_coupon_scheduleUpdateWithWhereUniqueWithoutIsin_masterInput[]
    updateMany?: isin_coupon_scheduleUpdateManyWithWhereWithoutIsin_masterInput | isin_coupon_scheduleUpdateManyWithWhereWithoutIsin_masterInput[]
    deleteMany?: isin_coupon_scheduleScalarWhereInput | isin_coupon_scheduleScalarWhereInput[]
  }

  export type isin_coupon_scheduleUncheckedUpdateManyWithoutIsin_masterNestedInput = {
    create?: XOR<isin_coupon_scheduleCreateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput> | isin_coupon_scheduleCreateWithoutIsin_masterInput[] | isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput[]
    connectOrCreate?: isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput | isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput[]
    upsert?: isin_coupon_scheduleUpsertWithWhereUniqueWithoutIsin_masterInput | isin_coupon_scheduleUpsertWithWhereUniqueWithoutIsin_masterInput[]
    createMany?: isin_coupon_scheduleCreateManyIsin_masterInputEnvelope
    set?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    disconnect?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    delete?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    connect?: isin_coupon_scheduleWhereUniqueInput | isin_coupon_scheduleWhereUniqueInput[]
    update?: isin_coupon_scheduleUpdateWithWhereUniqueWithoutIsin_masterInput | isin_coupon_scheduleUpdateWithWhereUniqueWithoutIsin_masterInput[]
    updateMany?: isin_coupon_scheduleUpdateManyWithWhereWithoutIsin_masterInput | isin_coupon_scheduleUpdateManyWithWhereWithoutIsin_masterInput[]
    deleteMany?: isin_coupon_scheduleScalarWhereInput | isin_coupon_scheduleScalarWhereInput[]
  }

  export type chart_of_accountsCreateNestedOneWithoutLedger_entriesInput = {
    create?: XOR<chart_of_accountsCreateWithoutLedger_entriesInput, chart_of_accountsUncheckedCreateWithoutLedger_entriesInput>
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutLedger_entriesInput
    connect?: chart_of_accountsWhereUniqueInput
  }

  export type chart_of_accountsUpdateOneRequiredWithoutLedger_entriesNestedInput = {
    create?: XOR<chart_of_accountsCreateWithoutLedger_entriesInput, chart_of_accountsUncheckedCreateWithoutLedger_entriesInput>
    connectOrCreate?: chart_of_accountsCreateOrConnectWithoutLedger_entriesInput
    upsert?: chart_of_accountsUpsertWithoutLedger_entriesInput
    connect?: chart_of_accountsWhereUniqueInput
    update?: XOR<XOR<chart_of_accountsUpdateToOneWithWhereWithoutLedger_entriesInput, chart_of_accountsUpdateWithoutLedger_entriesInput>, chart_of_accountsUncheckedUpdateWithoutLedger_entriesInput>
  }

  export type Enummoney_market_deals_counterparty_typeFieldUpdateOperationsInput = {
    set?: $Enums.money_market_deals_counterparty_type
  }

  export type portfolio_masterCreateNestedOneWithoutOther_portfolio_masterInput = {
    create?: XOR<portfolio_masterCreateWithoutOther_portfolio_masterInput, portfolio_masterUncheckedCreateWithoutOther_portfolio_masterInput>
    connectOrCreate?: portfolio_masterCreateOrConnectWithoutOther_portfolio_masterInput
    connect?: portfolio_masterWhereUniqueInput
  }

  export type portfolio_masterCreateNestedManyWithoutPortfolio_masterInput = {
    create?: XOR<portfolio_masterCreateWithoutPortfolio_masterInput, portfolio_masterUncheckedCreateWithoutPortfolio_masterInput> | portfolio_masterCreateWithoutPortfolio_masterInput[] | portfolio_masterUncheckedCreateWithoutPortfolio_masterInput[]
    connectOrCreate?: portfolio_masterCreateOrConnectWithoutPortfolio_masterInput | portfolio_masterCreateOrConnectWithoutPortfolio_masterInput[]
    createMany?: portfolio_masterCreateManyPortfolio_masterInputEnvelope
    connect?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
  }

  export type portfolio_masterUncheckedCreateNestedManyWithoutPortfolio_masterInput = {
    create?: XOR<portfolio_masterCreateWithoutPortfolio_masterInput, portfolio_masterUncheckedCreateWithoutPortfolio_masterInput> | portfolio_masterCreateWithoutPortfolio_masterInput[] | portfolio_masterUncheckedCreateWithoutPortfolio_masterInput[]
    connectOrCreate?: portfolio_masterCreateOrConnectWithoutPortfolio_masterInput | portfolio_masterCreateOrConnectWithoutPortfolio_masterInput[]
    createMany?: portfolio_masterCreateManyPortfolio_masterInputEnvelope
    connect?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
  }

  export type NullableEnumportfolio_master_statusFieldUpdateOperationsInput = {
    set?: $Enums.portfolio_master_status | null
  }

  export type NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput = {
    set?: $Enums.portfolio_master_risk_profile | null
  }

  export type NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput = {
    set?: $Enums.portfolio_master_investment_horizon | null
  }

  export type portfolio_masterUpdateOneWithoutOther_portfolio_masterNestedInput = {
    create?: XOR<portfolio_masterCreateWithoutOther_portfolio_masterInput, portfolio_masterUncheckedCreateWithoutOther_portfolio_masterInput>
    connectOrCreate?: portfolio_masterCreateOrConnectWithoutOther_portfolio_masterInput
    upsert?: portfolio_masterUpsertWithoutOther_portfolio_masterInput
    disconnect?: portfolio_masterWhereInput | boolean
    delete?: portfolio_masterWhereInput | boolean
    connect?: portfolio_masterWhereUniqueInput
    update?: XOR<XOR<portfolio_masterUpdateToOneWithWhereWithoutOther_portfolio_masterInput, portfolio_masterUpdateWithoutOther_portfolio_masterInput>, portfolio_masterUncheckedUpdateWithoutOther_portfolio_masterInput>
  }

  export type portfolio_masterUpdateManyWithoutPortfolio_masterNestedInput = {
    create?: XOR<portfolio_masterCreateWithoutPortfolio_masterInput, portfolio_masterUncheckedCreateWithoutPortfolio_masterInput> | portfolio_masterCreateWithoutPortfolio_masterInput[] | portfolio_masterUncheckedCreateWithoutPortfolio_masterInput[]
    connectOrCreate?: portfolio_masterCreateOrConnectWithoutPortfolio_masterInput | portfolio_masterCreateOrConnectWithoutPortfolio_masterInput[]
    upsert?: portfolio_masterUpsertWithWhereUniqueWithoutPortfolio_masterInput | portfolio_masterUpsertWithWhereUniqueWithoutPortfolio_masterInput[]
    createMany?: portfolio_masterCreateManyPortfolio_masterInputEnvelope
    set?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    disconnect?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    delete?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    connect?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    update?: portfolio_masterUpdateWithWhereUniqueWithoutPortfolio_masterInput | portfolio_masterUpdateWithWhereUniqueWithoutPortfolio_masterInput[]
    updateMany?: portfolio_masterUpdateManyWithWhereWithoutPortfolio_masterInput | portfolio_masterUpdateManyWithWhereWithoutPortfolio_masterInput[]
    deleteMany?: portfolio_masterScalarWhereInput | portfolio_masterScalarWhereInput[]
  }

  export type portfolio_masterUncheckedUpdateManyWithoutPortfolio_masterNestedInput = {
    create?: XOR<portfolio_masterCreateWithoutPortfolio_masterInput, portfolio_masterUncheckedCreateWithoutPortfolio_masterInput> | portfolio_masterCreateWithoutPortfolio_masterInput[] | portfolio_masterUncheckedCreateWithoutPortfolio_masterInput[]
    connectOrCreate?: portfolio_masterCreateOrConnectWithoutPortfolio_masterInput | portfolio_masterCreateOrConnectWithoutPortfolio_masterInput[]
    upsert?: portfolio_masterUpsertWithWhereUniqueWithoutPortfolio_masterInput | portfolio_masterUpsertWithWhereUniqueWithoutPortfolio_masterInput[]
    createMany?: portfolio_masterCreateManyPortfolio_masterInputEnvelope
    set?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    disconnect?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    delete?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    connect?: portfolio_masterWhereUniqueInput | portfolio_masterWhereUniqueInput[]
    update?: portfolio_masterUpdateWithWhereUniqueWithoutPortfolio_masterInput | portfolio_masterUpdateWithWhereUniqueWithoutPortfolio_masterInput[]
    updateMany?: portfolio_masterUpdateManyWithWhereWithoutPortfolio_masterInput | portfolio_masterUpdateManyWithWhereWithoutPortfolio_masterInput[]
    deleteMany?: portfolio_masterScalarWhereInput | portfolio_masterScalarWhereInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type Enumusers_roleFieldUpdateOperationsInput = {
    set?: $Enums.users_role
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumaccount_types_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.account_types_category | Enumaccount_types_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.account_types_category[]
    notIn?: $Enums.account_types_category[]
    not?: NestedEnumaccount_types_categoryFilter<$PrismaModel> | $Enums.account_types_category
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumaccount_types_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.account_types_category | Enumaccount_types_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.account_types_category[]
    notIn?: $Enums.account_types_category[]
    not?: NestedEnumaccount_types_categoryWithAggregatesFilter<$PrismaModel> | $Enums.account_types_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumaccount_types_categoryFilter<$PrismaModel>
    _max?: NestedEnumaccount_types_categoryFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.counterparty_limits_counterparty_type | Enumcounterparty_limits_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.counterparty_limits_counterparty_type[]
    notIn?: $Enums.counterparty_limits_counterparty_type[]
    not?: NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel> | $Enums.counterparty_limits_counterparty_type
  }

  export type NestedEnumcounterparty_limits_counterparty_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.counterparty_limits_counterparty_type | Enumcounterparty_limits_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.counterparty_limits_counterparty_type[]
    notIn?: $Enums.counterparty_limits_counterparty_type[]
    not?: NestedEnumcounterparty_limits_counterparty_typeWithAggregatesFilter<$PrismaModel> | $Enums.counterparty_limits_counterparty_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel>
    _max?: NestedEnumcounterparty_limits_counterparty_typeFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.money_market_deals_counterparty_type | Enummoney_market_deals_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.money_market_deals_counterparty_type[]
    notIn?: $Enums.money_market_deals_counterparty_type[]
    not?: NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel> | $Enums.money_market_deals_counterparty_type
  }

  export type NestedEnummoney_market_deals_counterparty_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.money_market_deals_counterparty_type | Enummoney_market_deals_counterparty_typeFieldRefInput<$PrismaModel>
    in?: $Enums.money_market_deals_counterparty_type[]
    notIn?: $Enums.money_market_deals_counterparty_type[]
    not?: NestedEnummoney_market_deals_counterparty_typeWithAggregatesFilter<$PrismaModel> | $Enums.money_market_deals_counterparty_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel>
    _max?: NestedEnummoney_market_deals_counterparty_typeFilter<$PrismaModel>
  }

  export type NestedEnumportfolio_master_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_status | Enumportfolio_master_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_status[] | null
    notIn?: $Enums.portfolio_master_status[] | null
    not?: NestedEnumportfolio_master_statusNullableFilter<$PrismaModel> | $Enums.portfolio_master_status | null
  }

  export type NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_risk_profile | Enumportfolio_master_risk_profileFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_risk_profile[] | null
    notIn?: $Enums.portfolio_master_risk_profile[] | null
    not?: NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel> | $Enums.portfolio_master_risk_profile | null
  }

  export type NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_investment_horizon | Enumportfolio_master_investment_horizonFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_investment_horizon[] | null
    notIn?: $Enums.portfolio_master_investment_horizon[] | null
    not?: NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel> | $Enums.portfolio_master_investment_horizon | null
  }

  export type NestedEnumportfolio_master_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_status | Enumportfolio_master_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_status[] | null
    notIn?: $Enums.portfolio_master_status[] | null
    not?: NestedEnumportfolio_master_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.portfolio_master_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumportfolio_master_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumportfolio_master_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumportfolio_master_risk_profileNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_risk_profile | Enumportfolio_master_risk_profileFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_risk_profile[] | null
    notIn?: $Enums.portfolio_master_risk_profile[] | null
    not?: NestedEnumportfolio_master_risk_profileNullableWithAggregatesFilter<$PrismaModel> | $Enums.portfolio_master_risk_profile | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel>
    _max?: NestedEnumportfolio_master_risk_profileNullableFilter<$PrismaModel>
  }

  export type NestedEnumportfolio_master_investment_horizonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portfolio_master_investment_horizon | Enumportfolio_master_investment_horizonFieldRefInput<$PrismaModel> | null
    in?: $Enums.portfolio_master_investment_horizon[] | null
    notIn?: $Enums.portfolio_master_investment_horizon[] | null
    not?: NestedEnumportfolio_master_investment_horizonNullableWithAggregatesFilter<$PrismaModel> | $Enums.portfolio_master_investment_horizon | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel>
    _max?: NestedEnumportfolio_master_investment_horizonNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumusers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleFilter<$PrismaModel> | $Enums.users_role
  }

  export type NestedEnumusers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleWithAggregatesFilter<$PrismaModel> | $Enums.users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_roleFilter<$PrismaModel>
    _max?: NestedEnumusers_roleFilter<$PrismaModel>
  }

  export type chart_of_accountsCreateWithoutAccount_typesInput = {
    account_code: string
    name: string
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    chart_of_accounts?: chart_of_accountsCreateNestedOneWithoutOther_chart_of_accountsInput
    other_chart_of_accounts?: chart_of_accountsCreateNestedManyWithoutChart_of_accountsInput
    ledger_entries?: ledger_entriesCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsUncheckedCreateWithoutAccount_typesInput = {
    id?: number
    account_code: string
    name: string
    parent_account_id?: number | null
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedCreateNestedManyWithoutChart_of_accountsInput
    ledger_entries?: ledger_entriesUncheckedCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsCreateOrConnectWithoutAccount_typesInput = {
    where: chart_of_accountsWhereUniqueInput
    create: XOR<chart_of_accountsCreateWithoutAccount_typesInput, chart_of_accountsUncheckedCreateWithoutAccount_typesInput>
  }

  export type chart_of_accountsCreateManyAccount_typesInputEnvelope = {
    data: chart_of_accountsCreateManyAccount_typesInput | chart_of_accountsCreateManyAccount_typesInput[]
    skipDuplicates?: boolean
  }

  export type chart_of_accountsUpsertWithWhereUniqueWithoutAccount_typesInput = {
    where: chart_of_accountsWhereUniqueInput
    update: XOR<chart_of_accountsUpdateWithoutAccount_typesInput, chart_of_accountsUncheckedUpdateWithoutAccount_typesInput>
    create: XOR<chart_of_accountsCreateWithoutAccount_typesInput, chart_of_accountsUncheckedCreateWithoutAccount_typesInput>
  }

  export type chart_of_accountsUpdateWithWhereUniqueWithoutAccount_typesInput = {
    where: chart_of_accountsWhereUniqueInput
    data: XOR<chart_of_accountsUpdateWithoutAccount_typesInput, chart_of_accountsUncheckedUpdateWithoutAccount_typesInput>
  }

  export type chart_of_accountsUpdateManyWithWhereWithoutAccount_typesInput = {
    where: chart_of_accountsScalarWhereInput
    data: XOR<chart_of_accountsUpdateManyMutationInput, chart_of_accountsUncheckedUpdateManyWithoutAccount_typesInput>
  }

  export type chart_of_accountsScalarWhereInput = {
    AND?: chart_of_accountsScalarWhereInput | chart_of_accountsScalarWhereInput[]
    OR?: chart_of_accountsScalarWhereInput[]
    NOT?: chart_of_accountsScalarWhereInput | chart_of_accountsScalarWhereInput[]
    id?: IntFilter<"chart_of_accounts"> | number
    account_code?: StringFilter<"chart_of_accounts"> | string
    name?: StringFilter<"chart_of_accounts"> | string
    account_type_id?: IntFilter<"chart_of_accounts"> | number
    parent_account_id?: IntNullableFilter<"chart_of_accounts"> | number | null
    description?: StringNullableFilter<"chart_of_accounts"> | string | null
    is_active?: BoolNullableFilter<"chart_of_accounts"> | boolean | null
    created_at?: DateTimeNullableFilter<"chart_of_accounts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chart_of_accounts"> | Date | string | null
  }

  export type account_typesCreateWithoutChart_of_accountsInput = {
    name: string
    category: $Enums.account_types_category
    description?: string | null
    created_at?: Date | string | null
  }

  export type account_typesUncheckedCreateWithoutChart_of_accountsInput = {
    id?: number
    name: string
    category: $Enums.account_types_category
    description?: string | null
    created_at?: Date | string | null
  }

  export type account_typesCreateOrConnectWithoutChart_of_accountsInput = {
    where: account_typesWhereUniqueInput
    create: XOR<account_typesCreateWithoutChart_of_accountsInput, account_typesUncheckedCreateWithoutChart_of_accountsInput>
  }

  export type chart_of_accountsCreateWithoutOther_chart_of_accountsInput = {
    account_code: string
    name: string
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    account_types: account_typesCreateNestedOneWithoutChart_of_accountsInput
    chart_of_accounts?: chart_of_accountsCreateNestedOneWithoutOther_chart_of_accountsInput
    ledger_entries?: ledger_entriesCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsUncheckedCreateWithoutOther_chart_of_accountsInput = {
    id?: number
    account_code: string
    name: string
    account_type_id: number
    parent_account_id?: number | null
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ledger_entries?: ledger_entriesUncheckedCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsCreateOrConnectWithoutOther_chart_of_accountsInput = {
    where: chart_of_accountsWhereUniqueInput
    create: XOR<chart_of_accountsCreateWithoutOther_chart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutOther_chart_of_accountsInput>
  }

  export type chart_of_accountsCreateWithoutChart_of_accountsInput = {
    account_code: string
    name: string
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    account_types: account_typesCreateNestedOneWithoutChart_of_accountsInput
    other_chart_of_accounts?: chart_of_accountsCreateNestedManyWithoutChart_of_accountsInput
    ledger_entries?: ledger_entriesCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput = {
    id?: number
    account_code: string
    name: string
    account_type_id: number
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedCreateNestedManyWithoutChart_of_accountsInput
    ledger_entries?: ledger_entriesUncheckedCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsCreateOrConnectWithoutChart_of_accountsInput = {
    where: chart_of_accountsWhereUniqueInput
    create: XOR<chart_of_accountsCreateWithoutChart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput>
  }

  export type chart_of_accountsCreateManyChart_of_accountsInputEnvelope = {
    data: chart_of_accountsCreateManyChart_of_accountsInput | chart_of_accountsCreateManyChart_of_accountsInput[]
    skipDuplicates?: boolean
  }

  export type ledger_entriesCreateWithoutChart_of_accountsInput = {
    entry_date: Date | string
    debit_amount?: Decimal | DecimalJsLike | number | string | null
    credit_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deal_number?: string | null
  }

  export type ledger_entriesUncheckedCreateWithoutChart_of_accountsInput = {
    id?: number
    entry_date: Date | string
    debit_amount?: Decimal | DecimalJsLike | number | string | null
    credit_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deal_number?: string | null
  }

  export type ledger_entriesCreateOrConnectWithoutChart_of_accountsInput = {
    where: ledger_entriesWhereUniqueInput
    create: XOR<ledger_entriesCreateWithoutChart_of_accountsInput, ledger_entriesUncheckedCreateWithoutChart_of_accountsInput>
  }

  export type ledger_entriesCreateManyChart_of_accountsInputEnvelope = {
    data: ledger_entriesCreateManyChart_of_accountsInput | ledger_entriesCreateManyChart_of_accountsInput[]
    skipDuplicates?: boolean
  }

  export type account_typesUpsertWithoutChart_of_accountsInput = {
    update: XOR<account_typesUpdateWithoutChart_of_accountsInput, account_typesUncheckedUpdateWithoutChart_of_accountsInput>
    create: XOR<account_typesCreateWithoutChart_of_accountsInput, account_typesUncheckedCreateWithoutChart_of_accountsInput>
    where?: account_typesWhereInput
  }

  export type account_typesUpdateToOneWithWhereWithoutChart_of_accountsInput = {
    where?: account_typesWhereInput
    data: XOR<account_typesUpdateWithoutChart_of_accountsInput, account_typesUncheckedUpdateWithoutChart_of_accountsInput>
  }

  export type account_typesUpdateWithoutChart_of_accountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: Enumaccount_types_categoryFieldUpdateOperationsInput | $Enums.account_types_category
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type account_typesUncheckedUpdateWithoutChart_of_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: Enumaccount_types_categoryFieldUpdateOperationsInput | $Enums.account_types_category
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chart_of_accountsUpsertWithoutOther_chart_of_accountsInput = {
    update: XOR<chart_of_accountsUpdateWithoutOther_chart_of_accountsInput, chart_of_accountsUncheckedUpdateWithoutOther_chart_of_accountsInput>
    create: XOR<chart_of_accountsCreateWithoutOther_chart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutOther_chart_of_accountsInput>
    where?: chart_of_accountsWhereInput
  }

  export type chart_of_accountsUpdateToOneWithWhereWithoutOther_chart_of_accountsInput = {
    where?: chart_of_accountsWhereInput
    data: XOR<chart_of_accountsUpdateWithoutOther_chart_of_accountsInput, chart_of_accountsUncheckedUpdateWithoutOther_chart_of_accountsInput>
  }

  export type chart_of_accountsUpdateWithoutOther_chart_of_accountsInput = {
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_types?: account_typesUpdateOneRequiredWithoutChart_of_accountsNestedInput
    chart_of_accounts?: chart_of_accountsUpdateOneWithoutOther_chart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateWithoutOther_chart_of_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_type_id?: IntFieldUpdateOperationsInput | number
    parent_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledger_entries?: ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUpsertWithWhereUniqueWithoutChart_of_accountsInput = {
    where: chart_of_accountsWhereUniqueInput
    update: XOR<chart_of_accountsUpdateWithoutChart_of_accountsInput, chart_of_accountsUncheckedUpdateWithoutChart_of_accountsInput>
    create: XOR<chart_of_accountsCreateWithoutChart_of_accountsInput, chart_of_accountsUncheckedCreateWithoutChart_of_accountsInput>
  }

  export type chart_of_accountsUpdateWithWhereUniqueWithoutChart_of_accountsInput = {
    where: chart_of_accountsWhereUniqueInput
    data: XOR<chart_of_accountsUpdateWithoutChart_of_accountsInput, chart_of_accountsUncheckedUpdateWithoutChart_of_accountsInput>
  }

  export type chart_of_accountsUpdateManyWithWhereWithoutChart_of_accountsInput = {
    where: chart_of_accountsScalarWhereInput
    data: XOR<chart_of_accountsUpdateManyMutationInput, chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsInput>
  }

  export type ledger_entriesUpsertWithWhereUniqueWithoutChart_of_accountsInput = {
    where: ledger_entriesWhereUniqueInput
    update: XOR<ledger_entriesUpdateWithoutChart_of_accountsInput, ledger_entriesUncheckedUpdateWithoutChart_of_accountsInput>
    create: XOR<ledger_entriesCreateWithoutChart_of_accountsInput, ledger_entriesUncheckedCreateWithoutChart_of_accountsInput>
  }

  export type ledger_entriesUpdateWithWhereUniqueWithoutChart_of_accountsInput = {
    where: ledger_entriesWhereUniqueInput
    data: XOR<ledger_entriesUpdateWithoutChart_of_accountsInput, ledger_entriesUncheckedUpdateWithoutChart_of_accountsInput>
  }

  export type ledger_entriesUpdateManyWithWhereWithoutChart_of_accountsInput = {
    where: ledger_entriesScalarWhereInput
    data: XOR<ledger_entriesUpdateManyMutationInput, ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsInput>
  }

  export type ledger_entriesScalarWhereInput = {
    AND?: ledger_entriesScalarWhereInput | ledger_entriesScalarWhereInput[]
    OR?: ledger_entriesScalarWhereInput[]
    NOT?: ledger_entriesScalarWhereInput | ledger_entriesScalarWhereInput[]
    id?: IntFilter<"ledger_entries"> | number
    account_id?: IntFilter<"ledger_entries"> | number
    entry_date?: DateTimeFilter<"ledger_entries"> | Date | string
    debit_amount?: DecimalNullableFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    credit_amount?: DecimalNullableFilter<"ledger_entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"ledger_entries"> | string | null
    description?: StringNullableFilter<"ledger_entries"> | string | null
    created_at?: DateTimeNullableFilter<"ledger_entries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ledger_entries"> | Date | string | null
    deal_number?: StringNullableFilter<"ledger_entries"> | string | null
  }

  export type isin_masterCreateWithoutIsin_coupon_scheduleInput = {
    isin_issuer: string
    isin_number: string
    issue_date: Date | string
    maturity_date: Date | string
    coupon_rate: Decimal | DecimalJsLike | number | string
    series?: string | null
    coupon_date_1: Date | string
    coupon_date_2: Date | string
    day_basis: number
    currency: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type isin_masterUncheckedCreateWithoutIsin_coupon_scheduleInput = {
    id?: number
    isin_issuer: string
    isin_number: string
    issue_date: Date | string
    maturity_date: Date | string
    coupon_rate: Decimal | DecimalJsLike | number | string
    series?: string | null
    coupon_date_1: Date | string
    coupon_date_2: Date | string
    day_basis: number
    currency: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type isin_masterCreateOrConnectWithoutIsin_coupon_scheduleInput = {
    where: isin_masterWhereUniqueInput
    create: XOR<isin_masterCreateWithoutIsin_coupon_scheduleInput, isin_masterUncheckedCreateWithoutIsin_coupon_scheduleInput>
  }

  export type isin_masterUpsertWithoutIsin_coupon_scheduleInput = {
    update: XOR<isin_masterUpdateWithoutIsin_coupon_scheduleInput, isin_masterUncheckedUpdateWithoutIsin_coupon_scheduleInput>
    create: XOR<isin_masterCreateWithoutIsin_coupon_scheduleInput, isin_masterUncheckedCreateWithoutIsin_coupon_scheduleInput>
    where?: isin_masterWhereInput
  }

  export type isin_masterUpdateToOneWithWhereWithoutIsin_coupon_scheduleInput = {
    where?: isin_masterWhereInput
    data: XOR<isin_masterUpdateWithoutIsin_coupon_scheduleInput, isin_masterUncheckedUpdateWithoutIsin_coupon_scheduleInput>
  }

  export type isin_masterUpdateWithoutIsin_coupon_scheduleInput = {
    isin_issuer?: StringFieldUpdateOperationsInput | string
    isin_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    series?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_date_1?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_date_2?: DateTimeFieldUpdateOperationsInput | Date | string
    day_basis?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type isin_masterUncheckedUpdateWithoutIsin_coupon_scheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    isin_issuer?: StringFieldUpdateOperationsInput | string
    isin_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    maturity_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    series?: NullableStringFieldUpdateOperationsInput | string | null
    coupon_date_1?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_date_2?: DateTimeFieldUpdateOperationsInput | Date | string
    day_basis?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type isin_coupon_scheduleCreateWithoutIsin_masterInput = {
    coupon_number: number
    coupon_date: Date | string
    coupon_amount: Decimal | DecimalJsLike | number | string
    principal?: Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput = {
    id?: number
    coupon_number: number
    coupon_date: Date | string
    coupon_amount: Decimal | DecimalJsLike | number | string
    principal?: Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleCreateOrConnectWithoutIsin_masterInput = {
    where: isin_coupon_scheduleWhereUniqueInput
    create: XOR<isin_coupon_scheduleCreateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput>
  }

  export type isin_coupon_scheduleCreateManyIsin_masterInputEnvelope = {
    data: isin_coupon_scheduleCreateManyIsin_masterInput | isin_coupon_scheduleCreateManyIsin_masterInput[]
    skipDuplicates?: boolean
  }

  export type isin_coupon_scheduleUpsertWithWhereUniqueWithoutIsin_masterInput = {
    where: isin_coupon_scheduleWhereUniqueInput
    update: XOR<isin_coupon_scheduleUpdateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedUpdateWithoutIsin_masterInput>
    create: XOR<isin_coupon_scheduleCreateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedCreateWithoutIsin_masterInput>
  }

  export type isin_coupon_scheduleUpdateWithWhereUniqueWithoutIsin_masterInput = {
    where: isin_coupon_scheduleWhereUniqueInput
    data: XOR<isin_coupon_scheduleUpdateWithoutIsin_masterInput, isin_coupon_scheduleUncheckedUpdateWithoutIsin_masterInput>
  }

  export type isin_coupon_scheduleUpdateManyWithWhereWithoutIsin_masterInput = {
    where: isin_coupon_scheduleScalarWhereInput
    data: XOR<isin_coupon_scheduleUpdateManyMutationInput, isin_coupon_scheduleUncheckedUpdateManyWithoutIsin_masterInput>
  }

  export type isin_coupon_scheduleScalarWhereInput = {
    AND?: isin_coupon_scheduleScalarWhereInput | isin_coupon_scheduleScalarWhereInput[]
    OR?: isin_coupon_scheduleScalarWhereInput[]
    NOT?: isin_coupon_scheduleScalarWhereInput | isin_coupon_scheduleScalarWhereInput[]
    id?: IntFilter<"isin_coupon_schedule"> | number
    isin?: StringFilter<"isin_coupon_schedule"> | string
    coupon_number?: IntFilter<"isin_coupon_schedule"> | number
    coupon_date?: DateTimeFilter<"isin_coupon_schedule"> | Date | string
    coupon_amount?: DecimalFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string
    principal?: DecimalNullableFilter<"isin_coupon_schedule"> | Decimal | DecimalJsLike | number | string | null
  }

  export type chart_of_accountsCreateWithoutLedger_entriesInput = {
    account_code: string
    name: string
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    account_types: account_typesCreateNestedOneWithoutChart_of_accountsInput
    chart_of_accounts?: chart_of_accountsCreateNestedOneWithoutOther_chart_of_accountsInput
    other_chart_of_accounts?: chart_of_accountsCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsUncheckedCreateWithoutLedger_entriesInput = {
    id?: number
    account_code: string
    name: string
    account_type_id: number
    parent_account_id?: number | null
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedCreateNestedManyWithoutChart_of_accountsInput
  }

  export type chart_of_accountsCreateOrConnectWithoutLedger_entriesInput = {
    where: chart_of_accountsWhereUniqueInput
    create: XOR<chart_of_accountsCreateWithoutLedger_entriesInput, chart_of_accountsUncheckedCreateWithoutLedger_entriesInput>
  }

  export type chart_of_accountsUpsertWithoutLedger_entriesInput = {
    update: XOR<chart_of_accountsUpdateWithoutLedger_entriesInput, chart_of_accountsUncheckedUpdateWithoutLedger_entriesInput>
    create: XOR<chart_of_accountsCreateWithoutLedger_entriesInput, chart_of_accountsUncheckedCreateWithoutLedger_entriesInput>
    where?: chart_of_accountsWhereInput
  }

  export type chart_of_accountsUpdateToOneWithWhereWithoutLedger_entriesInput = {
    where?: chart_of_accountsWhereInput
    data: XOR<chart_of_accountsUpdateWithoutLedger_entriesInput, chart_of_accountsUncheckedUpdateWithoutLedger_entriesInput>
  }

  export type chart_of_accountsUpdateWithoutLedger_entriesInput = {
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_types?: account_typesUpdateOneRequiredWithoutChart_of_accountsNestedInput
    chart_of_accounts?: chart_of_accountsUpdateOneWithoutOther_chart_of_accountsNestedInput
    other_chart_of_accounts?: chart_of_accountsUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateWithoutLedger_entriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_type_id?: IntFieldUpdateOperationsInput | number
    parent_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type portfolio_masterCreateWithoutOther_portfolio_masterInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    portfolio_master?: portfolio_masterCreateNestedOneWithoutOther_portfolio_masterInput
  }

  export type portfolio_masterUncheckedCreateWithoutOther_portfolio_masterInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    parent_portfolio_id?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type portfolio_masterCreateOrConnectWithoutOther_portfolio_masterInput = {
    where: portfolio_masterWhereUniqueInput
    create: XOR<portfolio_masterCreateWithoutOther_portfolio_masterInput, portfolio_masterUncheckedCreateWithoutOther_portfolio_masterInput>
  }

  export type portfolio_masterCreateWithoutPortfolio_masterInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_portfolio_master?: portfolio_masterCreateNestedManyWithoutPortfolio_masterInput
  }

  export type portfolio_masterUncheckedCreateWithoutPortfolio_masterInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_portfolio_master?: portfolio_masterUncheckedCreateNestedManyWithoutPortfolio_masterInput
  }

  export type portfolio_masterCreateOrConnectWithoutPortfolio_masterInput = {
    where: portfolio_masterWhereUniqueInput
    create: XOR<portfolio_masterCreateWithoutPortfolio_masterInput, portfolio_masterUncheckedCreateWithoutPortfolio_masterInput>
  }

  export type portfolio_masterCreateManyPortfolio_masterInputEnvelope = {
    data: portfolio_masterCreateManyPortfolio_masterInput | portfolio_masterCreateManyPortfolio_masterInput[]
    skipDuplicates?: boolean
  }

  export type portfolio_masterUpsertWithoutOther_portfolio_masterInput = {
    update: XOR<portfolio_masterUpdateWithoutOther_portfolio_masterInput, portfolio_masterUncheckedUpdateWithoutOther_portfolio_masterInput>
    create: XOR<portfolio_masterCreateWithoutOther_portfolio_masterInput, portfolio_masterUncheckedCreateWithoutOther_portfolio_masterInput>
    where?: portfolio_masterWhereInput
  }

  export type portfolio_masterUpdateToOneWithWhereWithoutOther_portfolio_masterInput = {
    where?: portfolio_masterWhereInput
    data: XOR<portfolio_masterUpdateWithoutOther_portfolio_masterInput, portfolio_masterUncheckedUpdateWithoutOther_portfolio_masterInput>
  }

  export type portfolio_masterUpdateWithoutOther_portfolio_masterInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portfolio_master?: portfolio_masterUpdateOneWithoutOther_portfolio_masterNestedInput
  }

  export type portfolio_masterUncheckedUpdateWithoutOther_portfolio_masterInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_portfolio_id?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type portfolio_masterUpsertWithWhereUniqueWithoutPortfolio_masterInput = {
    where: portfolio_masterWhereUniqueInput
    update: XOR<portfolio_masterUpdateWithoutPortfolio_masterInput, portfolio_masterUncheckedUpdateWithoutPortfolio_masterInput>
    create: XOR<portfolio_masterCreateWithoutPortfolio_masterInput, portfolio_masterUncheckedCreateWithoutPortfolio_masterInput>
  }

  export type portfolio_masterUpdateWithWhereUniqueWithoutPortfolio_masterInput = {
    where: portfolio_masterWhereUniqueInput
    data: XOR<portfolio_masterUpdateWithoutPortfolio_masterInput, portfolio_masterUncheckedUpdateWithoutPortfolio_masterInput>
  }

  export type portfolio_masterUpdateManyWithWhereWithoutPortfolio_masterInput = {
    where: portfolio_masterScalarWhereInput
    data: XOR<portfolio_masterUpdateManyMutationInput, portfolio_masterUncheckedUpdateManyWithoutPortfolio_masterInput>
  }

  export type portfolio_masterScalarWhereInput = {
    AND?: portfolio_masterScalarWhereInput | portfolio_masterScalarWhereInput[]
    OR?: portfolio_masterScalarWhereInput[]
    NOT?: portfolio_masterScalarWhereInput | portfolio_masterScalarWhereInput[]
    portfolio_id?: StringFilter<"portfolio_master"> | string
    portfolio_name?: StringFilter<"portfolio_master"> | string
    portfolio_type?: StringNullableFilter<"portfolio_master"> | string | null
    entity_business_unit?: StringNullableFilter<"portfolio_master"> | string | null
    fund_manager_user_id?: StringNullableFilter<"portfolio_master"> | string | null
    base_currency?: StringNullableFilter<"portfolio_master"> | string | null
    benchmark?: StringNullableFilter<"portfolio_master"> | string | null
    start_date?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    end_date?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    status?: Enumportfolio_master_statusNullableFilter<"portfolio_master"> | $Enums.portfolio_master_status | null
    risk_profile?: Enumportfolio_master_risk_profileNullableFilter<"portfolio_master"> | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: Enumportfolio_master_investment_horizonNullableFilter<"portfolio_master"> | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: DecimalNullableFilter<"portfolio_master"> | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: StringNullableFilter<"portfolio_master"> | string | null
    notes_description?: StringNullableFilter<"portfolio_master"> | string | null
    parent_portfolio_id?: StringNullableFilter<"portfolio_master"> | string | null
    valuation_method?: StringNullableFilter<"portfolio_master"> | string | null
    accounting_treatment?: StringNullableFilter<"portfolio_master"> | string | null
    rebalancing_frequency?: StringNullableFilter<"portfolio_master"> | string | null
    external_reference_code?: StringNullableFilter<"portfolio_master"> | string | null
    tags_categories?: StringNullableFilter<"portfolio_master"> | string | null
    created_at?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"portfolio_master"> | Date | string | null
  }

  export type chart_of_accountsCreateManyAccount_typesInput = {
    id?: number
    account_code: string
    name: string
    parent_account_id?: number | null
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chart_of_accountsUpdateWithoutAccount_typesInput = {
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chart_of_accounts?: chart_of_accountsUpdateOneWithoutOther_chart_of_accountsNestedInput
    other_chart_of_accounts?: chart_of_accountsUpdateManyWithoutChart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateWithoutAccount_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateManyWithoutAccount_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chart_of_accountsCreateManyChart_of_accountsInput = {
    id?: number
    account_code: string
    name: string
    account_type_id: number
    description?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ledger_entriesCreateManyChart_of_accountsInput = {
    id?: number
    entry_date: Date | string
    debit_amount?: Decimal | DecimalJsLike | number | string | null
    credit_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    description?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deal_number?: string | null
  }

  export type chart_of_accountsUpdateWithoutChart_of_accountsInput = {
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_types?: account_typesUpdateOneRequiredWithoutChart_of_accountsNestedInput
    other_chart_of_accounts?: chart_of_accountsUpdateManyWithoutChart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateWithoutChart_of_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_type_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_chart_of_accounts?: chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsNestedInput
    ledger_entries?: ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsNestedInput
  }

  export type chart_of_accountsUncheckedUpdateManyWithoutChart_of_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_type_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ledger_entriesUpdateWithoutChart_of_accountsInput = {
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ledger_entriesUncheckedUpdateWithoutChart_of_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ledger_entriesUncheckedUpdateManyWithoutChart_of_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    debit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    credit_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deal_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type isin_coupon_scheduleCreateManyIsin_masterInput = {
    id?: number
    coupon_number: number
    coupon_date: Date | string
    coupon_amount: Decimal | DecimalJsLike | number | string
    principal?: Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUpdateWithoutIsin_masterInput = {
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUncheckedUpdateWithoutIsin_masterInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type isin_coupon_scheduleUncheckedUpdateManyWithoutIsin_masterInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_number?: IntFieldUpdateOperationsInput | number
    coupon_date?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    principal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type portfolio_masterCreateManyPortfolio_masterInput = {
    portfolio_id: string
    portfolio_name: string
    portfolio_type?: string | null
    entity_business_unit?: string | null
    fund_manager_user_id?: string | null
    base_currency?: string | null
    benchmark?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    status?: $Enums.portfolio_master_status | null
    risk_profile?: $Enums.portfolio_master_risk_profile | null
    investment_horizon?: $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: string | null
    notes_description?: string | null
    valuation_method?: string | null
    accounting_treatment?: string | null
    rebalancing_frequency?: string | null
    external_reference_code?: string | null
    tags_categories?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type portfolio_masterUpdateWithoutPortfolio_masterInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_portfolio_master?: portfolio_masterUpdateManyWithoutPortfolio_masterNestedInput
  }

  export type portfolio_masterUncheckedUpdateWithoutPortfolio_masterInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_portfolio_master?: portfolio_masterUncheckedUpdateManyWithoutPortfolio_masterNestedInput
  }

  export type portfolio_masterUncheckedUpdateManyWithoutPortfolio_masterInput = {
    portfolio_id?: StringFieldUpdateOperationsInput | string
    portfolio_name?: StringFieldUpdateOperationsInput | string
    portfolio_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_business_unit?: NullableStringFieldUpdateOperationsInput | string | null
    fund_manager_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    base_currency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumportfolio_master_statusFieldUpdateOperationsInput | $Enums.portfolio_master_status | null
    risk_profile?: NullableEnumportfolio_master_risk_profileFieldUpdateOperationsInput | $Enums.portfolio_master_risk_profile | null
    investment_horizon?: NullableEnumportfolio_master_investment_horizonFieldUpdateOperationsInput | $Enums.portfolio_master_investment_horizon | null
    target_yield_return?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    compliance_rules_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes_description?: NullableStringFieldUpdateOperationsInput | string | null
    valuation_method?: NullableStringFieldUpdateOperationsInput | string | null
    accounting_treatment?: NullableStringFieldUpdateOperationsInput | string | null
    rebalancing_frequency?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_code?: NullableStringFieldUpdateOperationsInput | string | null
    tags_categories?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}